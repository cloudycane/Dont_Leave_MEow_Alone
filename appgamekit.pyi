"""
This module wraps AppGameKit functionality making it available for use in Python 3.

If you like and use this module, please purchase AppGameKit.  Without it this project would not have been possible.
AppGameKit can deploy apps to Windows, Mac, Linux, iOS, and Android and is available from The Game Creators at
https://www.appgamekit.com/.

AppGameKit for Python v2022.09.28

**USEFUL LINKS**

* Support for this module: https://fascimania.itch.io/appgamekit-for-python
* AppGameKit forums: https://forum.thegamecreators.com/
* AppGameKit documentation: https://www.appgamekit.com/documentation/home.html

**END USER LICENSE AGREEMENT**

In addition to AppGameKit's EULA:

* The end user is permitted to create any type of project with this module, freeware or commercial, even in the event
  that this project is removed from distribution.
* The end user agrees not to distribute this module except as part of their game's distribution package.

**COPYRIGHT AND LICENSE**

AppGameKit and the AppGameKit Logo are copyright The Game Creators Ltd.  All Rights Reserved.

AppGameKit for Python is officially licensed by The Game Creators Ltd to Adam Biser.
"""
from typing import Optional, Union

# PYD version
__version__ = "2022.09.28"  # type: str

# Anti-alias modes - set_antialias_mode
AA_NONE = 0  # type: int
AA_4XMSAA = 1  # type: int

# Alignment - create_advert, create_advert_ex, set_advert_location, set_advert_location_ex, set_text_alignment
ALIGN_LEFT = 0  # type: int
ALIGN_CENTER = 1  # type: int
ALIGN_RIGHT = 2  # type: int
ALIGN_TOP = 0  # type: int
ALIGN_BOTTOM = 2  # type: int

# Anisotropic Friction types - set_object_3d_physics_anisotropic_friction
ANISOTROPIC_FRICTION_DISABLED = 0  # type: int
ANISOTROPIC_FRICTION = 1  # type: int
ANISOTROPIC_ROLLING_FRICTION = 2  # type: int

# Axis - add_object_shape_capsule, add_object_shape_cone, add_object_shape_cylinder, create_3d_physics_character_controller, create_object_capsule, set_object_shape_capsule, set_object_shape_cone, set_object_shape_cylinder
AXIS_X = 0  # type: int
AXIS_Y = 1  # type: int
AXIS_Z = 2  # type: int

# Ad content rating for AdMob - set_admob_child_rating
ADMOB_NORMAL_ADS = 0  # type: int
ADMOB_CHILD_SAFE_ADS = 1  # type: int

# Ad banner sizes - create_advert, create_advert_ex
ADVERT_BANNER = 0  # type: int
ADVERT_LARGE_BANNER = 1  # type: int
ADVERT_MEDIUM_RECTANGLE = 2  # type: int
ADVERT_FULL_BANNER = 3  # type: int
ADVERT_LEADERBOARD = 4  # type: int
ADVERT_SMART_BANNER = 5  # type: int
ADVERT_FLUID_BANNER = 6  # type: int

# Alpha blend modes - set_object_blend_modes
BLEND_ZERO = 0  # type: int
BLEND_ONE = 1  # type: int
BLEND_SRC_ALPHA = 2  # type: int
BLEND_ONE_MINUS_SRC_ALPHA = 3  # type: int
BLEND_DST_ALPHA = 4  # type: int
BLEND_ONE_MINUS_DST_ALPHA = 5  # type: int
BLEND_SRC_COLOR = 6  # type: int
BLEND_ONE_MINUS_SRC_COLOR = 7  # type: int
BLEND_DST_COLOR = 8  # type: int
BLEND_ONE_MINUS_DST_COLOR = 9  # type: int
BLEND_SRC_ALPHA_SATURATE = 10  # type: int

# Device camera types - returned by get_device_camera_type
CAMERA_TYPE_BACK_FACING = 1  # type: int
CAMERA_TYPE_FRONT_FACING = 2  # type: int
CAMERA_TYPE_UNKNOWN = 0  # type: int

# Physics character controler move types - move_3d_physics_character_controller
CONTROLLER_MOVE_STOP = 0  # type: int
CONTROLLER_MOVE_FORWARD = 1  # type: int
CONTROLLER_MOVE_BACKWARD = 2  # type: int
CONTROLLER_MOVE_STRAFE_LEFT = 3  # type: int
CONTROLLER_MOVE_STRAFE_RIGHT = 4  # type: int

# Color mask channels - set_image_mask
COLOR_CHANNEL_RED = 1  # type: int
COLOR_CHANNEL_GREEN = 2  # type: int
COLOR_CHANNEL_BLUE = 3  # type: int
COLOR_CHANNEL_ALPHA = 4  # type: int

# Cull modes - set_object_cull_mode
CULL_FRONT_AND_BACK = 0  # type: int
CULL_FRONT = 1  # type: int
CULL_BACK = 2  # type: int

# Depth read modes - set_object_depth_read_mode
DEPTH_NEVER = 0  # type: int
DEPTH_LT = 1  # type: int
DEPTH_EQUAL = 2  # type: int
DEPTH_LT_OR_EQUAL = 3  # type: int
DEPTH_GT = 4  # type: int
DEPTH_NOT_EQUAL = 5  # type: int
DEPTH_GT_OR_EQUAL = 6  # type: int
DEPTH_ALWAYS = 7  # type: int

# Edit box wrap modes - set_edit_box_wrap_mode
EDIT_BOX_WRAP_SCROLL = 0  # type: int
EDIT_BOX_WRAP_NEW_LINE = 1  # type: int

# Error modes - set_error_mode
ERROR_MODE_IGNORE = 0  # type: int
ERROR_MODE_REPORT = 1  # type: int
ERROR_MODE_STOP = 2  # type: int

# Folder modes - get_file_count, get_folder_count, get_first_file, get_first_folder
FOLDER_MODE_READ_ONLY = 0  # type: int
FOLDER_MODE_WRITE_ONLY = 1  # type: int
FOLDER_MODE_BOTH = 2  # type: int

# Texture filters - set_default_mag_filter, set_default_min_filter, set_image_mag_filter, set_image_min_filter, set_text_default_mag_filter, set_text_default_min_filter
FILTER_NEAREST = 0  # type: int
FILTER_LINEAR = 1  # type: int

# HTTP response status - get_http_response_ready
HTTP_RESPONSE_STATUS_FAILED = -1  # type: int
HTTP_RESPONSE_STATUS_IN_PROGRESS = 0  # type: int
HTTP_RESPONSE_STATUS_COMPLETED = 1  # type: int

# Text input state - returned by get_text_input_state
INPUT_TEXT_ACTIVE = 0  # type: int
INPUT_TEXT_DONE = 1  # type: int

# Render image modes - create_render_image
IMAGE_RGBA = 0  # type: int
IMAGE_DEPTH = 1  # type: int

# Color interpolation modes - set_3d_particles_color_interpolation, set_particles_color_interpolation
INTERPOLATE_NONE = 0  # type: int
INTERPOLATE_SMOOTH = 1  # type: int

# Keyboard types - returned by get_keyboard_exists
KEYBOARD_NONE = 0  # type: int
KEYBOARD_FULL_SIZE = 1  # type: int
KEYBOARD_VIRTUAL = 2  # type: int

# Network variable types - set_network_local_float, set_network_local_integer
NETWORK_VAR_TYPE_NORMAL = 0  # type: int
NETWORK_VAR_TYPE_RESETTING = 1  # type: int

# Orientation mode - returned by get_orientation
ORIENTATION_PORTRAIT = 1  # type: int
ORIENTATION_PORTRAIT_180 = 2  # type: int
ORIENTATION_LANDSCAPE_CCW = 3  # type: int
ORIENTATION_LANDSCAPE_CW = 4  # type: int

# Physics modes - set_sprite_physics_on
PHYSICS_MODE_STATIC = 1  # type: int
PHYSICS_MODE_DYNAMIC = 2  # type: int
PHYSICS_MODE_KINEMATIC = 3  # type: int

# Point light modes - set_point_light_mode
POINT_LIGHT_VERTEX = 0  # type: int
POINT_LIGHT_PIXEL = 1  # type: int

# Ray cast contact - ray_cast_3d_physics, ray_cast_3d_physics_object
RAY_CAST_CLOSEST = 0  # type: int
RAY_CAST_ALL = 1  # type: int

# Resolution Modes - set_resolution_mode
RESOLUTION_MODE_LOW = 0  # type: int
RESOLUTION_MODE_HIGH = 1  # type: int

# Rotation modes - set_particles_face_direction
ROTATE_NORMAL = 0  # type: int
ROTATE_MOVE_DIRECTION = 1  # type: int

# Music seek modes - seek_music_ogg
SEEK_ABSOLUTE = 0  # type: int
SEEK_RELATIVE = 1  # type: int

# Shadow mapping modes - set_shadow_mapping_mode
SHADOW_MAP_NONE = 0  # type: int
SHADOW_MAP_UNIFORM = 1  # type: int
SHADOW_MAP_LISPSM = 2  # type: int
SHADOW_MAP_CASCADE = 3  # type: int

# Shadow smoothing - set_shadow_smoothing
SHADOW_SMOOTHING_NONE = 0  # type: int
SHADOW_SMOOTHING_MULTISAMPLE = 1  # type: int
SHADOW_SMOOTHING_RANDOM_MULTISAMPLE = 2  # type: int

# Sprite shapes - set_sprite_shape
SHAPE_NONE = 0  # type: int
SHAPE_CIRCLE = 1  # type: int
SHAPE_BOX = 2  # type: int
SHAPE_POLYGON = 3  # type: int

# Socket states - get_socket_connected
SOCKET_STATE_DISCONNECTED = -1  # type: int
SOCKET_STATE_CONNECTING = 0  # type: int
SOCKET_STATE_CONNECTED = 1  # type: int

# Key, button, and pointer states - returned by get_button_state, get_pointer_state, get_virtual_button_state, get_raw_joystick_button_state, get_raw_key_state, get_raw_mouse_left_state, get_raw_mouse_middle_state, get_raw_mouse_right_state
STATE_UP = 0  # type: int
STATE_DOWN = 1  # type: int

# Touch types - returned by get_raw_touch_type
TOUCH_UNKNOWN = 0  # type: int
TOUCH_SHORT = 1  # type: int
TOUCH_HOLD = 2  # type: int
TOUCH_DRAG = 3  # type: int

# Transparency modes - set_object_transparency, set_3d_particles_transparency, set_particles_transparency, set_sprite_transparency, set_text_transparency, returned by get_sprite_transparency
TRANSPARENCY_NONE = 0  # type: int
TRANSPARENCY_ALPHA = 1  # type: int
TRANSPARENCY_ADDITIVE = 2  # type: int
TRANSPARENCY_CUSTOM = 3  # type: int

# Tween interpolation types - the set_tween_* methods
TWEEN_OFF = -1  # type: int
TWEEN_LINEAR = 0  # type: int
TWEEN_SMOOTH1 = 1  # type: int
TWEEN_SMOOTH2 = 2  # type: int
TWEEN_EASE_IN1 = 3  # type: int
TWEEN_EASE_IN2 = 4  # type: int
TWEEN_EASE_OUT1 = 5  # type: int
TWEEN_EASE_OUT2 = 6  # type: int
TWEEN_BOUNCE = 7  # type: int
TWEEN_OVERSHOOT = 8  # type: int

# Video load responses - load_video
VIDEO_LOAD_UNSUPPORTED = -1  # type: int
VIDEO_LOAD_ERROR = 0  # type: int
VIDEO_LOAD_SUCCESS = 1  # type: int

# UV Texture wrapping modes - set_default_wrap_u, set_default_wrap_v, set_image_wrap_u, set_image_wrap_v
WRAP_CLAMP = 0  # type: int
WRAP_REPEAT = 1  # type: int

# View zoom modes
ZOOM_TOP_LEFT = 0  # type: int
ZOOM_CENTER = 1  # type: int

# Key codes
KEY_BACKSPACE = 8  # type: int
KEY_TAB = 9  # type: int
KEY_ENTER = 13  # type: int
KEY_SHIFT = 16  # type: int
KEY_CONTROL = 17  # type: int
KEY_ALT = 18  # type: int
KEY_PAUSE = 19  # type: int
KEY_CAPSLOCK = 20  # type: int
KEY_ESCAPE = 27  # type: int
KEY_SPACE = 32  # type: int
KEY_PAGE_UP = 33  # type: int
KEY_PAGE_DOWN = 34  # type: int
KEY_END = 35  # type: int
KEY_HOME = 36  # type: int
KEY_LEFT = 37  # type: int
KEY_UP = 38  # type: int
KEY_RIGHT = 39  # type: int
KEY_DOWN = 40  # type: int
KEY_INSERT = 45  # type: int
KEY_DELETE = 46  # type: int
KEY_NUM_0 = 48  # type: int
KEY_NUM_1 = 49  # type: int
KEY_NUM_2 = 50  # type: int
KEY_NUM_3 = 51  # type: int
KEY_NUM_4 = 52  # type: int
KEY_NUM_5 = 53  # type: int
KEY_NUM_6 = 54  # type: int
KEY_NUM_7 = 55  # type: int
KEY_NUM_8 = 56  # type: int
KEY_NUM_9 = 57  # type: int
KEY_A = 65  # type: int
KEY_B = 66  # type: int
KEY_C = 67  # type: int
KEY_D = 68  # type: int
KEY_E = 69  # type: int
KEY_F = 70  # type: int
KEY_G = 71  # type: int
KEY_H = 72  # type: int
KEY_I = 73  # type: int
KEY_J = 74  # type: int
KEY_K = 75  # type: int
KEY_L = 76  # type: int
KEY_M = 77  # type: int
KEY_N = 78  # type: int
KEY_O = 79  # type: int
KEY_P = 80  # type: int
KEY_Q = 81  # type: int
KEY_R = 82  # type: int
KEY_S = 83  # type: int
KEY_T = 84  # type: int
KEY_U = 85  # type: int
KEY_V = 86  # type: int
KEY_W = 87  # type: int
KEY_X = 88  # type: int
KEY_Y = 89  # type: int
KEY_Z = 90  # type: int
KEY_WIN_LEFT = 91  # type: int
KEY_WIN_RIGHT = 92  # type: int
KEY_MENU = 93  # type: int
KEY_NUMPAD_0 = 96  # type: int
KEY_NUMPAD_1 = 97  # type: int
KEY_NUMPAD_2 = 98  # type: int
KEY_NUMPAD_3 = 99  # type: int
KEY_NUMPAD_4 = 100  # type: int
KEY_NUMPAD_5 = 101  # type: int
KEY_NUMPAD_6 = 102  # type: int
KEY_NUMPAD_7 = 103  # type: int
KEY_NUMPAD_8 = 104  # type: int
KEY_NUMPAD_9 = 105  # type: int
KEY_ASTERISK = 106  # type: int
KEY_PLUS = 107  # type: int
KEY_SUBTRACT = 109  # type: int
KEY_DECIMAL = 110  # type: int
KEY_DIVIDE = 111  # type: int
KEY_F1 = 112  # type: int
KEY_F2 = 113  # type: int
KEY_F3 = 114  # type: int
KEY_F4 = 115  # type: int
KEY_F5 = 116  # type: int
KEY_F6 = 117  # type: int
KEY_F7 = 118  # type: int
KEY_F8 = 119  # type: int
KEY_F9 = 120  # type: int
KEY_F10 = 121  # type: int
KEY_F11 = 122  # type: int
KEY_F12 = 123  # type: int
KEY_NUMLOCK = 144  # type: int
KEY_SCROLLLOCK = 145  # type: int
KEY_VOLUME_MUTE = 173  # type: int
KEY_VOLUME_DOWN = 174  # type: int
KEY_VOLUME_UP = 175  # type: int
KEY_MEDIA_NEXT = 176  # type: int
KEY_MEDIA_PREV = 177  # type: int
KEY_MEDIA_STOP = 178  # type: int
KEY_MEDIA_PLAY = 179  # type: int
KEY_SEMICOLON = 186  # type: int
KEY_EQUALS = 187  # type: int
KEY_COMMA = 188  # type: int
KEY_MINUS = 189  # type: int
KEY_PERIOD = 190  # type: int
KEY_SLASH = 191  # type: int
KEY_GRAVE = 192  # type: int
KEY_TILDE = 192  # type: int
KEY_LEFT_BRACKET = 219  # type: int
KEY_BACKSLASH = 220  # type: int
KEY_RIGHT_BRACKET = 221  # type: int
KEY_APOSTROPHE = 222  # type: int
KEY_LEFT_SHIFT = 257  # type: int
KEY_RIGHT_SHIFT = 258  # type: int
KEY_LEFT_CTRL = 259  # type: int
KEY_RIGHT_CTRL = 260  # type: int
KEY_LEFT_ALT = 261  # type: int
KEY_RIGHT_ALT = 262  # type: int
KEY_TOP_0 = 263  # type: int
KEY_TOP_1 = 264  # type: int
KEY_TOP_2 = 265  # type: int
KEY_TOP_3 = 266  # type: int
KEY_TOP_4 = 267  # type: int
KEY_TOP_5 = 268  # type: int
KEY_TOP_6 = 269  # type: int
KEY_TOP_7 = 270  # type: int
KEY_TOP_8 = 271  # type: int
KEY_TOP_9 = 272  # type: int


class Application:
    """
    This class wraps the create_window and destroy_window methods and can be used in a with block.
    This provides a cleaner look alternative to using those two method in a try.. finally block.

    For example:
    ::
        with appgamekit.Application():
            pass  # Game code goes here.
    """
    pass

    def __init__(self, x: Optional[int] = None, y: Optional[int] = None, width: Optional[int] = 1024,
                 height: Optional[int] = 768, fullscreen: Optional[bool] = False, company_name: str = None,
                 app_name: str = None, show_appgamekit_logo: Optional[bool] = False) -> None:
        """
        Encapsulates creation and deletion of the graphics window.  Also initializes AppGameKit.  Only one instance of
        this class can be created.

        The parameters for this are the same as for create_window.

        By default, the write path will use the base name of the script file.  However, this can be overridden by
        setting the app_name parameter.  This parameter is ignored when running in a PyInstaller bundle.

        Providing company_name is optional and is used to build the write path.

        :param Optional[int] x: Initial x-coordinate of the window's upper left corner. If None, then the window centers
            horizontally.
        :param Optional[int] y: Initial y-coordinate of the window's upper left corner. If None, then the window centers
            vertically.
        :param Optional[int] width: Initial width of the window. Default is 1024.
        :param Optional[int] height: Initial height of the window. Default is 768.
        :param Optional[Union[bool, int]] fullscreen: When True, begins full screen; otherwise windowed.
        :param Optional[str] company_name: The company name for your app. The company name becomes a folder in the write
            file path.
        :param Optional[str] app_name: Overrides the app name derived from the script file name.  Ignored while running
            in a PyInstaller bundle.
        :param Optional[Union[bool, int]] show_appgamekit_logo: When True, shows the AppGameKit logo when the
            application starts.
        :rtype: None
        """
        pass

    def __del__(self):
        """Closes the AppGameKit window and cleans up resources."""
        pass

    def __enter__(self):
        """Allows the class to be used in a with block."""
        pass

    def __exit__(self, exc_type, exc_value, traceback):
        """Closes the AppGameKit window and cleans up resources."""
        pass


class PluginFunction:
    """
    A plugin function.
    Use `import_plugin()` to load a plugin and its functions.
    """
    pass

    def __init__(self, funcname: str, plugin: "Plugin", restype=None, *argtypes):
        """
        Creates a plugin function.

        :param str funcname: The exported function name within the plugin library.
        :param Plugin plugin: The plugin instance.
        :param restype: The result type.
        :param argtypes: The argument types.
        """
        pass

    def __call__(self, *args):
        """
        Calls the plugin function.

        :param args: The arguments.
        :return: The result
        """
        pass

    def __repr__(self):
        """String representation."""
        pass


class Plugin:
    """
    A plugin for AppGameKit.
    Use `import_plugin()` to load a plugin and its functions.

    Functions are accessed either as callable attributes.
    ie:
    ::
        plugin.function()
    """
    pass

    def __init__(self, name):
        """
        Creates and initializes a plugin for usage.

        :param name: The plugin name.
        """
        pass

    @property
    def name(self):
        """The plugin name."""
        pass

    @property
    def filename(self):
        """The plugin's full filename."""
        pass

    def __repr__(self):
        """String representation."""
        pass

    def __getattr__(self, name):
        """
        Access plugin functions as callable attributes.

        Calling a functions that doesn't exist within the plugin raises an AttributeError.
        """
        pass


def create_distance_joint(sprite_id1: int, sprite_id2: int, x1: Union[float, int], y1: Union[float,
                          int], x2: Union[float, int], y2: Union[float, int],
                          can_collide: Union[bool, int]) -> int:
    """
    Creates a distance joint between two sprites.

    The distance joint keeps the sprites a certain distance apart whilst being allowed to rotate freely around the
    anchor points. Specify two anchor points in world coordinates with the sprites already at the desired distance
    apart. The anchor points can be offset from the sprite positions. A joint may be deleted by the system if any of the
    sprites it connects are deleted.

    :param int sprite_id1: The ID of the first sprite to join.
    :param int sprite_id2: The ID of the second sprite to join.
    :param Union[float, int] x1: The x coordinate of the sprite 1 anchor point.
    :param Union[float, int] y1: The y coordinate of the sprite 1 anchor point.
    :param Union[float, int] x2: The x coordinate of the sprite 2 anchor point.
    :param Union[float, int] y2: The y coordinate of the sprite 2 anchor point.
    :param Union[bool, int] can_collide: Set whether the two sprites connected by the joint can collide with one
        another.
    :return: The new joint ID.
    :rtype: int
    """
    pass    


def create_distance_joint_id(joint_id: int, sprite_id1: int, sprite_id2: int, x1: Union[float, int],
                             y1: Union[float, int], x2: Union[float, int], y2: Union[float, int],
                             can_collide: Union[bool, int]) -> None:
    """
    Creates a distance joint between two sprites.

    The distance joint keeps the sprites a certain distance apart whilst being allowed to rotate freely around the
    anchor points. Specify two anchor points in world coordinates with the sprites already at the desired distance
    apart. The anchor points can be offset from the sprite positions. A joint may be deleted by the system if any of the
    sprites it connects are deleted.

    :param int joint_id: The ID to use for this joint.
    :param int sprite_id1: The ID of the first sprite to join.
    :param int sprite_id2: The ID of the second sprite to join.
    :param Union[float, int] x1: The x coordinate of the sprite 1 anchor point.
    :param Union[float, int] y1: The y coordinate of the sprite 1 anchor point.
    :param Union[float, int] x2: The x coordinate of the sprite 2 anchor point.
    :param Union[float, int] y2: The y coordinate of the sprite 2 anchor point.
    :param Union[bool, int] can_collide: Set whether the two sprites connected by the joint can collide with one
        another.
    :rtype: None
    """
    pass    


def create_gear_joint(joint_id1: int, joint_id2: int, ratio: Union[float, int]) -> int:
    """
    Creates a gear joint between two existing joints.

    The gear joint allows appearance of two existing joints to be locked together in perfect friction. The sprites that
    will be joined will be sprite 2 on both joints, sprite 1 on both joints must be a static sprite. A joint ID will be
    returned to reference this joint later, a joint may be deleted by the system if any of the sprites it connects are
    deleted. This joint should be deleted before any of the joints it depends on are deleted.

    :param int joint_id1: The ID of the first joint to join.
    :param int joint_id2: The ID of the second joint to join.
    :param Union[float, int] ratio: The gear ratio to use in moving one joint from the other.
    :rtype: int
    """
    pass    


def create_gear_joint_id(joint_id: int, joint_id1: int, joint_id2: int, ratio: Union[float,
                         int]) -> None:
    """
    Creates a gear joint between two existing joints.

    The gear joint allows appearance of two existing joints to be locked together in perfect friction. The sprites that
    will be joined will be sprite 2 on both joints, sprite 1 on both joints must be a static sprite. A joint ID will be
    returned to reference this joint later, a joint may be deleted by the system if any of the sprites it connects are
    deleted. This joint should be deleted before any of the joints it depends on are deleted.

    :param int joint_id: The ID for the gear joint.
    :param int joint_id1: The ID of the first joint to join.
    :param int joint_id2: The ID of the second joint to join.
    :param Union[float, int] ratio: The gear ratio to use in moving one joint from the other.
    :rtype: None
    """
    pass    


def create_line_joint(sprite_id1: int, sprite_id2: int, anchor_x: Union[float, int],
                      anchor_y: Union[float, int], axis_x: Union[float, int], axis_y: Union[float,
                      int], can_collide: Union[bool, int]) -> int:
    """
    Creates a line joint between two sprites.

    The line joint allows the sprites to only move along a given axis relative to each other whilst rotating freely at
    either end. It is similar to a prismatic joint except that relative rotation is allowed.

    Specify a single anchor point in world coordinates with the sprites already at the desired relative position, at the
    piston's minimal extent. From this point the sprites will be allowed to separate along the given axis relative to
    one another. The anchor point can be offset from the sprite center positions. A joint ID will be returned to
    reference this joint later, a joint may be deleted by the system if any of the sprites it connects are deleted. This
    joint supports motors and limits. Box2D has renamed this joint the Wheel Joint and it now contains a spring
    component to simulate a vehicle wheel. The AGK command name will remain the same for backwards compatibility,
    however the functionality may have changed.

    :param int sprite_id1: The ID of the first sprite to join.
    :param int sprite_id2: The ID of the second sprite to join.
    :param Union[float, int] anchor_x: The x coordinate of the anchor point.
    :param Union[float, int] anchor_y: The y coordinate of the anchor point.
    :param Union[float, int] axis_x: The x component of the axis.
    :param Union[float, int] axis_y: The y component of the axis.
    :param Union[bool, int] can_collide: Set whether the two sprites connected by the joint can collide with one
        another.
    :rtype: int
    """
    pass    


def create_line_joint_id(joint_id: int, sprite_id1: int, sprite_id2: int, anchor_x: Union[float,
                         int], anchor_y: Union[float, int], axis_x: Union[float, int],
                         axis_y: Union[float, int], can_collide: Union[bool, int]) -> None:
    """
    Creates a line joint between two sprites.

    The line joint allows the sprites to only move along a given axis relative to each other whilst rotating freely at
    either end. It is similar to a prismatic joint except that relative rotation is allowed.

    Specify a single anchor point in world coordinates with the sprites already at the desired relative position, at the
    piston's minimal extent. From this point the sprites will be allowed to separate along the given axis relative to
    one another. The anchor point can be offset from the sprite center positions. A joint ID will be returned to
    reference this joint later, a joint may be deleted by the system if any of the sprites it connects are deleted. This
    joint supports motors and limits. Box2D has renamed this joint the Wheel Joint and it now contains a spring
    component to simulate a vehicle wheel. The AGK command name will remain the same for backwards compatibility,
    however the functionality may have changed.

    :param int joint_id: The ID to use for this joint.
    :param int sprite_id1: The ID of the first sprite to join.
    :param int sprite_id2: The ID of the second sprite to join.
    :param Union[float, int] anchor_x: The x coordinate of the anchor point.
    :param Union[float, int] anchor_y: The y coordinate of the anchor point.
    :param Union[float, int] axis_x: The x component of the axis.
    :param Union[float, int] axis_y: The y component of the axis.
    :param Union[bool, int] can_collide: Set whether the two sprites connected by the joint can collide with one
        another.
    :rtype: None
    """
    pass    


def create_mouse_joint(sprite_id: int, anchor_x: Union[float, int], anchor_y: Union[float, int],
                       max_force: Union[float, int]) -> int:
    """
    Creates a mouse joint between a point and a sprite.

    This is typically used when dragging a shape with the mouse pointer, and attempts to move the sprite towards the
    given point using a force up to the maximum given. Specify an anchor point in world coordinates that will act as the
    initial hold point on the sprite. Any further change in the target position will attempt to move that point of the
    sprite to the new location. Use `set_joint_mouse_target()` to change the location of the target position.

    :param int sprite_id: The ID of the sprite to move.
    :param Union[float, int] anchor_x: The x coordinate of the initial anchor point on the sprite.
    :param Union[float, int] anchor_y: The y coordinate of the initial anchor point on the sprite.
    :param Union[float, int] max_force: The maximum force the joint can use to move the sprite.
    :rtype: int
    """
    pass    


def create_mouse_joint_id(joint_id: int, sprite_id: int, anchor_x: Union[float, int],
                          anchor_y: Union[float, int], max_force: Union[float, int]) -> None:
    """
    Creates a mouse joint between a point and a sprite.

    This is typically used when dragging a shape with the mouse pointer, and attempts to move the sprite towards the
    given point using a force up to the maximum given. Specify an anchor point in world coordinates that will act as the
    initial hold point on the sprite. Any further change in the target position will attempt to move that point of the
    sprite to the new location. Use `set_joint_mouse_target()` to change the location of the target position.

    :param int joint_id: The ID to use for this joint.
    :param int sprite_id: The ID of the sprite to move.
    :param Union[float, int] anchor_x: The x coordinate of the initial anchor point on the sprite.
    :param Union[float, int] anchor_y: The y coordinate of the initial anchor point on the sprite.
    :param Union[float, int] max_force: The maximum force the joint can use to move the sprite.
    :rtype: None
    """
    pass    


def create_physics_force(x: Union[float, int], y: Union[float, int], power: Union[float, int],
                         limit: Union[float, int], range: Union[float, int], fade: Union[bool,
                         int]) -> int:
    """
    Creates a global force that affects all physics sprites.

    Can be set to either attract to or repel sprites from a specific location. It returns a force ID that can be used to
    modify or delete the force later. Forces continue to act until they are deleted.

    :param Union[float, int] x: The x position of the force location in world coordinates.
    :param Union[float, int] y: The y position of the force location in world coordinates.
    :param Union[float, int] power: The strength of the force at 1 unit from the force point for fading forces, or the
        strength at all times for non fading.
    :param Union[float, int] limit: Applies to fading forces only, the maximum force that will be applied to a sprite,
        used when the sprite is closer than 1 unit.
    :param Union[float, int] range: The range that this force can act, sprites greater than this distance from the force
        point feel no effects. less than 0 means infinite range.
    :param Union[bool, int] fade: Set to True if the force should be weaker when sprites are further from the force
        point, False if the force is equal at all distances.
    :rtype: int
    """
    pass    


def create_prismatic_joint(sprite_id1: int, sprite_id2: int, anchor_x: Union[float, int],
                           anchor_y: Union[float, int], axis_x: Union[float, int],
                           axis_y: Union[float, int], can_collide: Union[bool, int]) -> int:
    """
    Creates a prismatic joint between two sprites.

    The prismatic joint allows the sprites to only move along a given axis relative to each other. It can be thought of
    as a piston with the sprites unable to rotate at each end. It is similar to a line joint except that relative
    rotation is prevented. Specify a single anchor point in world coordinates with the sprites already at the desired
    relative position, at the piston's minimal extent. From this point the sprites will be allowed to separate along the
    given axis and rotate as a whole, but not rotate relative to each other. The anchor point can be offset from the
    sprite center positions.

    A joint ID will be returned to reference this joint later, a joint may be deleted by the system if any of the
    sprites it connects are deleted.

    This joint supports motors and limits.

    :param int sprite_id1: The ID of the first sprite to join.
    :param int sprite_id2: The ID of the second sprite to join.
    :param Union[float, int] anchor_x: The x coordinate of the anchor point.
    :param Union[float, int] anchor_y: The y coordinate of the anchor point.
    :param Union[float, int] axis_x: The x component of the axis.
    :param Union[float, int] axis_y: The y component of the axis.
    :param Union[bool, int] can_collide: Set whether the two sprites connected by the joint can collide with one
        another.
    :rtype: int
    """
    pass    


def create_prismatic_joint_id(joint_id: int, sprite_id1: int, sprite_id2: int,
                              anchor_x: Union[float, int], anchor_y: Union[float, int],
                              axis_x: Union[float, int], axis_y: Union[float, int],
                              can_collide: Union[bool, int]) -> None:
    """
    Creates a prismatic joint between two sprites.

    The prismatic joint allows the sprites to only move along a given axis relative to each other. It can be thought of
    as a piston with the sprites unable to rotate at each end. It is similar to a line joint except that relative
    rotation is prevented. Specify a single anchor point in world coordinates with the sprites already at the desired
    relative position, at the piston's minimal extent. From this point the sprites will be allowed to separate along the
    given axis and rotate as a whole, but not rotate relative to each other. The anchor point can be offset from the
    sprite center positions.

    A joint ID will be returned to reference this joint later, a joint may be deleted by the system if any of the
    sprites it connects are deleted.

    This joint supports motors and limits.

    :param int joint_id: The ID to use for this joint.
    :param int sprite_id1: The ID of the first sprite to join.
    :param int sprite_id2: The ID of the second sprite to join.
    :param Union[float, int] anchor_x: The x coordinate of the anchor point.
    :param Union[float, int] anchor_y: The y coordinate of the anchor point.
    :param Union[float, int] axis_x: The x component of the axis.
    :param Union[float, int] axis_y: The y component of the axis.
    :param Union[bool, int] can_collide: Set whether the two sprites connected by the joint can collide with one
        another.
    :rtype: None
    """
    pass    


def create_pulley_joint(joint_id: int, sprite_id1: int, sprite_id2: int, ground_x1: Union[float,
                        int], ground_y1: Union[float, int], ground_x2: Union[float, int],
                        ground_y2: Union[float, int], anchor_x1: Union[float, int],
                        anchor_y1: Union[float, int], anchor_x2: Union[float, int],
                        anchor_y2: Union[float, int], ratio: Union[float, int],
                        can_collide: Union[bool, int]) -> None:
    """
    Creates a pulley joint between two sprites.

    The anchor points are world space coordinates that attach the joint to the sprite, the anchor points do not have to
    be on the sprite's center, or anywhere near the sprite, but this point will become the new center of rotation for
    the time the sprite is attached to the pulley. The ground points are where the pulley rope will attach to the
    imaginary pulleys, and will remain fixed for the life of the joint, they need not be in the same location. The ratio
    value determines the gear ratio between the two sides of the pulley, for example a value of 2 would mean that sprite
    1 moves at twice the speed of sprite 2, but will experience half the force applied to sprite 2.

    :param int joint_id: The ID to use for this joint.
    :param int sprite_id1: The ID of the first sprite to join.
    :param int sprite_id2: The ID of the second sprite to join.
    :param Union[float, int] ground_x1: The x coordinate of the ground point for sprite 1.
    :param Union[float, int] ground_y1: The y coordinate of the ground point for sprite 1.
    :param Union[float, int] ground_x2: The x coordinate of the ground point for sprite 2.
    :param Union[float, int] ground_y2: The y coordinate of the ground point for sprite 2.
    :param Union[float, int] anchor_x1: The x coordinate of the anchor point for sprite 1.
    :param Union[float, int] anchor_y1: The y coordinate of the anchor point for sprite 1.
    :param Union[float, int] anchor_x2: The x coordinate of the anchor point for sprite 2.
    :param Union[float, int] anchor_y2: The y coordinate of the anchor point for sprite 2.
    :param Union[float, int] ratio: The ratio between the two sides of the pulley.
    :param Union[bool, int] can_collide: Set whether the two sprites connected by the joint can collide with one
        another.
    :rtype: None
    """
    pass    


def create_pulley_joint2(sprite_id1: int, sprite_id2: int, ratio: Union[float, int],
                         can_collide: Union[bool, int]) -> None:
    """
    Creates a pulley joint between two sprites.

    This the first half of a two command setup. Due to the number of parameters required you must call
    `finish_pulley_joint()` with the rest of the parameters to create the joint. This command returns nothing, the joint
    ID is returned by `finish_pulley_joint()`.

    :param int sprite_id1: The ID of the first sprite to join.
    :param int sprite_id2: The ID of the second sprite to join.
    :param Union[float, int] ratio: The ratio between the two sides of the pulley.
    :param Union[bool, int] can_collide: Set whether the two sprites connected by the joint can collide with one
        another.
    :rtype: None
    """
    pass    


def create_revolute_joint(sprite_id1: int, sprite_id2: int, x: Union[float, int], y: Union[float,
                          int], can_collide: Union[bool, int]) -> int:
    """
    Creates a revolute joint between two sprites.

    The revolute joint allows the sprites to only rotate around the given point. Specify a single anchor point in world
    coordinates with the sprites already at the desired relative position. The anchor point can be offset from the
    sprite center positions.

    A joint ID will be returned to reference this joint later, a joint may be deleted by the system if any of the
    sprites it connects are deleted.

    This joint supports motors and limits.

    :param int sprite_id1: The ID of the first sprite to join.
    :param int sprite_id2: The ID of the second sprite to join.
    :param Union[float, int] x: The x coordinate of the anchor point.
    :param Union[float, int] y: The y coordinate of the anchor point.
    :param Union[bool, int] can_collide: Set whether the two sprites connected by the joint can collide with one
        another.
    :rtype: int
    """
    pass    


def create_revolute_joint_id(joint_id: int, sprite_id1: int, sprite_id2: int, x: Union[float, int],
                             y: Union[float, int], can_collide: Union[bool, int]) -> None:
    """
    Creates a revolute joint between two sprites.

    The revolute joint allows the sprites to only rotate around the given point. Specify a single anchor point in world
    coordinates with the sprites already at the desired relative position. The anchor point can be offset from the
    sprite center positions.

    A joint ID will be returned to reference this joint later, a joint may be deleted by the system if any of the
    sprites it connects are deleted.

    This joint supports motors and limits.

    :param int joint_id: The ID to use for this joint.
    :param int sprite_id1: The ID of the first sprite to join.
    :param int sprite_id2: The ID of the second sprite to join.
    :param Union[float, int] x: The x coordinate of the anchor point.
    :param Union[float, int] y: The y coordinate of the anchor point.
    :param Union[bool, int] can_collide: Set whether the two sprites connected by the joint can collide with one
        another.
    :rtype: None
    """
    pass    


def create_rope_joint(sprite_id1: int, sprite_id2: int, x1: Union[float, int], y1: Union[float,
                      int], x2: Union[float, int], y2: Union[float, int], max_length: Union[float,
                      int], can_collide: Union[bool, int]) -> int:
    """
    Creates a rope joint between two sprites.

    The rope joint enforces a maximum distance between the sprites without any other restrictions. It does not stop them
    getting closer together. Specify two anchor points in world coordinates with the maximum length you want to allow,
    the current position of the sprites does not affect the initialisation of the joint. The anchor points can be offset
    from the sprite positions. A joint may be deleted by the system if any of the sprites it connects are deleted.

    :param int sprite_id1: The ID of the first sprite to join.
    :param int sprite_id2: The ID of the second sprite to join.
    :param Union[float, int] x1: The x coordinate of the sprite 1 anchor point.
    :param Union[float, int] y1: The y coordinate of the sprite 1 anchor point.
    :param Union[float, int] x2: The x coordinate of the sprite 2 anchor point.
    :param Union[float, int] y2: The y coordinate of the sprite 2 anchor point.
    :param Union[float, int] max_length: The maximum length allowed between the sprite anchor points.
    :param Union[bool, int] can_collide: Set whether the two sprites connected by the joint can collide with one
        another.
    :rtype: int
    """
    pass    


def create_rope_joint_id(joint_id: int, sprite_id1: int, sprite_id2: int, x1: Union[float, int],
                         y1: Union[float, int], x2: Union[float, int], y2: Union[float, int],
                         max_length: Union[float, int], can_collide: Union[bool, int]) -> None:
    """
    Creates a rope joint between two sprites.

    The rope joint enforces a maximum distance between the sprites without any other restrictions. It does not stop them
    getting closer together. Specify two anchor points in world coordinates with the maximum length you want to allow,
    the current position of the sprites does not affect the initialisation of the joint. The anchor points can be offset
    from the sprite positions. A joint may be deleted by the system if any of the sprites it connects are deleted.

    :param int joint_id: The ID to use for this joint.
    :param int sprite_id1: The ID of the first sprite to join.
    :param int sprite_id2: The ID of the second sprite to join.
    :param Union[float, int] x1: The x coordinate of the sprite 1 anchor point.
    :param Union[float, int] y1: The y coordinate of the sprite 1 anchor point.
    :param Union[float, int] x2: The x coordinate of the sprite 2 anchor point.
    :param Union[float, int] y2: The y coordinate of the sprite 2 anchor point.
    :param Union[float, int] max_length: The maximum length allowed between the sprite anchor points.
    :param Union[bool, int] can_collide: Set whether the two sprites connected by the joint can collide with one
        another.
    :rtype: None
    """
    pass    


def create_weld_joint(sprite_id1: int, sprite_id2: int, x: Union[float, int], y: Union[float, int],
                      can_collide: Union[bool, int]) -> int:
    """
    Creates a weld joint between two sprites.

    The weld joint attempts to limit all relative movement and rotation between the two sprites. Specify a single anchor
    point in world coordinates with the sprites already in the desired positions. The joint is not a perfect fixture and
    given a large enough force the sprites may shift out of position. The anchor point can be offset from the sprite
    center positions.

    A joint may be deleted by the system if any of the sprites it connects are deleted.

    :param int sprite_id1: The ID of the first sprite to join.
    :param int sprite_id2: The ID of the second sprite to join.
    :param Union[float, int] x: The x coordinate of the anchor point.
    :param Union[float, int] y: The y coordinate of the anchor point.
    :param Union[bool, int] can_collide: Set whether the two sprites connected by the joint can collide with one
        another.
    :rtype: int
    """
    pass    


def create_weld_joint_id(joint_id: int, sprite_id1: int, sprite_id2: int, x: Union[float, int],
                         y: Union[float, int], can_collide: Union[bool, int]) -> None:
    """
    Creates a weld joint between two sprites.

    The weld joint attempts to limit all relative movement and rotation between the two sprites. Specify a single anchor
    point in world coordinates with the sprites already in the desired positions. The joint is not a perfect fixture and
    given a large enough force the sprites may shift out of position. The anchor point can be offset from the sprite
    center positions.

    A joint may be deleted by the system if any of the sprites it connects are deleted.

    :param int joint_id: The ID to use for this joint.
    :param int sprite_id1: The ID of the first sprite to join.
    :param int sprite_id2: The ID of the second sprite to join.
    :param Union[float, int] x: The x coordinate of the anchor point.
    :param Union[float, int] y: The y coordinate of the anchor point.
    :param Union[bool, int] can_collide: Set whether the two sprites connected by the joint can collide with one
        another.
    :rtype: None
    """
    pass    


def delete_joint(joint_id: int) -> None:
    """
    Deletes a joint and allows the connected sprites to move freely again.

    Joints should be deleted before sprites. Gear joints should be deleted before the joints it depends on. Deleting a
    joint that does not exist will not cause an error.

    :param int joint_id: The ID of the joint to delete.
    :rtype: None
    """
    pass    


def delete_physics_force(force_id: int) -> None:
    """
    Deletes the specified global force.

    :param int force_id: The ID of the force to delete.
    :rtype: None
    """
    pass    


def finish_pulley_joint(ground_x1: Union[float, int], ground_y1: Union[float, int],
                        ground_x2: Union[float, int], ground_y2: Union[float, int],
                        anchor_x1: Union[float, int], anchor_y1: Union[float, int],
                        anchor_x2: Union[float, int], anchor_y2: Union[float, int]) -> int:
    """
    Creates a pulley joint between two sprites.

    This the second half of a two command setup. Due to the number of parameters required you must call
    `create_pulley_joint2()` first with the initial set of parameters to create the joint. This command returns the ID
    of the new joint.

    :param Union[float, int] ground_x1: The x coordinate of the first ground point.
    :param Union[float, int] ground_y1: The y coordinate of the first ground point.
    :param Union[float, int] ground_x2: The x coordinate of the second ground point.
    :param Union[float, int] ground_y2: The y coordinate of the second ground point.
    :param Union[float, int] anchor_x1: The x coordinate of the first anchor point.
    :param Union[float, int] anchor_y1: The y coordinate of the first anchor point.
    :param Union[float, int] anchor_x2: The x coordinate of the second anchor point.
    :param Union[float, int] anchor_y2: The y coordinate of the second anchor point.
    :rtype: int
    """
    pass    


def get_contact_sprite_id1() -> int:
    """
    Returns the ID of the first sprite involved in this contact.

    If this half of the contact is with an item not associated to a sprite this will return 0.

    :rtype: int
    """
    pass    


def get_contact_sprite_id2() -> int:
    """
    Returns the ID of the second sprite involved in this contact.

    If this half of the contact is with an item not associated to a sprite this will return 0.

    :rtype: int
    """
    pass    


def get_contact_world_x() -> float:
    """
    Returns the X position of the contact point in world coordinates.

    :rtype: float
    """
    pass    


def get_contact_world_y() -> float:
    """
    Returns the Y position of the contact point in world coordinates.

    :rtype: float
    """
    pass    


def get_first_contact() -> bool:
    """
    Cycles through the list of all contacts detected in the last physics step.

    Returns True if a contact exists, you can get the sprites involved in this contact using `get_contact_sprite_id1()`
    and `get_contact_sprite_id2()`, you can move on to the next contact with `get_next_contact()`.

    Returns False if there are no contacts.

    :rtype: bool
    """
    pass    


def get_joint_exists(joint_id: int) -> bool:
    """
    Returns True if the specified joint still exists, False otherwise.

    Joints can be deleted by the system.

    :param int joint_id: The ID of the joint to check.
    :rtype: bool
    """
    pass    


def get_joint_reaction_force_x(joint_id: int) -> float:
    """
    Returns the amount of force applied to the joint in the X direction in the last time step.

    You can use this to detect large forces and delete the joint to simulate breaking.

    :param int joint_id: The ID of the joint to check.
    :rtype: float
    """
    pass    


def get_joint_reaction_force_y(joint_id: int) -> float:
    """
    Returns the amount of force applied to the joint in the Y direction in the last time step.

    You can use this to detect large forces and delete the joint to simulate breaking.

    :param int joint_id: The ID of the joint to check.
    :rtype: float
    """
    pass    


def get_joint_reaction_torque(joint_id: int) -> float:
    """
    Returns the amount of torque applied to the joint in the last time step.

    You can use this to detect large forces and delete the joint to simulate breaking. Torque applies to joints that
    rotate such as revolute joints.

    :param int joint_id: The ID of the joint to check.
    :rtype: float
    """
    pass    


def get_next_contact() -> bool:
    """
    Returns True if a contact exists, you can get the sprites involved in this contact using `get_contact_sprite_id1()`
    and `get_contact_sprite_id2()`, you can move on to the next contact by calling this command again, when there are no
    more contacts it will return False.

    :rtype: bool
    """
    pass    


def get_physics_island_count() -> int:
    """
    Returns the number of islands the solver processed last step.

    :rtype: int
    """
    pass    


def get_physics_solve_time() -> float:
    """
    Returns the number of milliseconds spent in the solver.

    :rtype: float
    """
    pass    


def get_ray_cast_fraction() -> float:
    """
    Returns the fraction of the ray travelled before reaching a collision.

    0 represents the start of the ray and 1.0 represents the end of the ray.

    :rtype: float
    """
    pass    


def get_ray_cast_normal_x() -> float:
    """
    Returns the X component of the normal of the most recent ray cast check.

    This will not be a unit vector as it has been converted to world coordinates.

    :rtype: float
    """
    pass    


def get_ray_cast_normal_y() -> float:
    """
    Returns the Y component of the normal of the most recent ray cast check.

    This will not be a unit vector as it has been converted to world coordinates.

    :rtype: float
    """
    pass    


def get_ray_cast_sprite_id() -> int:
    """
    Returns the ID of the sprite hit in the most recent ray cast check.

    If the ray hit a non-sprite shape 0 will be returned.

    :rtype: int
    """
    pass    


def get_ray_cast_x() -> float:
    """
    Returns the X coordinate of the intersection point of the most recent ray cast check.

    The result is in world coordinates.

    :rtype: float
    """
    pass    


def get_ray_cast_y() -> float:
    """
    Returns the Y coordinate of the intersection point of the most recent ray cast check.

    The result is in world coordinates.

    :rtype: float
    """
    pass    


def get_sprite_contact_sprite_id2() -> int:
    """
    Returns the ID of the other sprite involved in this contact.

    :rtype: int
    """
    pass    


def get_sprite_contact_world_x() -> float:
    """
    Returns the X coordinate of the contact point in world coordinates.

    :rtype: float
    """
    pass    


def get_sprite_contact_world_y() -> float:
    """
    Returns the Y coordinate of the contact point in world coordinates.

    :rtype: float
    """
    pass    


def get_sprite_first_contact(sprite1: int) -> bool:
    """
    Cycles through the list of contacts for the given sprite only.

    Returns True if a contact exists, you can get the other sprite involved in this contact using
    `get_sprite_contact_sprite_id2()`, you can move on to the next contact with `get_sprite_next_contact()`. Only works
    on sprites setup for physics.

    Returns False if there are no contacts.

    :param int sprite1: The sprite to check for physics contacts.
    :rtype: bool
    """
    pass    


def get_sprite_next_contact() -> bool:
    """
    Cycles through the list of contacts for the given sprite only.

    Returns True if a contact exists, you can get the other sprite involved in this contact using
    `get_sprite_contact_sprite_id2()`, you can move on to the next contact by calling this command again, it will return
    False when no more contacts exist. Only works on sprites setup for physics.

    :rtype: bool
    """
    pass    


def physics_ray_cast(x1: Union[float, int], y1: Union[float, int], x2: Union[float, int],
                     y2: Union[float, int]) -> bool:
    """
    Casts a ray through all physics objects including sprites that have physics turned on and stores the closest item
    hit.

    Results of a ray cast can be retrieved using the other ray cast functions such as `get_ray_cast_normal_x()`.

    If the ray starts inside a shape that shape will not be counted in the results.

    Returns True if there was a collision, False if not.

    :param Union[float, int] x1: The X coordinate of the start point in world coordinates.
    :param Union[float, int] y1: The Y coordinate of the start point in world coordinates.
    :param Union[float, int] x2: The X coordinate of the end point in world coordinates.
    :param Union[float, int] y2: The Y coordinate of the end point in world coordinates.
    :rtype: bool
    """
    pass    


def physics_ray_cast_category(category: int, x1: Union[float, int], y1: Union[float, int],
                              x2: Union[float, int], y2: Union[float, int]) -> bool:
    """
    Casts a ray through all physics objects including sprites that have physics turned on and stores the closest item
    hit.

    Results of a ray cast can be retrieved using the other ray cast functions such as `get_ray_cast_normal_x()`.

    If the ray starts inside a shape that shape will not be counted in the results.

    This function filters the sprites that are checked so only sprites of certain categories are checked. The category
    parameter is a bitwise field that uses the lower 16 bits to represent each of the possible 16 categories used when
    setting up a sprite. The default value of all 1s means all categories will be included, whereas a value of all 0s
    means no categories will be included. You can set individual bits to set which ones should be checked.

    Returns True if there was a collision, False if not.

    :param int category: The categories to check for intersection with the ray, bitwise field using the lower most 16
        bits.
    :param Union[float, int] x1: The X coordinate of the start point in world coordinates.
    :param Union[float, int] y1: The Y coordinate of the start point in world coordinates.
    :param Union[float, int] x2: The X coordinate of the end point in world coordinates.
    :param Union[float, int] y2: The Y coordinate of the end point in world coordinates.
    :rtype: bool
    """
    pass    


def physics_ray_cast_group(group: int, x1: Union[float, int], y1: Union[float, int],
                           x2: Union[float, int], y2: Union[float, int]) -> bool:
    """
    Casts a ray through all physics objects including sprites that have physics turned on and stores the closest item
    hit.

    Results of a ray cast can be retrieved using the other ray cast functions such as `get_ray_cast_normal_x()`.

    If the ray starts inside a shape that shape will not be counted in the results.

    This function filters the sprites that are checked so only sprites of a certain group are checked, a group value of
    0 means all groups will be checked.

    Returns True if there was a collision, False if not.

    :param int group: The group ID to check for intersection with the ray, can be negative.
    :param Union[float, int] x1: The X coordinate of the start point in world coordinates.
    :param Union[float, int] y1: The Y coordinate of the start point in world coordinates.
    :param Union[float, int] x2: The X coordinate of the end point in world coordinates.
    :param Union[float, int] y2: The Y coordinate of the end point in world coordinates.
    :rtype: bool
    """
    pass    


def set_joint_damping(joint_id: int, damping: Union[float, int], frequency: Union[float,
                      int]) -> None:
    """
    Damping can be used to make the joint soft, like a spring.

    The frequency is specified in hertz and should typically be less than half of the physics step rate. For example if
    the fps is 60 then the frequency should be less than 30. The damping ratio should be between 0 and 1, but can be
    larger.

    This can only be used on distance joints, weld joints, line/wheel joints, and mouse joints. By default distance and
    weld joints have a damping ratio and frequency of 0 making the joint rigid. By default mouse joints have a frequency
    of 5 and a damping ratio of 0.7. By default line/wheel joints have a frequency of 2 and a damping ratio of 0.7.

    :param int joint_id: The ID of the joint to modify.
    :param Union[float, int] damping: The damping ratio to use, typically between 0 and 1.
    :param Union[float, int] frequency: The frequency of the oscillations, should be less than half the frame rate.
    :rtype: None
    """
    pass    


def set_joint_limit_off(joint_id: int) -> None:
    """
    Turns off limits for joints that support them.

    Works on Prismatic joints and Revolute joints.

    :param int joint_id: The ID of the joint to modify.
    :rtype: None
    """
    pass    


def set_joint_limit_on(joint_id: int, minimum: Union[float, int], maximum: Union[float,
                       int]) -> None:
    """
    Works on Prismatic joints and Revolute joints.

    Sets the limit that this joint can reach before stopping, for revolute joints this is based on angles, for the
    others it is on length.

    By default a joint does not have limits.

    :param int joint_id: The ID of the joint to modify.
    :param Union[float, int] minimum: The smallest extent that the joint can reach.
    :param Union[float, int] maximum: The greatest extent that the joint can reach.
    :rtype: None
    """
    pass    


def set_joint_motor_off(joint_id: int) -> None:
    """
    Turns off a motor previously applied to a joint that supports it.

    Works on Line joints, Prismatic joints, and Revolute joints.

    :param int joint_id: The ID of the joint to modify.
    :rtype: None
    """
    pass    


def set_joint_motor_on(joint_id: int, speed: Union[float, int], max_force: Union[float,
                       int]) -> None:
    """
    Turns on a motor for the joint so that it moves continuously until prevented by a collision.

    Works on Line/Wheel joints, Prismatic joints, and Revolute joints. Motors work by applying a force to achieve a set
    speed, if they meet resistance they increase the force until either the motor is moving at the desired speed or the
    maximum force specified is reached, at which point the motor will stop, continuing to apply the maximum force. In
    the case of linear joints the motor applies in one direction and either pushes the attached sprites together or
    apart.

    :param int joint_id: The ID of the joint to modify.
    :param Union[float, int] speed: The desired speed of the motor.
    :param Union[float, int] max_force: The max force it can use to achieve the speed.
    :rtype: None
    """
    pass    


def set_joint_mouse_max_force(joint_id: int, max_force: Union[float, int]) -> None:
    """
    Sets the maximum force that can be used by the mouse joint to move an object.

    By default this is set to 0.

    :param int joint_id: The ID of the joint to modify.
    :param Union[float, int] max_force: The maximum force to allow.
    :rtype: None
    """
    pass    


def set_joint_mouse_target(joint_id: int, x: Union[float, int], y: Union[float, int]) -> None:
    """
    Sets the target point in world coordinates that the mouse joint will attempt to move the attached body towards.

    Only works on Mouse joints.

    :param int joint_id: The ID of the joint to modify.
    :param Union[float, int] x: The x coordinate of the new target.
    :param Union[float, int] y: The y coordinate of the new target.
    :rtype: None
    """
    pass    


def set_physics_ccd(enabled: Union[bool, int]) -> None:
    """
    Turns Continuous Collision Detection on and off.

    This prevents fast moving objects from tunnelling through static bodies. To prevent fast moving objects passing
    through each other use `set_sprite_physics_is_bullet()` When you have a large number of dynamic bodies CCD can be
    the bottleneck in the physics engine, especially when threading is turned on as this part is not currently threaded.
    Default is off.

    :param Union[bool, int] enabled: False to disable CCD, True to turn it on.
    :rtype: None
    """
    pass    


def set_physics_debug_off() -> None:
    """
    Disables the drawing of internal physics shapes on screen.

    :rtype: None
    """
    pass    


def set_physics_debug_on() -> None:
    """
    Enables the drawing of internal physics shapes on screen.

    If you `set_view_offset()` to something other than 0,0 make sure none of your physics sprites are fixed to the
    screen using `fix_sprite_to_screen()` otherwise the debug shapes will not line up. Debug outlines are drawn as world
    sprites.

    The debug output will draw the shape of every physics sprite set using `set_sprite_physics_on()` and all non physics
    sprites that have a shape assigned for non-physics collision commands. The shapes will be drawn in the following
    colors: Cream=Dynamic physics object, Green=Static physics object, Dark Blue=Kinematic physics object, Light
    Blue=Non-physics object. Grey=Sleeping dynamic physics object. Additionally physics objects will be drawn as shaded
    with an outline, non-physics objects will be an outline only.

    :rtype: None
    """
    pass    


def set_physics_force_position(force_id: int, x: Union[float, int], y: Union[float, int]) -> None:
    """
    Changes the position of the global force in world coordinates.

    :param int force_id: The ID of the force to modify.
    :param Union[float, int] x: The x component of the new position.
    :param Union[float, int] y: The y component of the new position.
    :rtype: None
    """
    pass    


def set_physics_force_power(force_id: int, power: Union[float, int]) -> None:
    """
    Changes the strength of the global force.

    For forces that fade this will be the strength at 1 unit from the force position.

    The force is in Newtons, and is similar in size to gravity except that it is affected by the mass of the object. For
    example, for an object of mass of 1 kg and a force of 10 newtons will affect the object in the same way as gravity
    set at 10 m/s^2. For a mass of 2 kg it is harder to move, so a force of 10 Newtons would be half as effective at
    moving the object as gravity at 10m/s^2.

    :param int force_id: The ID of the force to modify.
    :param Union[float, int] power: The new strength of the force.
    :rtype: None
    """
    pass    


def set_physics_force_range(force_id: int, range: Union[float, int]) -> None:
    """
    Changes the range of the global force.

    Sprites greater than this distance from the force position will not feel its effects. A range less than zero equals
    an infinite range.

    :param int force_id: The ID of the force to modify.
    :param Union[float, int] range: The new range of the force.
    :rtype: None
    """
    pass    


def set_physics_gravity(x: Union[float, int], y: Union[float, int]) -> None:
    """
    Sets the gravity vector for all sprites using physics.

    The x and y values will be scaled into physics space so will only represent meters per second squared when scale =
    1.0, in world space the values represent pixels per second squared. For example in the default scale of 0.2, a
    `set_physics_gravity()` value of 0,50 would represent 10 meters per second squared. Gravity is a constant
    acceleration applied to all physics objects equally, regardless of mass. Whereas a force applies an acceleration
    proportional to the objects mass. To counteract gravity with a force will require accounting for mass.

    :param Union[float, int] x: The X component of the gravity vector.
    :param Union[float, int] y: The Y component of the gravity vector.
    :rtype: None
    """
    pass    


def set_physics_max_polygon_points(points: int) -> None:
    """
    Sets the maximum number of points that will be generated in future polygon physics shapes, does not affect already
    generated shapes, may be called multiple times.

    Only affects shapes generated by the AGK through `set_sprite_shape()`. Must be between 2 and 12. The default setting
    is 8.

    :param int points: The maximum number of points allowed in new polygon shapes.
    :rtype: None
    """
    pass    


def set_physics_scale(scale: Union[float, int]) -> None:
    """
    Sets the scale used by the physics system compared with world coordinates.

    By design the physics system is set to use 1 unit as equalling 1 meter, which in the case of default world
    coordinates (100,100) would mean that the screen is 100 meters by 100 meters in the physics simulation.

    However by design the physics system is designed to work best with dynamic objects ranging from 0.1 meters to 10
    meters in size, and with static objects up to 50 meters, so the screen is scaled down when sent to the physics
    system, by default the scale is 0.2, so in the physics world the screen is 20 meters by 20 meters. This is purely to
    allow the physics system to work at its designed scale whilst allowing world coordinates to be used as parameters
    with the AGK doing all the necessary scaling behind the scenes. This function allows you to change the scale factor
    if your virtual resolution is going to be different from 100,100.

    This function must be called before any other physics functions, and must not be called once the physics system is
    running.

    :param Union[float, int] scale: The new scale value to use for all screen to physics values and vice versa.
    :rtype: None
    """
    pass    


def set_physics_sleeping(enabled: Union[bool, int]) -> None:
    """
    Sets the ability of dynamic bodies to sleep when they are not moving, this dramatically improves performance when
    dynamic bodies have settled into their final positions.

    Turning it off is only useful for benchmarking when you want to keep the CPU active processing all bodies all the
    time. Default is on.

    :param Union[bool, int] enabled: False to disable sleeping, True to turn it on.
    :rtype: None
    """
    pass    


def set_physics_threading(threads: int) -> None:
    """
    Sets the number of threads to use during physics.

    A value of 0 or 1 turns off multi-threading, a value of -1 chooses a value matching the number of processors in the
    device for best performance. Using a value higher than the number of processors in the device is likely to hurt
    performance. Default is -1.

    :param int threads: The number of threads to use, -1 to automatically choose a number appropriate for the device.
    :rtype: None
    """
    pass    


def set_physics_wall_bottom(enabled: Union[bool, int]) -> None:
    """
    Toggles the existence of a physics wall at the bottom of the screen to prevent physics objects leaving the screen in
    that direction.

    If you have physics objects beyond the edge of the screen, e.g. in a platform game, you should turn this off.

    If you change the view offset using `set_view_offset()` the walls will not move with it, they are fixed to the
    world, so they will be disabled automatically.

    :param Union[bool, int] enabled: True to enable.
    :rtype: None
    """
    pass    


def set_physics_wall_left(enabled: Union[bool, int]) -> None:
    """
    Toggles the existence of a physics wall on the left of the screen to prevent physics objects leaving the screen in
    that direction.

    If you have physics objects beyond the edge of the screen, e.g. in a platform game, you should turn this off.

    If you change the view offset using `set_view_offset()` the walls will not move with it, they are fixed to the
    world, so they will be disabled automatically.

    :param Union[bool, int] enabled: True to enable.
    :rtype: None
    """
    pass    


def set_physics_wall_right(enabled: Union[bool, int]) -> None:
    """
    Toggles the existence of a physics wall on the right of the screen to prevent physics objects leaving the screen in
    that direction.

    If you have physics objects beyond the edge of the screen, e.g. in a platform game, you should turn this off.

    If you change the view offset using `set_view_offset()` the walls will not move with it, they are fixed to the
    world, so they will be disabled automatically.

    :param Union[bool, int] enabled: True to enable.
    :rtype: None
    """
    pass    


def set_physics_wall_top(enabled: Union[bool, int]) -> None:
    """
    Toggles the existence of a physics wall at the top of the screen to prevent physics objects leaving the screen in
    that direction.

    If you have physics objects beyond the edge of the screen, e.g. in a platform game, you should turn this off.

    If you change the view offset using `set_view_offset()` the walls will not move with it, they are fixed to the
    world, so they will be disabled automatically.

    :param Union[bool, int] enabled: True to enable.
    :rtype: None
    """
    pass    


def sprite_ray_cast(x1: Union[float, int], y1: Union[float, int], x2: Union[float, int],
                    y2: Union[float, int]) -> bool:
    """
    Casts a ray through all sprites that have a shape (including physics sprites) and stores the result of any
    intersection.

    Results of a ray cast can be retrieved using the other ray cast functions such as `get_ray_cast_normal_x()`. Physics
    sprites will only use the main shape assigned to the sprite using `set_sprite_shape()`, to check compound shapes use
    `physics_ray_cast()`.

    If the ray starts inside a shape that shape will not be counted in the results.

    Sprites must be assigned a shape using one of the sprite shape commands or it will not be included in the collision
    results. This function is slower than the physics only ray casts as it cannot make use of optimized structures that
    represent where the sprites are in the world relative to the ray.

    This function can only keep track of sprites created using `create_sprite()`, if you have manually allocated memory
    for sprites you will need to cycle through your list of sprites with `sprite_ray_cast_single()` or use the physics
    version.

    Returns True if there was a collision, False if not.

    :param Union[float, int] x1: The X coordinate of the start point in world coordinates.
    :param Union[float, int] y1: The Y coordinate of the start point in world coordinates.
    :param Union[float, int] x2: The X coordinate of the end point in world coordinates.
    :param Union[float, int] y2: The Y coordinate of the end point in world coordinates.
    :rtype: bool
    """
    pass    


def sprite_ray_cast_category(category: int, x1: Union[float, int], y1: Union[float, int],
                             x2: Union[float, int], y2: Union[float, int]) -> bool:
    """
    Casts a ray through all sprites that have a shape (including physics sprites) and stores the result of any
    intersection.

    Results of a ray cast can be retrieved using the other ray cast functions such as `get_ray_cast_normal_x()`. Physics
    sprites will only use the main shape assigned to the sprite using `set_sprite_shape()`, to check compound shapes use
    `physics_ray_cast()`.

    If the ray starts inside a shape that shape will not be counted in the results.

    Sprites must be assigned a shape using one of the sprite shape commands or it will not be included in the collision
    results. This function is slower than the physics ray casts as it cannot make use of optimized structures that
    represent where the sprites are in the world relative to the ray.

    This function filters the sprites that are checked so only sprites of certain categories are checked. The category
    parameter is a bitwise field that uses the lower 16 bits to represent each of the possible 16 categories used when
    setting up a sprite. The default value of all 1s means all categories will be included, whereas a value of all 0s
    means no categories will be included. You can set individual bits to set which ones should be checked.

    This function can only keep track of sprites created using `create_sprite()`, if you have manually allocated memory
    for sprites you will need to cycle through your list of sprites with `sprite_ray_cast_single()` or use the physics
    version.

    Returns True if there was a collision, False if not.

    :param int category: The categories to check for intersection with the ray, bitwise field using the lower most 16
        bits.
    :param Union[float, int] x1: The X coordinate of the start point in world coordinates.
    :param Union[float, int] y1: The Y coordinate of the start point in world coordinates.
    :param Union[float, int] x2: The X coordinate of the end point in world coordinates.
    :param Union[float, int] y2: The Y coordinate of the end point in world coordinates.
    :rtype: bool
    """
    pass    


def sprite_ray_cast_group(group: int, x1: Union[float, int], y1: Union[float, int], x2: Union[float,
                          int], y2: Union[float, int]) -> bool:
    """
    Casts a ray through all sprites that have a shape (including physics sprites) and stores the result of any
    intersection.

    Results of a ray cast can be retrieved using the other ray cast functions such as `get_ray_cast_normal_x()`. Physics
    sprites will only use the main shape assigned to the sprite using `set_sprite_shape()`, to check compound shapes use
    `physics_ray_cast()`.

    If the ray starts inside a shape that shape will not be counted in the results. Sprites must be assigned a shape
    using one of the sprite shape commands or it will not be included in the collision results. This function is slower
    than the physics ray casts as it cannot make use of optimized structures that represent where the sprites are in the
    world relative to the ray.

    This function filters the sprites that are checked so only sprites of a certain group are checked. By default
    sprites are created in group 0.

    This function can only keep track of sprites created using `create_sprite()`, if you have manually allocated memory
    for sprites you will need to cycle through your list of sprites with `sprite_ray_cast_single()` or use the physics
    version.

    Returns True if there was a collision, False if not.

    :param int group: The group ID to check for intersection with the ray, can be negative.
    :param Union[float, int] x1: The X coordinate of the start point in world coordinates.
    :param Union[float, int] y1: The Y coordinate of the start point in world coordinates.
    :param Union[float, int] x2: The X coordinate of the end point in world coordinates.
    :param Union[float, int] y2: The Y coordinate of the end point in world coordinates.
    :rtype: bool
    """
    pass    


def sprite_ray_cast_single(sprite: int, x1: Union[float, int], y1: Union[float, int],
                           x2: Union[float, int], y2: Union[float, int]) -> bool:
    """
    Casts a ray through a particular sprite (can be physics or non physics) and stores the result of any intersection.

    Results of a ray cast can be retrieved using the other ray cast functions such as `get_ray_cast_normal_x()`. If the
    ray starts inside a shape that shape will not be counted in the results. This function is special in that it also
    works on all sprites even those that do not have physics turned on, but the sprite must have been assigned a shape
    using one of the sprite shape commands.

    Returns True if there was a collision, False if not.

    :param int sprite: The sprite ID to check for intersection with the ray.
    :param Union[float, int] x1: The X coordinate of the start point in world coordinates.
    :param Union[float, int] y1: The Y coordinate of the start point in world coordinates.
    :param Union[float, int] x2: The X coordinate of the end point in world coordinates.
    :param Union[float, int] y2: The Y coordinate of the end point in world coordinates.
    :rtype: bool
    """
    pass    


def clear_point_lights() -> None:
    """
    Deletes all point lights.

    :rtype: None
    """
    pass    


def clone_object(copy_object_id: int) -> int:
    """
    Copies an object into a new ID, the new object is completely separate from the original object.

    Cloning an instanced object will produce another instance that shares vertex data with the original object.

    Returns an ID you can use to reference this object in other commands.

    :param int copy_object_id: The ID of the object to copy.
    :rtype: int
    """
    pass    


def clone_object_to(new_object_id: int, copy_object_id: int) -> None:
    """
    Copies an object into a new ID, the new object is completely separate from the original object.

    Cloning an instanced object will produce another instance that shares vertex data with the original object.

    Returns an ID you can use to reference this object in other commands.

    :param int new_object_id: The ID of the new object.
    :param int copy_object_id: The ID of the object to copy.
    :rtype: None
    """
    pass    


def create_object_box(width: Union[float, int], height: Union[float, int], length: Union[float,
                      int]) -> int:
    """
    Creates a 3D box with the given width (X), height (Y), and length (Z).

    Returns an ID you can use to reference this object in other commands.

    :param Union[float, int] width: The size of the object in the X direction.
    :param Union[float, int] height: The size of the object in the Y direction.
    :param Union[float, int] length: The size of the object in the Z direction.
    :rtype: int
    """
    pass    


def create_object_id_box(object_id: int, width: Union[float, int], height: Union[float, int],
                         length: Union[float, int]) -> None:
    """
    Creates a 3D box with the given width (X), height (Y), and length (Z).

    Returns an ID you can use to reference this object in other commands.

    :param int object_id: The ID to use for the new object.
    :param Union[float, int] width: The size of the object in the X direction.
    :param Union[float, int] height: The size of the object in the Y direction.
    :param Union[float, int] length: The size of the object in the Z direction.
    :rtype: None
    """
    pass    


def create_object_capsule(diameter: Union[float, int], height: Union[float, int], axis: int) -> int:
    """
    Creates a Capsule primitive.

    :param Union[float, int] diameter: The diameter of the capsule.
    :param Union[float, int] height: The height of the capsule.
    :param int axis: 0 (AXIS_X)= X, 1 (AXIS_Y)= Y, 2 (AXIS_Z)= Z.
    :rtype: int
    """
    pass    


def create_object_id_capsule(object_id: int, diameter: Union[float, int], height: Union[float, int],
                             axis: int) -> None:
    """
    Creates a Capsule primitive.

    :param int object_id: The ID to use for the new object.
    :param Union[float, int] diameter: The diameter of the capsule.
    :param Union[float, int] height: The height of the capsule.
    :param int axis: 0 (AXIS_X)= X, 1 (AXIS_Y)= Y, 2 (AXIS_Z)= Z.
    :rtype: None
    """
    pass    


def create_object_cone(height: Union[float, int], diameter: Union[float, int],
                       segments: int) -> int:
    """
    Creates a 3D cone with the given diameter and height, and an optional number of polygons.

    The segments parameter determines how many columns of polygons make up the cone and must be at least 3. The formula
    for calculating the total number of polygons used in the cone is 2*segments. Returns an ID you can use to reference
    this object in other commands.

    :param Union[float, int] height: The height of the cone.
    :param Union[float, int] diameter: The diameter of the base of the cone.
    :param int segments: The number of columns of polygons that make up the cone.
    :rtype: int
    """
    pass    


def create_object_id_cone(object_id: int, height: Union[float, int], diameter: Union[float, int],
                          segments: int) -> None:
    """
    Creates a 3D cone with the given diameter and height, and an optional number of polygons.

    The segments parameter determines how many columns of polygons make up the cone and must be at least 3. The formula
    for calculating the total number of polygons used in the cone is 2*segments. Returns an ID you can use to reference
    this object in other commands.

    :param int object_id: The ID to use for the new object.
    :param Union[float, int] height: The height of the cone.
    :param Union[float, int] diameter: The diameter of the base of the cone.
    :param int segments: The number of columns of polygons that make up the cone.
    :rtype: None
    """
    pass    


def create_object_cylinder(height: Union[float, int], diameter: Union[float, int],
                           segments: int) -> int:
    """
    Creates a 3D cylinder with the given diameter and height, and an optional number of polygons.

    The segments parameter determines how many columns of polygons make up the cylinder and must be at least 3. The
    formula for calculating the total number of polygons used in the cylinder is 3*segments.

    :param Union[float, int] height: The height of the cylinder.
    :param Union[float, int] diameter: The diameter of the base of the cylinder.
    :param int segments: The number of columns of polygons that make up the cylinder.
    :rtype: int
    """
    pass    


def create_object_id_cylinder(object_id: int, height: Union[float, int], diameter: Union[float,
                              int], segments: int) -> None:
    """
    Creates a 3D cylinder with the given diameter and height, and an optional number of polygons.

    The segments parameter determines how many columns of polygons make up the cylinder and must be at least 3. The
    formula for calculating the total number of polygons used in the cylinder is 3*segments.

    :param int object_id: The ID to use for the new object.
    :param Union[float, int] height: The height of the cylinder.
    :param Union[float, int] diameter: The diameter of the base of the cylinder.
    :param int segments: The number of columns of polygons that make up the cylinder.
    :rtype: None
    """
    pass    


def create_object_from_height_map(image_filename: str, width: Union[float, int],
                                  height: Union[float, int], length: Union[float, int],
                                  smoothing: int, split: int) -> int:
    """
    Creates an object from a specified height map, useful for making terrain.

    The image should be PNG 8-bit greyscale or RGB, if it is RGB then only the red channel is read. 16-bit greyscale
    support may be added in future. The object will have a single UV channel with the range 0 to 1 mapped to the entire
    terrain. If you wish to modify this then you can use `set_object_uv_offset()` and `set_object_uv_scale()`, or use a
    shader that multiplies the UV coordinates by a specified amount. A shader can also be used to create multiple UV
    channels from this single channel by applying different scale factors to each. A smoothing value of 1 is recommended
    to remove stepping artifacts, adjust as necessary. The split value lets you create multiple meshes which can improve
    performance, as unseen meshes will not be drawn. The split value specifies how many meshes to create along each
    edge, for example a split value of 5 will create 5x5 = 25 meshes in total. Unlike other objects collision data is
    not generated by default on this object as it can consume a lot of memory, use `set_object_collision_mode()` if you
    want to turn it on. For terrains greater than 1024x1024 this is not recommended on mobile devices, and you should
    use `get_object_height_map_height()` instead if possible. Turning on physics for this object will use even more
    memory and is not recommended on terrains greater than 1024x1024 on any platform.

    :param str image_filename: The filename of the image to use as a height map, PNG preferred, also supports JPEG.
    :param Union[float, int] width: The desired width of the new object in the X direction.
    :param Union[float, int] height: The desired height of the new object in the Y direction.
    :param Union[float, int] length: The desired length of the new object in the Z direction.
    :param int smoothing: The amount of smoothing to apply to the height values, 0=none, 1=one pass, 2=two passes, etc.
    :param int split: 1=single mesh, 2=four meshes, 3=nine meshes, 4=sixteen meshes, etc.
    :rtype: int
    """
    pass    


def create_object_id_from_height_map(object_id: int, image_filename: str, width: Union[float, int],
                                     height: Union[float, int], length: Union[float, int],
                                     smoothing: int, split: int) -> None:
    """
    Creates an object from a specified height map, useful for making terrain.

    The image should be PNG 8-bit greyscale or RGB, if it is RGB then only the red channel is read. 16-bit greyscale
    support may be added in future. The object will have a single UV channel with the range 0 to 1 mapped to the entire
    terrain. If you wish to modify this then you can use `set_object_uv_offset()` and `set_object_uv_scale()`, or use a
    shader that multiplies the UV coordinates by a specified amount. A shader can also be used to create multiple UV
    channels from this single channel by applying different scale factors to each. A smoothing value of 1 is recommended
    to remove stepping artifacts, adjust as necessary. The split value lets you create multiple meshes which can improve
    performance, as unseen meshes will not be drawn. The split value specifies how many meshes to create along each
    edge, for example a split value of 5 will create 5x5 = 25 meshes in total. Unlike other objects collision data is
    not generated by default on this object as it can consume a lot of memory, use `set_object_collision_mode()` if you
    want to turn it on. For terrains greater than 1024x1024 this is not recommended on mobile devices, and you should
    use `get_object_height_map_height()` instead if possible. Turning on physics for this object will use even more
    memory and is not recommended on terrains greater than 1024x1024 on any platform.

    :param int object_id: The ID of the object to create.
    :param str image_filename: The filename of the image to use as a height map, PNG preferred, also supports JPEG.
    :param Union[float, int] width: The desired width of the new object in the X direction.
    :param Union[float, int] height: The desired height of the new object in the Y direction.
    :param Union[float, int] length: The desired length of the new object in the Z direction.
    :param int smoothing: The amount of smoothing to apply to the height values, 0=none, 1=one pass, 2=two passes, etc.
    :param int split: 1=single mesh, 2=four meshes, 3=nine meshes, 4=sixteen meshes, etc.
    :rtype: None
    """
    pass    


def create_object_from_object_mesh(from_object_id: int, mesh: int) -> int:
    """
    Creates an object by copying a single mesh from another object.

    An object can contain many meshes, and using `clone_object()` would copy them all. Use this command if you only want
    to copy a single mesh. Mesh indices are in the range 1 to `get_object_num_meshes()` inclusive.

    :param int from_object_id: The ID of the object that contains the mesh to copy.
    :param int mesh: The index of the mesh to copy.
    :rtype: int
    """
    pass    


def create_object_id_from_object_mesh(new_object_id: int, from_object_id: int, mesh: int) -> None:
    """
    Creates an object by copying a single mesh from another object.

    An object can contain many meshes, and using `clone_object()` would copy them all. Use this command if you only want
    to copy a single mesh. Mesh indices are in the range 1 to `get_object_num_meshes()` inclusive.

    :param int new_object_id: The ID of the new object.
    :param int from_object_id: The ID of the object that contains the mesh to copy.
    :param int mesh: The index of the mesh to copy.
    :rtype: None
    """
    pass    


def create_object_from_raw_height_map(filename: str, width: Union[float, int], height: Union[float,
                                      int], length: Union[float, int], smoothing: int, split: int,
                                      raw_width: int, raw_height: int) -> int:
    """
    Creates an object from a specified .raw or .dat height map, useful for making terrain.

    The file should be in raw 16-bit data. If you use extension ".dat" in `filename` it will expect that this is a
    GameGuru 32-bit raw height map and convert that to 16-bit. If the file is not a GameGuru height map then you must
    change the extension to ".raw". If you convert a GameGuru height map (.dat) file, `raw_width` and `raw_height`
    should always be set to 1024. The object will have a single UV channel with the range 0 to 1 mapped to the entire
    terrain.

    If you wish to modify this then you can use `set_object_uv_offset()` and `set_object_uv_scale()`, or use a shader
    that multiplies the UV coordinates by a specified amount. A shader can also be used to create multiple UV channels
    from this single channel by applying different scale factors to each. Normally when using 16-bit data you don't need
    to set a smoothing value, but if its not already been smoothed adjust as necessary.

    The `split` value lets you create multiple meshes which can improve performance, as unseen meshes will not be drawn.
    The `split` value specifies how many meshes to create along each edge, for example a `split` value of 5 will create
    5x5 = 25 meshes in total. Unlike other objects collision data is not generated by default on this object as it can
    consume a lot of memory, use `set_object_collision_mode()` if you want to turn it on. For terrains greater than
    1024x1024 this is not recommended on mobile devices, and you should use `get_object_height_map_height()` instead if
    possible. Turning on physics for this object will use even more memory and is not recommended on terrains greater
    than 1024x1024 on any platform.

    :param str filename: The filename of the height map, must end in .raw or .dat
    :param Union[float, int] width: The desired width of the new object in the X direction
    :param Union[float, int] height: The desired height of the new object in the Y direction
    :param Union[float, int] length: The desired length of the new object in the Z direction
    :param int smoothing: The amount of smoothing to apply to the height values, 0=none, 1=one pass, 2=two passes, etc
    :param int split: 1=single mesh, 2=four meshes, 3=nine meshes, 4=sixteen meshes, etc
    :param int raw_width: The width of the height map data
    :param int raw_height: The height of the height map data
    :rtype: int
    """
    pass    


def create_object_id_from_raw_height_map(object_id: int, filename: str, width: Union[float, int],
                                         height: Union[float, int], length: Union[float, int],
                                         smoothing: int, split: int, raw_width: int,
                                         raw_height: int) -> None:
    """
    Creates an object from a specified .raw or .dat height map, useful for making terrain.

    The file should be in raw 16-bit data. If you use extension ".dat" in `filename` it will expect that this is a
    GameGuru 32-bit raw height map and convert that to 16-bit. If the file is not a GameGuru height map then you must
    change the extension to ".raw". If you convert a GameGuru height map (.dat) file, `raw_width` and `raw_height`
    should always be set to 1024. The object will have a single UV channel with the range 0 to 1 mapped to the entire
    terrain.

    If you wish to modify this then you can use `set_object_uv_offset()` and `set_object_uv_scale()`, or use a shader
    that multiplies the UV coordinates by a specified amount. A shader can also be used to create multiple UV channels
    from this single channel by applying different scale factors to each. Normally when using 16-bit data you don't need
    to set a smoothing value, but if its not already been smoothed adjust as necessary.

    The `split` value lets you create multiple meshes which can improve performance, as unseen meshes will not be drawn.
    The `split` value specifies how many meshes to create along each edge, for example a `split` value of 5 will create
    5x5 = 25 meshes in total. Unlike other objects collision data is not generated by default on this object as it can
    consume a lot of memory, use `set_object_collision_mode()` if you want to turn it on. For terrains greater than
    1024x1024 this is not recommended on mobile devices, and you should use `get_object_height_map_height()` instead if
    possible. Turning on physics for this object will use even more memory and is not recommended on terrains greater
    than 1024x1024 on any platform.

    :param int object_id: The ID of the object to create
    :param str filename: The filename of the height map, must end in .raw or .dat
    :param Union[float, int] width: The desired width of the new object in the X direction
    :param Union[float, int] height: The desired height of the new object in the Y direction
    :param Union[float, int] length: The desired length of the new object in the Z direction
    :param int smoothing: The amount of smoothing to apply to the height values, 0=none, 1=one pass, 2=two passes, etc
    :param int split: 1=single mesh, 2=four meshes, 3=nine meshes, 4=sixteen meshes, etc
    :param int raw_width: The width of the height map data
    :param int raw_height: The height of the height map data
    :rtype: None
    """
    pass    


def create_object_id_plane(object_id: int, width: Union[float, int], height: Union[float,
                           int]) -> None:
    """
    Creates a 3D double sided plane with the given width (X) and height (Y).

    The plane is created in the XY plane and has no size in the Z direction. Returns an ID you can use to reference this
    object in other commands.

    :param int object_id: The ID to use for the new object.
    :param Union[float, int] width: The width of the plane.
    :param Union[float, int] height: The height of the plane.
    :rtype: None
    """
    pass    


def create_object_plane(width: Union[float, int], height: Union[float, int]) -> int:
    """
    Creates a 3D double sided plane with the given width (X) and height (Y).

    The plane is created in the XY plane and has no size in the Z direction. Returns an ID you can use to reference this
    object in other commands.

    :param Union[float, int] width: The width of the plane.
    :param Union[float, int] height: The height of the plane.
    :rtype: int
    """
    pass    


def create_object_id_quad(object_id: int) -> None:
    """
    Creates a plane that will fill the entire screen and can be used to render full screen shaders.

    :param int object_id: The ID to use for the new object.
    :rtype: None
    """
    pass    


def create_object_quad() -> int:
    """
    Creates a plane that will fill the entire screen and can be used to render full screen shaders.

    :rtype: int
    """
    pass    


def create_object_id_sphere(object_id: int, diameter: Union[float, int], rows: int,
                            columns: int) -> None:
    """
    Creates a 3D sphere with the given diameter, and an optional number of polygons.

    The rows parameter determines how many rows of polygons make up the sphere and must be at least 2. The columns
    parameter determines how many columns of polygons make up the sphere and must be at least 3. The formula for
    calculating the total number of polygons used in the sphere is 2*columns*(rows-1). Returns an ID you can use to
    reference this object in other commands.

    :param int object_id: The ID to use for the new object.
    :param Union[float, int] diameter: The diameter of the sphere.
    :param int rows: The number of rows of polygons that make up the sphere.
    :param int columns: The number of columns of polygons that make up the sphere.
    :rtype: None
    """
    pass    


def create_object_sphere(diameter: Union[float, int], rows: int, columns: int) -> int:
    """
    Creates a 3D sphere with the given diameter, and an optional number of polygons.

    The rows parameter determines how many rows of polygons make up the sphere and must be at least 2. The columns
    parameter determines how many columns of polygons make up the sphere and must be at least 3. The formula for
    calculating the total number of polygons used in the sphere is 2*columns*(rows-1). Returns an ID you can use to
    reference this object in other commands.

    :param Union[float, int] diameter: The diameter of the sphere.
    :param int rows: The number of rows of polygons that make up the sphere.
    :param int columns: The number of columns of polygons that make up the sphere.
    :rtype: int
    """
    pass    


def create_point_light(light_id: int, x: Union[float, int], y: Union[float, int], z: Union[float,
                       int], radius: Union[float, int], red: int, green: int, blue: int) -> None:
    """
    Creates a point light that shines equally in all directions.

    This affects all objects using the default internal shader with `set_object_light_mode()` set to 1. If you are using
    a custom shader then AGK will add lighting functions to your shader during loading if you reference them, see the
    guide to shaders for more information on this. By default, lights are created in vertex mode, this is faster than
    pixel mode but lower quality. To change this use `set_point_light_mode()`. Color values should be in the range 0-255
    but are not limited to it. Values greater than 255 will over saturate things and values less than 0 will take light
    away.

    :param int light_id: The ID of the light to reference it in other commands.
    :param Union[float, int] x: The X component of the light position.
    :param Union[float, int] y: The Y component of the light position.
    :param Union[float, int] z: The Z component of the light position.
    :param Union[float, int] radius: The range that the light affects.
    :param int red: The red component of the light color.
    :param int green: The green component of the light color.
    :param int blue: The blue component of the light color.
    :rtype: None
    """
    pass    


def delete_all_objects() -> None:
    """
    Deletes all objects created with an ID.

    This also resets the auto object ID to 10000.

    :rtype: None
    """
    pass    


def delete_object(object_id: int) -> None:
    """
    Deletes the object at the given ID, if the object doesn't exist then this command does nothing.

    Note that if the object was loaded with `load_object_with_children()` then any child objects that were created
    during that loading process will not be deleted by this command. You can use `get_object_child_id()` to get and
    delete those objects manually, or use `delete_object_with_children()` to delete everything that was created when
    this object was loaded.

    :param int object_id: The ID of the object to delete.
    :rtype: None
    """
    pass    


def delete_object_tree(object_id: int) -> None:
    """
    Deletes the object at the given ID, if the object doesn't exist then this command does nothing.

    This command also deletes any child objects that were created when this object was loaded, and any objects that are
    currently attached to this object from using `fix_object_to_object()` or `fix_object_to_bone()`.

    :param int object_id: The ID of the object to delete.
    :rtype: None
    """
    pass    


def delete_object_with_children(object_id: int) -> None:
    """
    Deletes the object at the given ID, if the object doesn't exist then this command does nothing.

    This command also deletes any child objects that were created when this object was loaded, if you do not want to
    delete those then use `delete_object()` instead. If you use this command on an object that was loaded with
    `load_object()` then it deletes it as normal.

    :param int object_id: The ID of the object to delete.
    :rtype: None
    """
    pass    


def delete_point_light(light_id: int) -> None:
    """
    Deletes the specified point light.

    If the point light doesn't exist this command does nothing.

    :param int light_id: The ID of the light to delete.
    :rtype: None
    """
    pass    


def delete_shader(shader_id: int) -> None:
    """
    Deletes a shader and frees the ID.

    The shader must not currently be assigned to any object, mesh, quad, or sprite, otherwise it may cause a crash when
    it tries to draw.

    :param int shader_id: The ID of the shader to delete.
    :rtype: None
    """
    pass    


def draw_object(object_id: int) -> None:
    """
    Immediately draws the object to the current render target at its current position, size, and rotation.

    This is useful if you want to draw particular objects like sky boxes before any other objects. In this case be sure
    to make the object invisible for calls to `render()` or `sync()` otherwise the object may appear twice.

    :param int object_id: The ID of the object to draw.
    :rtype: None
    """
    pass    


def fix_camera_to_object(camera_id: int, object_id: int) -> None:
    """
    Fixes a camera to an object so that any movement of the object also affects the camera. The camera uses its current
    position, rotation, and scale as an offset to the object. For example if the object was placed at 10,5,0 and a
    camera was fixed to it with a current position of 0,10,0 then the camera would now inherit the position of the
    object, combine it with its own, and the camera would be placed at 10,15,0. The same applies to rotation and
    scaling, so if the object was rotated around the Y axis then the camera would rotate by the same amount. Note that
    using `get_camera_y()` would only show its local position relative to the parent object (in this case it would
    return 10). To get the final world position of the camera use `get_camera_world_y()`, which in this case would
    return 15. There is no limit to the number of objects or cameras an object can have fixed to it, nor is there a
    limit to objects being fixed to objects which are fixed to other objects, just don't create any loops. To stop a
    camera being fixed to anything set `object_id` to 0 and it will become independent again.

    :param int camera_id: The ID of the camera to fix, must be equal to 1
    :param int object_id: The ID of the object to fix it to.
    :rtype: None
    """
    pass    


def fix_object_pivot(object_id: int) -> None:
    """
    Resets the object's position and rotation to 0 whilst keeping the object's vertices where they are.

    This can be used to change the center of rotation of an object or adjust its default orientation when it's rotation
    is 0. This command modifies the vertices of the object's meshes so is not recommended to call this every frame,
    unless the target platform is quite powerful i.e. Windows, Mac, or Linux.

    :param int object_id: The ID of the object to modify.
    :rtype: None
    """
    pass    


def fix_object_to_bone(object_id: int, to_object_id: int, to_bone: int) -> None:
    """
    Similar to `fix_object_to_object()` except the parent will be a bone in the other object.

    :param int object_id: The ID of the object to fix.
    :param int to_object_id: The ID of the object to fix it to.
    :param int to_bone: The index of the bone to fix it to.
    :rtype: None
    """
    pass    


def fix_object_to_camera(object_id: int, to_camera_id: int) -> None:
    """
    Fixes an object to a camera so that any movement of the parent also affects the child. The object being fixed uses
    its current position, rotation, and scale as an offset to the parent. For example if the camera was placed at 10,5,0
    and an object was fixed to it with the current position 0,10,0 then the object would now inherit the position of the
    camera, combine it with its own, and the object would be placed at 10,15,0. The same applies to rotation and
    scaling, so if the camera was rotated around the Y axis then the object would rotate by the same amount.

    Note that using `get_object_y()` on the child would only show its local position relative to its parent (in this
    case it would return 10). To get the final world position of the child use `get_object_world_y()` on it, which in
    this case would return 15. There is no limit to the number of objects a camera can have fixed to it, nor is there a
    limit to objects being fixed to objects which are fixed to cameras, just don't create any loops.

    An object can only be fixed to one thing at a time, fixing it to something else will remove it from its current
    attachment (if any). To stop an object being fixed to anything set toObjID to 0 and it will become independent
    again.

    :param int object_id: The ID of the object to fix.
    :param int to_camera_id: The ID of the camera to fix it to.
    :rtype: None
    """
    pass    


def fix_object_to_object(object_id: int, to_object_id: int) -> None:
    """
    Fixes an object to another object so that any movement of the parent also affects the child.

    The object being fixed uses its current position, rotation, and scale as an offset to the parent. For example if the
    parent was placed at 10,5,0 and an object was fixed to it with the current position 0,10,0 then the child would now
    inherit the position of the parent, combine it with its own, and the child would be placed at 10,15,0. The same
    applies to rotation and scaling, so if the parent was rotated around the Y axis then the child would rotate by the
    same amount. Note that using `get_object_y()` on the child would only show its local position relative to its parent
    (in this case it would return 10). To get the final world position of the child use `get_object_world_y()` on it,
    which in this case would return 15. There is no limit to the number of objects an object can have fixed to it, nor
    is there a limit to objects being fixed to objects which are fixed to other objects, just don't create any loops. An
    object can only be fixed to one thing at a time, fixing it to something else will remove it from its current
    attachment (if any). To stop an object being fixed to anything set `to_object_id` to 0 and it will become
    independent again.

    :param int object_id: The ID of the object to fix.
    :param int to_object_id: The ID of the object to fix it to.
    :rtype: None
    """
    pass    


def get_3d_vector_x_from_screen(x: Union[float, int], y: Union[float, int]) -> float:
    """
    Converts a 2D point on the screen into a vector pointing into the 3D world.

    The vector is normalised to 1 unit long, to extend it into the world simply multiply it by your desired distance.

    If the camera is using an orthographic projection matrix then this command behaves slightly differently, since all
    points on the screen would produce the same vector pointing away from the camera, but each originating from a
    different point in 3D space. This differs from a perspective projection where all vectors start at the camera
    position and fan out as they move away from the camera. So when using an orthographic projection matrix this command
    will instead return a sideways unnormalised vector from the camera position to the point in 3D space that the vector
    should start. This can then be combined with a vector that points away from the camera to create a ray cast into the
    scene.

    :param Union[float, int] x: The X component of the screen position.
    :param Union[float, int] y: The Y component of the screen position.
    :rtype: float
    """
    pass    


def get_3d_vector_y_from_screen(x: Union[float, int], y: Union[float, int]) -> float:
    """
    Converts a 2D point on the screen into a vector pointing into the 3D world.

    The vector is normalised to 1 unit long, to extend it into the world simply multiply it by your desired distance.

    If the camera is using an orthographic projection matrix then this command behaves slightly differently, since all
    points on the screen would produce the same vector pointing away from the camera, but each originating from a
    different point in 3D space. This differs from a perspective projection where all vectors start at the camera
    position and fan out as they move away from the camera. So when using an orthographic projection matrix this command
    will instead return a sideways unnormalised vector from the camera position to the point in 3D space that the vector
    should start. This can then be combined with a vector that points away from the camera to create a ray cast into the
    scene.

    :param Union[float, int] x: The X component of the screen position.
    :param Union[float, int] y: The Y component of the screen position.
    :rtype: float
    """
    pass    


def get_3d_vector_z_from_screen(x: Union[float, int], y: Union[float, int]) -> float:
    """
    Converts a 2D point on the screen into a vector pointing into the 3D world.

    The vector is normalised to 1 unit long, to extend it into the world simply multiply it by your desired distance.

    If the camera is using an orthographic projection matrix then this command behaves slightly differently, since all
    points on the screen would produce the same vector pointing away from the camera, but each originating from a
    different point in 3D space. This differs from a perspective projection where all vectors start at the camera
    position and fan out as they move away from the camera. So when using an orthographic projection matrix this command
    will instead return a sideways unnormalised vector from the camera position to the point in 3D space that the vector
    should start. This can then be combined with a vector that points away from the camera to create a ray cast into the
    scene.

    :param Union[float, int] x: The X component of the screen position.
    :param Union[float, int] y: The Y component of the screen position.
    :rtype: float
    """
    pass    


def get_camera_angle_x(camera_id: int) -> float:
    """
    Returns the X component of the camera's current rotation converted to Euler angles.

    :param int camera_id: The ID of the camera to check, the main camera is ID 1.
    :rtype: float
    """
    pass    


def get_camera_angle_y(camera_id: int) -> float:
    """
    Returns the Y component of the camera's current rotation converted to Euler angles.

    :param int camera_id: The ID of the camera to check, the main camera is ID 1.
    :rtype: float
    """
    pass    


def get_camera_angle_z(camera_id: int) -> float:
    """
    Returns the Z component of the camera's current rotation converted to Euler angles.

    :param int camera_id: The ID of the camera to check, the main camera is ID 1.
    :rtype: float
    """
    pass    


def get_camera_fov(camera_id: int) -> float:
    """
    Returns the current Field Of View for the specified camera.

    :param int camera_id: The ID of the camera to check, the main camera is ID 1.
    :rtype: float
    """
    pass    


def get_camera_quat_w(camera_id: int) -> float:
    """
    Returns the W component of the camera's current rotation converted to a quaternion.

    :param int camera_id: The ID of the camera to check, the main camera is ID 1.
    :rtype: float
    """
    pass    


def get_camera_quat_x(camera_id: int) -> float:
    """
    Returns the X component of the camera's current rotation converted to a quaternion.

    :param int camera_id: The ID of the camera to check, the main camera is ID 1.
    :rtype: float
    """
    pass    


def get_camera_quat_y(camera_id: int) -> float:
    """
    Returns the Y component of the camera's current rotation converted to a quaternion.

    :param int camera_id: The ID of the camera to check, the main camera is ID 1.
    :rtype: float
    """
    pass    


def get_camera_quat_z(camera_id: int) -> float:
    """
    Returns the Z component of the camera's current rotation converted to a quaternion.

    :param int camera_id: The ID of the camera to check, the main camera is ID 1.
    :rtype: float
    """
    pass    


def get_camera_world_angle_x(camera_id: int) -> float:
    """
    Returns the X component of the camera's current rotation converted to Euler angles after all transformations due to
    `fix_camera_to_object()`.

    :param int camera_id: The ID of the camera to check, the main camera is ID 1.
    :rtype: float
    """
    pass    


def get_camera_world_angle_y(camera_id: int) -> float:
    """
    Returns the Y component of the camera's current rotation converted to Euler angles after all transformations due to
    `fix_camera_to_object()`.

    :param int camera_id: The ID of the camera to check, the main camera is ID 1.
    :rtype: float
    """
    pass    


def get_camera_world_angle_z(camera_id: int) -> float:
    """
    Returns the Z component of the camera's current rotation converted to Euler angles after all transformations due to
    `fix_camera_to_object()`.

    :param int camera_id: The ID of the camera to check, the main camera is ID 1.
    :rtype: float
    """
    pass    


def get_camera_world_quat_w(camera_id: int) -> float:
    """
    Returns the W component of the camera's current rotation converted to a quaternion after all transformations due to
    `fix_camera_to_object()`.

    :param int camera_id: The ID of the camera to check, the main camera is ID 1.
    :rtype: float
    """
    pass    


def get_camera_world_quat_x(camera_id: int) -> float:
    """
    Returns the X component of the camera's current rotation converted to a quaternion after all transformations due to
    `fix_camera_to_object()`.

    :param int camera_id: The ID of the camera to check, the main camera is ID 1.
    :rtype: float
    """
    pass    


def get_camera_world_quat_y(camera_id: int) -> float:
    """
    Returns the Y component of the camera's current rotation converted to a quaternion after all transformations due to
    `fix_camera_to_object()`.

    :param int camera_id: The ID of the camera to check, the main camera is ID 1.
    :rtype: float
    """
    pass    


def get_camera_world_quat_z(camera_id: int) -> float:
    """
    Returns the Z component of the camera's current rotation converted to a quaternion after all transformations due to
    `fix_camera_to_object()`.

    :param int camera_id: The ID of the camera to check, the main camera is ID 1.
    :rtype: float
    """
    pass    


def get_camera_world_x(camera_id: int) -> float:
    """
    Returns the current X position of the camera after all transformations due to `fix_camera_to_object()`.

    :param int camera_id: The ID of the camera to check, the main camera is ID 1.
    :rtype: float
    """
    pass    


def get_camera_world_y(camera_id: int) -> float:
    """
    Returns the current Y position of the camera after all transformations due to `fix_camera_to_object()`.

    :param int camera_id: The ID of the camera to check, the main camera is ID 1.
    :rtype: float
    """
    pass    


def get_camera_world_z(camera_id: int) -> float:
    """
    Returns the current Z position of the camera after all transformations due to `fix_camera_to_object()`.

    :param int camera_id: The ID of the camera to check, the main camera is ID 1.
    :rtype: float
    """
    pass    


def get_camera_x(camera_id: int) -> float:
    """
    Returns the current X position of the camera.

    :param int camera_id: The ID of the camera to check, the main camera is ID 1.
    :rtype: float
    """
    pass    


def get_camera_y(camera_id: int) -> float:
    """
    Returns the current Y position of the camera.

    :param int camera_id: The ID of the camera to check, the main camera is ID 1.
    :rtype: float
    """
    pass    


def get_camera_z(camera_id: int) -> float:
    """
    Returns the current Z position of the camera.

    :param int camera_id: The ID of the camera to check, the main camera is ID 1.
    :rtype: float
    """
    pass    


def get_fog_mode() -> bool:
    """
    Returns True if 3D fog is currently on, otherwise it returns False.

    :rtype: bool
    """
    pass    


def get_object_alpha(object_id: int) -> int:
    """
    Returns the current alpha value of this object's color, as set by `set_object_color()` or `set_object_alpha()`.

    :param int object_id: The ID of the object to check.
    :rtype: int
    """
    pass    


def get_object_angle_x(object_id: int) -> float:
    """
    Returns the X component of the object's current rotation converted to Euler angles.

    :param int object_id: The ID of the object to check.
    :rtype: float
    """
    pass    


def get_object_angle_y(object_id: int) -> float:
    """
    Returns the Y component of the object's current rotation converted to Euler angles.

    :param int object_id: The ID of the object to check.
    :rtype: float
    """
    pass    


def get_object_angle_z(object_id: int) -> float:
    """
    Returns the Z component of the object's current rotation converted to Euler angles.

    :param int object_id: The ID of the object to check.
    :rtype: float
    """
    pass    


def get_object_animation_duration(object_id: int, name: str) -> float:
    """
    Returns the duration of a specified animation in seconds.

    :param int object_id: The ID of the object to check.
    :param str name: The name of the animation to check, defined by the modelling program.
    :rtype: float
    """
    pass    


def get_object_animation_name(object_id: int, index: int) -> str:
    """
    Returns the name of the specified animation for the given object.

    You can find the number of animations for this object with `get_object_num_animations()`. The index should be in the
    range 1 to numAnimations inclusive.

    :param int object_id: The ID of the object to check.
    :param int index: The index of the animation to check, indices start at 1.
    :rtype: str
    """
    pass    


def get_object_animation_time(object_id: int) -> float:
    """
    Returns the current time of a playing animation, or if the animation has stopped then the last time used for
    interpolation is returned.

    :param int object_id: The ID of the object to check.
    :rtype: float
    """
    pass    


def get_object_bone_angle_x(object_id: int, bone: int) -> float:
    """
    Returns the X component of the bone's current rotation converted to Euler angles.

    :param int object_id: The ID of the object that contains the bone to check.
    :param int bone: The index of the bone to check.
    :rtype: float
    """
    pass    


def get_object_bone_angle_y(object_id: int, bone: int) -> float:
    """
    Returns the Y component of the bone's current rotation converted to Euler angles.

    :param int object_id: The ID of the object that contains the bone to check.
    :param int bone: The index of the bone to check.
    :rtype: float
    """
    pass    


def get_object_bone_angle_z(object_id: int, bone: int) -> float:
    """
    Returns the Z component of the bone's current rotation converted to Euler angles.

    :param int object_id: The ID of the object that contains the bone to check.
    :param int bone: The index of the bone to check.
    :rtype: float
    """
    pass    


def get_object_bone_by_name(object_id: int, name: str) -> int:
    """
    Gets the index of a bone by its name.

    Names are loaded from the model file when `load_object_with_children()` is used, otherwise no bones are loaded.
    Indexes will be in the range 1 to num bones, or 0 if not found.

    :param int object_id: The ID of the object to check.
    :param str name: The name of the bone to find.
    :rtype: int
    """
    pass    


def get_object_bone_name(object_id: int, bone: int) -> str:
    """
    Returns the name of the bone.

    :param int object_id: The ID of the object that contains the bone to check.
    :param int bone: The index of the bone to check.
    :rtype: str
    """
    pass    


def get_object_bone_quat_w(object_id: int, bone: int) -> float:
    """
    Returns the W component of the bone's current rotation converted to a quaternion.

    :param int object_id: The ID of the object that contains the bone to check.
    :param int bone: The index of the bone to check.
    :rtype: float
    """
    pass    


def get_object_bone_quat_x(object_id: int, bone: int) -> float:
    """
    Returns the X component of the bone's current rotation converted to a quaternion.

    :param int object_id: The ID of the object that contains the bone to check.
    :param int bone: The index of the bone to check.
    :rtype: float
    """
    pass    


def get_object_bone_quat_y(object_id: int, bone: int) -> float:
    """
    Returns the Y component of the bone's current rotation converted to a quaternion.

    :param int object_id: The ID of the object that contains the bone to check.
    :param int bone: The index of the bone to check.
    :rtype: float
    """
    pass    


def get_object_bone_quat_z(object_id: int, bone: int) -> float:
    """
    Returns the Z component of the bone's current rotation converted to a quaternion.

    :param int object_id: The ID of the object that contains the bone to check.
    :param int bone: The index of the bone to check.
    :rtype: float
    """
    pass    


def get_object_bone_world_angle_x(object_id: int, bone: int) -> float:
    """
    Returns the X component of the bone's current rotation in world coordinates converted to Euler angles.

    :param int object_id: The ID of the object that contains the bone to check.
    :param int bone: The index of the bone to check.
    :rtype: float
    """
    pass    


def get_object_bone_world_angle_y(object_id: int, bone: int) -> float:
    """
    Returns the Y component of the bone's current rotation converted to Euler angles.

    :param int object_id: The ID of the object that contains the bone to check.
    :param int bone: The index of the bone to check.
    :rtype: float
    """
    pass    


def get_object_bone_world_angle_z(object_id: int, bone: int) -> float:
    """
    Returns the Z component of the bone's current rotation converted to Euler angles.

    :param int object_id: The ID of the object that contains the bone to check.
    :param int bone: The index of the bone to check.
    :rtype: float
    """
    pass    


def get_object_bone_world_quat_w(object_id: int, bone: int) -> float:
    """
    Returns the W component of the bone's current rotation converted to a quaternion.

    :param int object_id: The ID of the object that contains the bone to check.
    :param int bone: The index of the bone to check.
    :rtype: float
    """
    pass    


def get_object_bone_world_quat_x(object_id: int, bone: int) -> float:
    """
    Returns the X component of the bone's current rotation converted to a quaternion.

    :param int object_id: The ID of the object that contains the bone to check.
    :param int bone: The index of the bone to check.
    :rtype: float
    """
    pass    


def get_object_bone_world_quat_y(object_id: int, bone: int) -> float:
    """
    Returns the Y component of the bone's current rotation converted to a quaternion.

    :param int object_id: The ID of the object that contains the bone to check.
    :param int bone: The index of the bone to check.
    :rtype: float
    """
    pass    


def get_object_bone_world_quat_z(object_id: int, bone: int) -> float:
    """
    Returns the Z component of the bone's current rotation converted to a quaternion.

    :param int object_id: The ID of the object that contains the bone to check.
    :param int bone: The index of the bone to check.
    :rtype: float
    """
    pass    


def get_object_bone_world_x(object_id: int, bone: int) -> float:
    """
    Returns the current X position of the bone in world coordinates.

    :param int object_id: The ID of the object that contains the bone to check.
    :param int bone: The index of the bone to check.
    :rtype: float
    """
    pass    


def get_object_bone_world_y(object_id: int, bone: int) -> float:
    """
    Returns the current Y position of the bone in world coordinates.

    :param int object_id: The ID of the object that contains the bone to check.
    :param int bone: The index of the bone to check.
    :rtype: float
    """
    pass    


def get_object_bone_world_z(object_id: int, bone: int) -> float:
    """
    Returns the current Z position of the bone in world coordinates.

    :param int object_id: The ID of the object that contains the bone to check.
    :param int bone: The index of the bone to check.
    :rtype: float
    """
    pass    


def get_object_bone_x(object_id: int, bone: int) -> float:
    """
    Returns the current X position of the bone.

    :param int object_id: The ID of the object that contains the bone to check.
    :param int bone: The index of the bone to check.
    :rtype: float
    """
    pass    


def get_object_bone_y(object_id: int, bone: int) -> float:
    """
    Returns the current Y position of the bone.

    :param int object_id: The ID of the object that contains the bone to check.
    :param int bone: The index of the bone to check.
    :rtype: float
    """
    pass    


def get_object_bone_z(object_id: int, bone: int) -> float:
    """
    Returns the current Z position of the bone.

    :param int object_id: The ID of the object that contains the bone to check.
    :param int bone: The index of the bone to check.
    :rtype: float
    """
    pass    


def get_object_cast_shadow_mode(object_id: int) -> bool:
    """
    Returns True if the object is currently set to cast shadows, False otherwise.

    :param int object_id: The ID of the object to check.
    :rtype: bool
    """
    pass    


def get_object_child_id(object_id: int, child: int) -> int:
    """
    Returns the object ID for a specified child object that was loaded as a result of this object.

    To find the number of child objects use `get_object_num_children()`. `child` is in the range 1 to the number of
    children inclusive. For those of you that are familiar with DarkBasic, objects that contained limbs in DarkBasic
    would be loaded as child objects in AGK. However there is no hierarchy in the child objects, they would not have
    children of their own. Instead a bone structure is created in the root object that represents the limb hierarchy,
    and the child objects are attached to the appropriate bones.

    :param int object_id: The ID of the object to check.
    :param int child: The index of the child to get.
    :rtype: int
    """
    pass    


def get_object_color_blue(object_id: int) -> int:
    """
    Returns the current blue value of this object's color, as set by `set_object_color()`.

    :param int object_id: The ID of the object to check.
    :rtype: int
    """
    pass    


def get_object_color_green(object_id: int) -> int:
    """
    Returns the current green value of this object's color, as set by `set_object_color()`.

    :param int object_id: The ID of the object to check.
    :rtype: int
    """
    pass    


def get_object_color_red(object_id: int) -> int:
    """
    Returns the current red value of this object's color, as set by `set_object_color()`.

    :param int object_id: The ID of the object to check.
    :rtype: int
    """
    pass    


def get_object_cull_mode(object_id: int) -> int:
    """
    Returns the current cull mode for this object.

    :param int object_id: The ID of the object to check.
    :rtype: int
    """
    pass    


def get_object_depth_bias(object_id: int) -> float:
    """
    Returns the current depth bias for this object.

    :param int object_id: The ID of the object to check.
    :rtype: float
    """
    pass    


def get_object_depth_read_mode(object_id: int) -> int:
    """
    Returns the current depth read mode for this object.

    :param int object_id: The ID of the object to check.
    :rtype: int
    """
    pass    


def get_object_depth_write(object_id: int) -> bool:
    """
    Returns the current depth write mode for this object.

    :param int object_id: The ID of the object to check.
    :rtype: bool
    """
    pass    


def get_object_exists(object_id: int) -> bool:
    """
    Returns True if an object exists at the given ID, False otherwise.

    :param int object_id: The ID of the object to check.
    :rtype: bool
    """
    pass    


def get_object_height_map_height(object_id: int, x: Union[float, int], z: Union[float,
                                 int]) -> float:
    """
    If the object was created with `create_object_from_height_map()` then this command can be used to quickly get the
    height of the object at a particular world position.

    This accounts for the object's position and Y rotation to provide the height regardless of where the object is
    positioned. If the object is rotated in the X or Z angles then this will produce incorrect values. You should
    provide the X and Z coordinates in world units, if the point lies outside the object then 0 will be returned.

    :param int object_id: The ID of the object to check.
    :param Union[float, int] x: The X component of the position to check.
    :param Union[float, int] z: The Z component of the position to check.
    :rtype: float
    """
    pass    


def get_object_in_screen(object_id: int) -> bool:
    """
    Returns True if AGK thinks the object is currently on screen, False if not.

    This is an estimate and if in doubt will assume the object is on screen. As such if this command returns False then
    the object is definitely off screen, if it returns True the object may or may not be on screen.

    :param int object_id: The ID of the object to check.
    :rtype: bool
    """
    pass    


def get_object_is_animating(object_id: int) -> bool:
    """
    Returns True if the object is currently playing an animation, this includes tween to the start of an animation, but
    not tweening to a single frame.

    Essentially it returns True if the object should be playing an animation. If the animation is set to loop a
    specified number of times, or to only play once, then this command will return False when the animation is finished.

    :param int object_id: The ID of the object to check.
    :rtype: bool
    """
    pass    


def get_object_is_tweening(object_id: int) -> bool:
    """
    Returns True if the object is currently tweening to an animation frame or the beginning or an animation about to
    play.

    This only occurs immediately after `play_object_animation()` or `set_object_animation_frame()` if you specified a
    tween time greater than 0. It does not occur at any other time during an animation.

    :param int object_id: The ID of the object to check.
    :rtype: bool
    """
    pass    


def get_object_mesh_name(object_id: int, mesh: int) -> str:
    """
    Gets the name of a mesh as defined in the model file that it was loaded from, but meshes are not guaranteed to have
    names.

    Mesh indices are in the range 1 to `get_object_num_meshes()` inclusive.

    :param int object_id: The ID of the object to check.
    :param int mesh: The index of the mesh to check, first mesh is at index 1.
    :rtype: str
    """
    pass    


def get_object_mesh_ps_source(object_id: int, mesh: int) -> str:
    """
    Returns the source code to the pixel shader currently being used on this object.

    If you haven't assigned a shader to this mesh then one is generated automatically, and you can use this command to
    get its source code if you want to make adjustments to it. You can then load this modified shader source with
    `load_shader()` and assign it with `set_object_mesh_shader()`. Note that modifying the number of textures, or using
    `set_object_light_mode()` will normally generate a new shader to handle the changes, however if you have used
    `set_object_mesh_shader()` then AGK will no longer modify your shader, assuming you have accounted for these changes
    yourself. Note that shaders which use lighting will have the functions GetVSLighting() and GetPSLighting() that will
    be filled out by AGK at runtime based on how many lights are near the mesh. Removing these functions from the shader
    source will remove all lighting from the mesh.

    :param int object_id: The ID of the object to check.
    :param int mesh: The index of the mesh to check, first mesh is at index 1.
    :rtype: str
    """
    pass    


def get_object_mesh_size_max_x(object_id: int, mesh: int) -> float:
    """
    Returns the maximum extent of the mesh in the X direction, this can be combined with `get_object_mesh_size_min_x()`
    to determine the size of the mesh in the X direction.

    Note that the mesh may be off center so its min value may be 10 whilst its max value is 12, meaning its size is 2
    units in the X direction.

    :param int object_id: The ID of the object to check.
    :param int mesh: The index of the mesh to check.
    :rtype: float
    """
    pass    


def get_object_mesh_size_max_y(object_id: int, mesh: int) -> float:
    """
    Returns the maximum extent of the mesh in the Y direction, this can be combined with `get_object_mesh_size_min_y()`
    to determine the size of the mesh in the Y direction.

    Note that the mesh may be off center so its min value may be 10 whilst its max value is 12, meaning its size is 2
    units in the Y direction.

    :param int object_id: The ID of the object to check.
    :param int mesh: The index of the mesh to check.
    :rtype: float
    """
    pass    


def get_object_mesh_size_max_z(object_id: int, mesh: int) -> float:
    """
    Returns the maximum extent of the mesh in the Z direction, this can be combined with `get_object_mesh_size_min_z()`
    to determine the size of the mesh in the Z direction.

    Note that the mesh may be off center so its min value may be 10 whilst its max value is 12, meaning its size is 2
    units in the Z direction.

    :param int object_id: The ID of the object to check.
    :param int mesh: The index of the mesh to check.
    :rtype: float
    """
    pass    


def get_object_mesh_size_min_x(object_id: int, mesh: int) -> float:
    """
    Returns the minimum extent of the mesh in the X direction, this can be combined with `get_object_mesh_size_max_x()`
    to determine the size of the mesh in the X direction.

    Note that the mesh may be off center so its min value may be 10 whilst its max value is 12, meaning its size is 2
    units in the X direction.

    :param int object_id: The ID of the object to check.
    :param int mesh: The index of the mesh to check.
    :rtype: float
    """
    pass    


def get_object_mesh_size_min_y(object_id: int, mesh: int) -> float:
    """
    Returns the minimum extent of the mesh in the Y direction, this can be combined with `get_object_mesh_size_max_y()`
    to determine the size of the mesh in the Y direction.

    Note that the mesh may be off center so its min value may be 10 whilst its max value is 12, meaning its size is 2
    units in the Y direction.

    :param int object_id: The ID of the object to check.
    :param int mesh: The index of the mesh to check.
    :rtype: float
    """
    pass    


def get_object_mesh_size_min_z(object_id: int, mesh: int) -> float:
    """
    Returns the minimum extent of the mesh in the Z direction, this can be combined with `get_object_mesh_size_max_z()`
    to determine the size of the mesh in the Z direction.

    Note that the mesh may be off center so its min value may be 10 whilst its max value is 12, meaning its size is 2
    units in the Z direction.

    :param int object_id: The ID of the object to check.
    :param int mesh: The index of the mesh to check.
    :rtype: float
    """
    pass    


def get_object_mesh_vs_source(object_id: int, mesh: int) -> str:
    """
    Returns the source code to the vertex shader currently being used on this object.

    If you haven't assigned a shader to this mesh then one is generated automatically, and you can use this command to
    get its source code if you want to make adjustments to it. You can then load this modified shader source with
    `load_shader()` and assign it with `set_object_mesh_shader()`. Note that modifying the number of textures, or using
    `set_object_light_mode()` will normally generate a new shader to handle the changes, however if you have used
    `set_object_mesh_shader()` then AGK will no longer modify your shader, assuming you have accounted for these changes
    yourself. Note that shaders which use lighting will have the functions GetVSLighting() and GetPSLighting() that will
    be filled out by AGK at runtime based on how many lights are near the mesh. Removing these functions from the shader
    source will remove all lighting from the mesh.

    :param int object_id: The ID of the object to check.
    :param int mesh: The index of the mesh to check, first mesh is at index 1.
    :rtype: str
    """
    pass    


def get_object_name(object_id: int) -> str:
    """
    Returns the name of the object as defined in the model file.

    This is useful when using `load_object_with_children()` to identify child objects which can be accessed with
    `get_object_child_id()`.

    :param int object_id: The ID of the object to check.
    :rtype: str
    """
    pass    


def get_object_num_animations(object_id: int) -> int:
    """
    Returns the number of animations currently assigned to the object.

    Only objects loaded with `load_object_with_children()` get animations assigned to them.

    :param int object_id: The ID of the object to check.
    :rtype: int
    """
    pass    


def get_object_num_bones(object_id: int) -> int:
    """
    Gets the number of bones that were loaded as a result of loading this object.

    This only happens if the object was loaded with `load_object_with_children()`. If the object has limb animation like
    in DarkBasic Classic, then the bones represent the limb hierarchy and each limb is loaded as a child object attached
    to a bone. If the object has weighted vertex animation then the bones represent the skeleton and the skin is loaded
    as a single mesh stored in the root object. The two forms of animation can be combined, so a weighted vertex bone
    structure can have objects attached to its bones at the same time as deforming the skin mesh.

    :param int object_id: The ID of the object to check.
    :rtype: int
    """
    pass    


def get_object_num_children(object_id: int) -> int:
    """
    Gets the number of child objects that were loaded as a result of loading this object.

    For example a bone animated character object may have a gun model attached to the bone representing its hand, this
    gun model would be loaded as a separate object and given its own ID, which you can manipulate separately from the
    main object. You can even detach the gun from the hand with `fix_object_to_bone(ID,0)` to make it a normal object
    that will not move when the character moves. It will however always remain in this list of children, for reference,
    and will get deleted if `delete_object_with_children()` is called on the character object. For those of you that are
    familiar with DarkBasic, objects that contained limbs in DarkBasic would be loaded as child objects in AGK. However
    there is no hierarchy in the child objects, they would not have children of their own. Instead a bone structure is
    created in the root object that represents the limb hierarchy, and the child objects are attached to the appropriate
    bones.

    :param int object_id: The ID of the object to check.
    :rtype: int
    """
    pass    


def get_object_num_meshes(object_id: int) -> int:
    """
    Gets the number of meshes that belong to this object.

    An object can have multiple meshes, usually this happens in the case of multi-material objects where the object is
    split into multiple meshes, each using a different texture. Note that instanced objects may not have any meshes.

    :param int object_id: The ID of the object to check.
    :rtype: int
    """
    pass    


def get_object_num_textures(object_id: int) -> int:
    """
    Gets the number of texture references that was found when loading the object.

    An object can have multiple texture references. This information will only be available if the model file have a
    material setup with a diffuse texture reference.

    :param int object_id: The ID of the object to check.
    :rtype: int
    """
    pass    


def get_object_quat_w(object_id: int) -> float:
    """
    Returns the W component of the object's current rotation converted to a quaternion.

    :param int object_id: The ID of the object to check.
    :rtype: float
    """
    pass    


def get_object_quat_x(object_id: int) -> float:
    """
    Returns the X component of the object's current rotation converted to a quaternion.

    :param int object_id: The ID of the object to check.
    :rtype: float
    """
    pass    


def get_object_quat_y(object_id: int) -> float:
    """
    Returns the Y component of the object's current rotation converted to a quaternion.

    :param int object_id: The ID of the object to check.
    :rtype: float
    """
    pass    


def get_object_quat_z(object_id: int) -> float:
    """
    Returns the Z component of the object's current rotation converted to a quaternion.

    :param int object_id: The ID of the object to check.
    :rtype: float
    """
    pass    


def get_object_ray_cast_bounce_x(index: int) -> float:
    """
    Returns the X component of the bounce vector for the last collision check.

    You can check the number of valid indices with `get_object_ray_cast_num_hits()`. Position an object here to make it
    look like it bounced after colliding.

    :param int index: The index of the collision to check, starting at index 0.
    :rtype: float
    """
    pass    


def get_object_ray_cast_bounce_y(index: int) -> float:
    """
    Returns the Y component of the bounce vector for the last collision check.

    You can check the number of valid indices with `get_object_ray_cast_num_hits()`. Position an object here to make it
    look like it bounced after colliding.

    :param int index: The index of the collision to check, starting at index 0.
    :rtype: float
    """
    pass    


def get_object_ray_cast_bounce_z(index: int) -> float:
    """
    Returns the Z component of the bounce vector for the last collision check.

    You can check the number of valid indices with `get_object_ray_cast_num_hits()`. Position an object here to make it
    look like it bounced after colliding.

    :param int index: The index of the collision to check, starting at index 0.
    :rtype: float
    """
    pass    


def get_object_ray_cast_distance(index: int) -> float:
    """
    Returns the distance between the start point for the ray and the collision point.

    :param int index: The index of the collision to check, starting at index 0.
    :rtype: float
    """
    pass    


def get_object_ray_cast_hit_id(index: int) -> int:
    """
    Returns the object ID hit for the given collision index in the last collision check.

    You can check the number of valid indices with `get_object_ray_cast_num_hits()`.

    :param int index: The index of the collision to check, starting at index 0.
    :rtype: int
    """
    pass    


def get_object_ray_cast_normal_x(index: int) -> float:
    """
    Returns the X component of the collision normal in the last collision check.

    You can check the number of valid indices with `get_object_ray_cast_num_hits()`.

    :param int index: The index of the collision to check, starting at index 0.
    :rtype: float
    """
    pass    


def get_object_ray_cast_normal_y(index: int) -> float:
    """
    Returns the Y component of the collision normal in the last collision check.

    You can check the number of valid indices with `get_object_ray_cast_num_hits()`.

    :param int index: The index of the collision to check, starting at index 0.
    :rtype: float
    """
    pass    


def get_object_ray_cast_normal_z(index: int) -> float:
    """
    Returns the Z component of the collision normal in the last collision check.

    You can check the number of valid indices with `get_object_ray_cast_num_hits()`.

    :param int index: The index of the collision to check, starting at index 0.
    :rtype: float
    """
    pass    


def get_object_ray_cast_num_hits() -> int:
    """
    Returns the number of collisions that occurred in the last collision check.

    In the case of `object_ray_cast()` and `object_sphere_cast()` this will be 0 or 1. For `object_sphere_slide()` this
    could be anywhere between 0 and 4.

    :rtype: int
    """
    pass    


def get_object_ray_cast_slide_x(index: int) -> float:
    """
    Returns the X component of the final resting point for sliding collisions.

    This is only valid for index 0 and after calling `object_sphere_slide()`. Position an object here to make it look
    like it slid after colliding.

    :param int index: The index of the collision to check, starting at index 0.
    :rtype: float
    """
    pass    


def get_object_ray_cast_slide_y(index: int) -> float:
    """
    Returns the Y component of the final resting point for sliding collisions.

    This is only valid for index 0 and after calling `object_sphere_slide()`. Position an object here to make it look
    like it slid after colliding.

    :param int index: The index of the collision to check, starting at index 0.
    :rtype: float
    """
    pass    


def get_object_ray_cast_slide_z(index: int) -> float:
    """
    Returns the Z component of the final resting point for sliding collisions.

    This is only valid for index 0 and after calling `object_sphere_slide()`. Position an object here to make it look
    like it slid after colliding.

    :param int index: The index of the collision to check, starting at index 0.
    :rtype: float
    """
    pass    


def get_object_ray_cast_x(index: int) -> float:
    """
    Returns the X component of the point of collision for the given collision index in the last collision check.

    You can check the number of valid indices with `get_object_ray_cast_num_hits()`.

    :param int index: The index of the collision to check, starting at index 0.
    :rtype: float
    """
    pass    


def get_object_ray_cast_y(index: int) -> float:
    """
    Returns the Y component of the point of collision for the given collision index in the last collision check.

    You can check the number of valid indices with `get_object_ray_cast_num_hits()`.

    :param int index: The index of the collision to check, starting at index 0.
    :rtype: float
    """
    pass    


def get_object_ray_cast_z(index: int) -> float:
    """
    Returns the Z component of the point of collision for the given collision index in the last collision check.

    You can check the number of valid indices with `get_object_ray_cast_num_hits()`.

    :param int index: The index of the collision to check, starting at index 0.
    :rtype: float
    """
    pass    


def get_object_receive_shadow_mode(object_id: int) -> bool:
    """
    Returns True if the object is currently set to receive shadows, False otherwise.

    :param int object_id: The ID of the object to check.
    :rtype: bool
    """
    pass    


def get_object_size_max_x(object_id: int) -> float:
    """
    Returns the maximum extent of the object in the X direction, this can be combined with `get_object_size_min_x()` to
    determine the size of the object in the X direction.

    Note that the object may be off center so its min value may be 10 whilst its max value is 12, meaning its size is 2
    units in the X direction. This command takes the bounds of all meshes that make up this object, to check the bounds
    of a single mesh use `get_object_mesh_size_max_x()`.

    :param int object_id: The ID of the object to check.
    :rtype: float
    """
    pass    


def get_object_size_max_y(object_id: int) -> float:
    """
    Returns the maximum extent of the object in the X direction, this can be combined with `get_object_size_min_y()` to
    determine the size of the object in the Y direction.

    Note that the object may be off center so its min value may be 10 whilst its max value is 12, meaning its size is 2
    units in the Y direction. This command takes the bounds of all meshes that make up this object, to check the bounds
    of a single mesh use `get_object_mesh_size_max_y()`.

    :param int object_id: The ID of the object to check.
    :rtype: float
    """
    pass    


def get_object_size_max_z(object_id: int) -> float:
    """
    Returns the maximum extent of the object in the Z direction, this can be combined with `get_object_size_min_z()` to
    determine the size of the object in the Z direction.

    Note that the object may be off center so its min value may be 10 whilst its max value is 12, meaning its size is 2
    units in the Z direction. This command takes the bounds of all meshes that make up this object, to check the bounds
    of a single mesh use `get_object_mesh_size_max_z()`.

    :param int object_id: The ID of the object to check.
    :rtype: float
    """
    pass    


def get_object_size_min_x(object_id: int) -> float:
    """
    Returns the minimum extent of the object in the X direction, this can be combined with `get_object_size_max_x()` to
    determine the size of the object in the X direction.

    Note that the object may be off center so its min value may be 10 whilst its max value is 12, meaning its size is 2
    units in the X direction. This command takes the bounds of all meshes that make up this object, to check the bounds
    of a single mesh use `get_object_mesh_size_min_x()`.

    :param int object_id: The ID of the object to check.
    :rtype: float
    """
    pass    


def get_object_size_min_y(object_id: int) -> float:
    """
    Returns the minimum extent of the object in the X direction, this can be combined with `get_object_size_max_y()` to
    determine the size of the object in the Y direction.

    Note that the object may be off center so its min value may be 10 whilst its max value is 12, meaning its size is 2
    units in the Y direction. This command takes the bounds of all meshes that make up this object, to check the bounds
    of a single mesh use `get_object_mesh_size_min_y()`.

    :param int object_id: The ID of the object to check.
    :rtype: float
    """
    pass    


def get_object_size_min_z(object_id: int) -> float:
    """
    Returns the minimum extent of the object in the Z direction, this can be combined with `get_object_size_max_z()` to
    determine the size of the object in the Z direction.

    Note that the object may be off center so its min value may be 10 whilst its max value is 12, meaning its size is 2
    units in the Z direction. This command takes the bounds of all meshes that make up this object, to check the bounds
    of a single mesh use `get_object_mesh_size_min_z()`.

    :param int object_id: The ID of the object to check.
    :rtype: float
    """
    pass    


def get_object_texture_name(object_id: int, texture: int) -> str:
    """
    Gets the name of a texture as defined in the model file that it was loaded from, but textures are not guaranteed to
    have names.

    Texture names are in the range 1 to `get_object_num_textures()` inclusive.

    :param int object_id: The ID of the object to check.
    :param int texture: The index of the texture to check, first texture is at index 1.
    :rtype: str
    """
    pass    


def get_object_transparency(object_id: int) -> int:
    """
    Returns the current transparency mode for this object.

    :param int object_id: The ID of the object to check.
    :rtype: int
    """
    pass    


def get_object_visible(object_id: int) -> bool:
    """
    Returns the current visibility mode for this object.

    :param int object_id: The ID of the object to check.
    :rtype: bool
    """
    pass    


def get_object_world_angle_x(object_id: int) -> float:
    """
    Returns the X component of the object's current rotation converted to Euler angles in world coordinates.

    This takes into account parent rotations as a result of `fix_object_to_object()` or `fix_object_to_bone()` and
    returns the absolute world rotation of the object.

    :param int object_id: The ID of the object to check.
    :rtype: float
    """
    pass    


def get_object_world_angle_y(object_id: int) -> float:
    """
    Returns the Y component of the object's current rotation converted to Euler angles in world coordinates.

    This takes into account parent rotations as a result of `fix_object_to_object()` or `fix_object_to_bone()` and
    returns the absolute world rotation of the object.

    :param int object_id: The ID of the object to check.
    :rtype: float
    """
    pass    


def get_object_world_angle_z(object_id: int) -> float:
    """
    Returns the Z component of the object's current rotation converted to Euler angles in world coordinates.

    This takes into account parent rotations as a result of `fix_object_to_object()` or `fix_object_to_bone()` and
    returns the absolute world rotation of the object.

    :param int object_id: The ID of the object to check.
    :rtype: float
    """
    pass    


def get_object_world_quat_w(object_id: int) -> float:
    """
    Returns the W component of the object's current rotation converted to a quaternion in world coordinates.

    This takes into account parent rotations as a result of `fix_object_to_object()` or `fix_object_to_bone()` and
    returns the absolute world rotation of the object.

    :param int object_id: The ID of the object to check.
    :rtype: float
    """
    pass    


def get_object_world_quat_x(object_id: int) -> float:
    """
    Returns the X component of the object's current rotation converted to a quaternion in world coordinates.

    This takes into account parent rotations as a result of `fix_object_to_object()` or `fix_object_to_bone()` and
    returns the absolute world rotation of the object.

    :param int object_id: The ID of the object to check.
    :rtype: float
    """
    pass    


def get_object_world_quat_y(object_id: int) -> float:
    """
    Returns the Y component of the object's current rotation converted to a quaternion in world coordinates.

    This takes into account parent rotations as a result of `fix_object_to_object()` or `fix_object_to_bone()` and
    returns the absolute world rotation of the object.

    :param int object_id: The ID of the object to check.
    :rtype: float
    """
    pass    


def get_object_world_quat_z(object_id: int) -> float:
    """
    Returns the Z component of the object's current rotation converted to a quaternion in world coordinates.

    This takes into account parent rotations as a result of `fix_object_to_object()` or `fix_object_to_bone()` and
    returns the absolute world rotation of the object.

    :param int object_id: The ID of the object to check.
    :rtype: float
    """
    pass    


def get_object_world_x(object_id: int) -> float:
    """
    Returns the current X position of the object in world coordinates.

    This takes into account parent positions as a result of `fix_object_to_object()` or `fix_object_to_bone()` and
    returns the absolute world position of the object.

    :param int object_id: The ID of the object to check.
    :rtype: float
    """
    pass    


def get_object_world_y(object_id: int) -> float:
    """
    Returns the current Y position of the object in world coordinates.

    This takes into account parent positions as a result of `fix_object_to_object()` or `fix_object_to_bone()` and
    returns the absolute world position of the object.

    :param int object_id: The ID of the object to check.
    :rtype: float
    """
    pass    


def get_object_world_z(object_id: int) -> float:
    """
    Returns the current Z position of the object in world coordinates.

    This takes into account parent positions as a result of `fix_object_to_object()` or `fix_object_to_bone()` and
    returns the absolute world position of the object.

    :param int object_id: The ID of the object to check.
    :rtype: float
    """
    pass    


def get_object_x(object_id: int) -> float:
    """
    Returns the current X position of the object.

    :param int object_id: The ID of the object to check.
    :rtype: float
    """
    pass    


def get_object_y(object_id: int) -> float:
    """
    Returns the current Y position of the object.

    :param int object_id: The ID of the object to check.
    :rtype: float
    """
    pass    


def get_object_z(object_id: int) -> float:
    """
    Returns the current Z position of the object.

    :param int object_id: The ID of the object to check.
    :rtype: float
    """
    pass    


def get_point_light_exists(light_id: int) -> bool:
    """
    returns True if the specified point light exists, False otherwise.

    :param int light_id: The ID of the light to check.
    :rtype: bool
    """
    pass    


def get_screen_x_from_3d(x: Union[float, int], y: Union[float, int], z: Union[float, int]) -> float:
    """
    Converts a 3D point into screen coordinates.

    :param Union[float, int] x: The X component of the 3D point.
    :param Union[float, int] y: The Y component of the 3D point.
    :param Union[float, int] z: The Z component of the 3D point.
    :rtype: float
    """
    pass    


def get_screen_y_from_3d(x: Union[float, int], y: Union[float, int], z: Union[float, int]) -> float:
    """
    Converts a 3D point into screen coordinates.

    :param Union[float, int] x: The X component of the 3D point.
    :param Union[float, int] y: The Y component of the 3D point.
    :param Union[float, int] z: The Z component of the 3D point.
    :rtype: float
    """
    pass    


def get_shader_exists(shader_id: int) -> bool:
    """
    Returns True if a shader is currently loaded at the given ID, otherwise it returns False.

    :param int shader_id: The ID of the shader to check.
    :rtype: bool
    """
    pass    


def get_shadow_mapping_mode() -> int:
    """
    Returns the current shadow mapping mode that was set with `set_shadow_mapping_mode()`.

    :rtype: int
    """
    pass    


def get_shadow_mapping_supported() -> bool:
    """
    Returns True if shadow mapping is supported on this device, False otherwise.

    :rtype: bool
    """
    pass    


def get_supported_shader_varyings() -> int:
    """
    Returns the number of varying values that can be used in shaders on the current device.

    Varyings are the variables that pass data between the vertex and pixel shaders. This value is guaranteed to be at
    least 32, but most devices support more. A single vec4 varying holds 4 varying values, so 32 varyings values means
    you can have a maximum of 8 vec4 varyings. Note that a vec3 varying may take up 4 value spaces if it cannot be
    packed with any other varying. Varyings will automatically be packed together if they can fill a vec4 without being
    split, for example a vec3 and a float can be packed together, as can two vec2 varyings. However two vec3 varyings
    cannot be packed together without being split up so they will each use up 4 values with the extra space being
    wasted.

    :rtype: int
    """
    pass    


def instance_object(copy_object_id: int) -> int:
    """
    Copies an object into a new ID, the new object shares vertex data with the original object.

    The original object must exist for the instanced object to draw properly. Instancing an object that is already an
    instance will do nothing. Instancing an object and then deleting the original will probably crash. Setting a shader
    on an instance object is allowed as long as the vertex attributes used by the shader match exactly in name and order
    as those used on the shader of the original object. Setting different images on the instance and original object is
    supported.

    :param int copy_object_id: The ID of the object to copy.
    :rtype: int
    """
    pass    


def instance_object_id(new_object_id: int, copy_object_id: int) -> None:
    """
    Copies an object into a new ID, the new object shares vertex data with the original object.

    The original object must exist for the instanced object to draw properly. Instancing an object that is already an
    instance will do nothing. Instancing an object and then deleting the original will probably crash. Setting a shader
    on an instance object is allowed as long as the vertex attributes used by the shader match exactly in name and order
    as those used on the shader of the original object. Setting different images on the instance and original object is
    supported.

    :param int new_object_id: The ID of the new object.
    :param int copy_object_id: The ID of the object to copy.
    :rtype: None
    """
    pass    


def load_full_screen_shader(filename: str) -> int:
    """
    Loads a shader used for modifying render targets, as such it only contains a pixel shader, the vertex shader is
    automatically generated to make sure it applies to the full screen.

    This type of shader should only be applied to objects created with `create_object_quad()` but nothing bad will
    happen if you choose to apply it to other objects, it will just produce unusual rendering results for that object.
    Currently shaders default to GLSL version 1.10, the line "#version 110" will be automatically added as the first
    line of the shader unless you specify a "#version " line of your own. Note that doing this may mean your shader does
    not work on all devices and platforms. The global "precision" value will be added and should not be included in the
    shader source. Returns an ID that can be used to reference this shader in other commands. IDs are shared across all
    shader types so loading a full screen shader into ID 1 will not work if a normal shader exists with ID 1.

    :param str filename: The file name of the pixel shader file, normally ending .ps.
    :rtype: int
    """
    pass    


def load_full_screen_shader_id(shader_id: int, filename: str) -> None:
    """
    Loads a shader used for modifying render targets, as such it only contains a pixel shader, the vertex shader is
    automatically generated to make sure it applies to the full screen.

    This type of shader should only be applied to objects created with `create_object_quad()` but nothing bad will
    happen if you choose to apply it to other objects, it will just produce unusual rendering results for that object.
    Currently shaders default to GLSL version 1.10, the line "#version 110" will be automatically added as the first
    line of the shader unless you specify a "#version " line of your own. Note that doing this may mean your shader does
    not work on all devices and platforms. The global "precision" value will be added and should not be included in the
    shader source. Returns an ID that can be used to reference this shader in other commands. IDs are shared across all
    shader types so loading a full screen shader into ID 1 will not work if a normal shader exists with ID 1.

    :param int shader_id: An ID used to reference this shader in other commands.
    :param str filename: The file name of the pixel shader file, normally ending .ps.
    :rtype: None
    """
    pass    


def load_object(filename: str, height: Optional[Union[float, int]] = None) -> int:
    """
    Loads an object from a file, currently supported formats are .x .3ds .md3 .smd .md5 .lwo .ac .b3d .dae .3d .lws
    .ms3d .blend .m3 .obj and .ago.

    This command includes the optional height parameter that will scale the object's vertices to the given height, the X
    and Z directions will be matched to this height so the object is still in proportion. This command will not load any
    animation or bone data and will consolidate the vertices into a single object with as few meshes as possible. To
    load animation and bone data use `load_object_with_children()` instead.

    Returns an ID you can use to reference this object in other commands.

    :param str filename: The name of the object file to load.
    :param Optional[Union[float, int]] height: Scale the loaded object to this height.
    :rtype: int
    """
    pass    


def load_object_id(object_id: int, filename: str, height: Optional[Union[float,
                   int]] = None) -> None:
    """
    Loads an object from a file, currently supported formats are .x .3ds .md3 .smd .md5 .lwo .ac .b3d .dae .3d .lws
    .ms3d .blend .m3 .obj and .ago.

    This command includes the optional height parameter that will scale the object's vertices to the given height, the X
    and Z directions will be matched to this height so the object is still in proportion. This command will not load any
    animation or bone data and will consolidate the vertices into a single object with as few meshes as possible. To
    load animation and bone data use `load_object_with_children()` instead.

    Returns an ID you can use to reference this object in other commands.

    :param int object_id: The ID to use for the new object.
    :param str filename: The name of the object file to load.
    :param Optional[Union[float, int]] height: Scale the loaded object to this height.
    :rtype: None
    """
    pass    


def load_object_id_with_children(object_id: int, filename: str) -> None:
    """
    Loads an object from a file, currently supported formats are .x .fbx .dae (collada) .3ds .md3 .smd .md5 .lwo .ac
    .b3d .dae .3d .lws .ms3d .blend .obj and .ago.

    If the model file contains a bone hierarchy or animation data then this will also be loaded and associated with the
    object.

    Note that objects with more than 50 bones may fail to render on some old devices. AGK has a limit of 200 bones. If
    the model file contains a scene graph containing multiple objects then these will also be loaded and stored in
    separate objects which can be discovered with `get_object_num_children()`. If you just want to load a single object
    without any bones, animation, or children then use `load_object()` instead.

    Returns an ID you can use to reference this object in other commands.

    :param int object_id: The ID to use for the new object.
    :param str filename: The name of the object file to load.
    :rtype: None
    """
    pass    


def load_object_with_children(filename: str) -> int:
    """
    Loads an object from a file, currently supported formats are .x .fbx .dae (collada) .3ds .md3 .smd .md5 .lwo .ac
    .b3d .dae .3d .lws .ms3d .blend .obj and .ago.

    If the model file contains a bone hierarchy or animation data then this will also be loaded and associated with the
    object.

    Note that objects with more than 50 bones may fail to render on some old devices. AGK has a limit of 200 bones. If
    the model file contains a scene graph containing multiple objects then these will also be loaded and stored in
    separate objects which can be discovered with `get_object_num_children()`. If you just want to load a single object
    without any bones, animation, or children then use `load_object()` instead.

    Returns an ID you can use to reference this object in other commands.

    :param str filename: The name of the object file to load.
    :rtype: int
    """
    pass    


def load_shader(vertex_filename: str, pixel_filename: str) -> int:
    """
    Loads a shader used for drawing objects.

    The vertex shader transforms the polygons into screen space and the pixel shader determines the final color of each
    pixel the object covers. Currently shaders default to GLSL version 1.10, the line "#version 110" will be
    automatically added as the first line of the shader unless you specify a "#version " line of your own. Note that
    doing this may mean your shader does not work on all devices and platforms. The global "precision" value will be
    added and should not be included in the shader source.

    :param str vertex_filename: The file name of the vertex shader file, normally ending .vs.
    :param str pixel_filename: The file name of the pixel shader file, normally ending .ps.
    :rtype: int
    """
    pass    


def load_shader_id(shader_id: int, vertex_filename: str, pixel_filename: str) -> None:
    """
    Loads a shader used for drawing objects.

    The vertex shader transforms the polygons into screen space and the pixel shader determines the final color of each
    pixel the object covers. Currently shaders default to GLSL version 1.10, the line "#version 110" will be
    automatically added as the first line of the shader unless you specify a "#version " line of your own. Note that
    doing this may mean your shader does not work on all devices and platforms. The global "precision" value will be
    added and should not be included in the shader source.

    :param int shader_id: An ID used to reference this shader in other commands.
    :param str vertex_filename: The file name of the vertex shader file, normally ending .vs.
    :param str pixel_filename: The file name of the pixel shader file, normally ending .ps.
    :rtype: None
    """
    pass    


def load_shader_from_string(vertex_source: str, pixel_source: str) -> int:
    """
    Loads a shader used for drawing objects.

    The vertex shader transforms the polygons into screen space and the pixel shader determines the final color of each
    pixel the object covers. Currently shaders default to GLSL version 1.10, the line "#version 110" will be
    automatically added as the first line of the shader unless you specify a "#version " line of your own. Note that
    doing this may mean your shader does not work on all devices and platforms. The global "precision" value will be
    added and should not be included in the shader source.

    :param str vertex_source: The file name of the vertex shader file, normally ending .vs.
    :param str pixel_source: The file name of the pixel shader file, normally ending .ps.
    :rtype: int
    """
    pass    


def load_shader_id_from_string(shader_id: int, vertex_source: str, pixel_source: str) -> None:
    """
    Loads a shader used for drawing objects.

    The vertex shader transforms the polygons into screen space and the pixel shader determines the final color of each
    pixel the object covers. Currently shaders default to GLSL version 1.10, the line "#version 110" will be
    automatically added as the first line of the shader unless you specify a "#version " line of your own. Note that
    doing this may mean your shader does not work on all devices and platforms. The global "precision" value will be
    added and should not be included in the shader source.

    :param int shader_id: An ID used to reference this shader in other commands.
    :param str vertex_source: The file name of the vertex shader file, normally ending .vs.
    :param str pixel_source: The file name of the pixel shader file, normally ending .ps.
    :rtype: None
    """
    pass    


def load_sprite_shader(filename: str) -> int:
    """
    Loads a shader used for modifying sprites, as such it only contains a pixel shader, the vertex shader is
    automatically generated to make sure it appears in the right place.

    This type of shader should only be applied to sprites but nothing bad will happen if you choose to apply it to
    objects, it will just produce unusual rendering results for that object. Currently shaders default to GLSL version
    1.10, the line "#version 110" will be automatically added as the first line of the shader unless you specify a
    "#version " line of your own. Note that doing this may mean your shader does not work on all devices and platforms.
    The global "precision" value will be added and should not be included in the shader source. Returns an ID that can
    be used to reference this shader in other commands. IDs are shared across all shader types so loading a sprite
    shader into ID 1 will not work if a 3D shader exists with ID 1.

    :param str filename: The file name of the pixel shader file, normally ending .ps.
    :rtype: int
    """
    pass    


def load_sprite_shader_id(shader_id: int, filename: str) -> None:
    """
    Loads a shader used for modifying sprites, as such it only contains a pixel shader, the vertex shader is
    automatically generated to make sure it appears in the right place.

    This type of shader should only be applied to sprites but nothing bad will happen if you choose to apply it to
    objects, it will just produce unusual rendering results for that object. Currently shaders default to GLSL version
    1.10, the line "#version 110" will be automatically added as the first line of the shader unless you specify a
    "#version " line of your own. Note that doing this may mean your shader does not work on all devices and platforms.
    The global "precision" value will be added and should not be included in the shader source. Returns an ID that can
    be used to reference this shader in other commands. IDs are shared across all shader types so loading a sprite
    shader into ID 1 will not work if a 3D shader exists with ID 1.

    :param int shader_id: An ID used to reference this shader in other commands.
    :param str filename: The file name of the pixel shader file, normally ending .ps.
    :rtype: None
    """
    pass    


def move_camera_local_x(camera_id: int, distance: Union[float, int]) -> None:
    """
    Moves the specified camera along its local X axis, i.e.

    if the camera were a character this command would make them strafe no matter which direction they were facing.

    :param int camera_id: The ID of the camera to modify, the main camera is ID 1.
    :param Union[float, int] distance: The distance to move in the local X direction, can be negative.
    :rtype: None
    """
    pass    


def move_camera_local_y(camera_id: int, distance: Union[float, int]) -> None:
    """
    Moves the specified camera along its local Y axis, i.e.

    if the camera were a character this command would make them jump no matter which direction they were facing.

    :param int camera_id: The ID of the camera to modify, the main camera is ID 1.
    :param Union[float, int] distance: The distance to move in the local Y direction, can be negative.
    :rtype: None
    """
    pass    


def move_camera_local_z(camera_id: int, distance: Union[float, int]) -> None:
    """
    Moves the specified camera along its local Z axis, i.e.

    if the camera were a character this command would make them move forwards no matter which direction they were
    facing.

    :param int camera_id: The ID of the camera to modify, the main camera is ID 1.
    :param Union[float, int] distance: The distance to move in the local Z direction, can be negative.
    :rtype: None
    """
    pass    


def move_object_local_x(object_id: int, distance: Union[float, int]) -> None:
    """
    Moves the specified object along its local X axis, i.e.

    if the object were a character this command would make them strafe no matter which direction they were facing.

    :param int object_id: The ID of the object to modify.
    :param Union[float, int] distance: The distance to move in the local X direction, can be negative.
    :rtype: None
    """
    pass    


def move_object_local_y(object_id: int, distance: Union[float, int]) -> None:
    """
    Moves the specified object along its local Y axis, i.e.

    if the object were a character this command would make them jump no matter which direction they were facing.

    :param int object_id: The ID of the object to modify.
    :param Union[float, int] distance: The distance to move in the local Y direction, can be negative.
    :rtype: None
    """
    pass    


def move_object_local_z(object_id: int, distance: Union[float, int]) -> None:
    """
    Moves the specified object along its local Z axis, i.e.

    if the object were a character this command would make them move forwards no matter which direction they were
    facing.

    :param int object_id: The ID of the object to modify.
    :param Union[float, int] distance: The distance to move in the local Z direction, can be negative.
    :rtype: None
    """
    pass    


def object_ray_cast(object_id: int, start_x: Union[float, int], start_y: Union[float, int],
                    start_z: Union[float, int], end_x: Union[float, int], end_y: Union[float, int],
                    end_z: Union[float, int]) -> int:
    """
    Casts a ray through 1 or all objects to check for intersection with the object.

    Rays are define with a start position and an end position and does not collide with backfaces, will return the
    number of the object hit first, or 0 for no collision. Ray casting commands are useful for calculating the
    collisions of bullets with levels and objects, or for representing the line of sight of an enemy to detect if they
    can see the player.

    :param int object_id: The ID of the object to check, 0 for all objects.
    :param Union[float, int] start_x: The X component of the start position.
    :param Union[float, int] start_y: The Y component of the start position.
    :param Union[float, int] start_z: The Z component of the start position.
    :param Union[float, int] end_x: The X component of the end position.
    :param Union[float, int] end_y: The Y component of the end position.
    :param Union[float, int] end_z: The Z component of the end position.
    :rtype: int
    """
    pass    


def object_sphere_cast(object_id: int, start_x: Union[float, int], start_y: Union[float, int],
                       start_z: Union[float, int], end_x: Union[float, int], end_y: Union[float,
                       int], end_z: Union[float, int], radius: Union[float, int]) -> int:
    """
    Will check if the ray starting at `start_x`, `start_y`, `start_z` and ending at `end_x`, `end_y`, `end_z`, and of
    width radius, collides with the specified object (`object_id`=0 for all). Does not collide with backfaces, will
    return the number of the object hit first, or 0 for no collision. Sphere casting commands add a width dimension to
    normal ray casting which can be used to check if a player has hit anything during movement and to position them at
    the collision point to provide 'sticky' collision, where the player stops if they hit anything. The alternative is
    sliding collision. see `object_sphere_slide()`.

    :param int object_id: The ID of the object to check, 0 for all objects.
    :param Union[float, int] start_x: The X component of the start position.
    :param Union[float, int] start_y: The Y component of the start position.
    :param Union[float, int] start_z: The Z component of the start position.
    :param Union[float, int] end_x: The X component of the end position.
    :param Union[float, int] end_y: The Y component of the end position.
    :param Union[float, int] end_z: The Z component of the end position.
    :param Union[float, int] radius: The radius of the sphere to cast.
    :rtype: int
    """
    pass    


def object_sphere_slide(object_id: int, start_x: Union[float, int], start_y: Union[float, int],
                        start_z: Union[float, int], end_x: Union[float, int], end_y: Union[float,
                        int], end_z: Union[float, int], radius: Union[float, int]) -> int:
    """
    This command does the same as `object_sphere_cast()` but over multiple iterations to produce a slide point for use
    in sliding collisions.

    It produces a slide point that is checked again to make sure this new point does not collide with any objects. This
    produces another point, which must be checked and so on. `object_sphere_slide()` uses a maximum of three iterations
    to finalize a point that will keep the sphere outside all objects checked. The command
    `get_object_ray_cast_num_hits()` can be used to get the number of iterations used by this command. Details of the
    collision point, normal, and slide point for each iteration are also available using collision indices 1 to 3 i.e.
    `get_object_ray_cast_x(1)`, `get_object_ray_cast_x(2)`, or `get_object_ray_cast_x(3)`. The final collision point,
    normal and slide point are in index 0, i.e. `get_object_ray_cast_slide_x(0)`.

    :param int object_id: The ID of the object to check, 0 for all objects.
    :param Union[float, int] start_x: The X component of the start position.
    :param Union[float, int] start_y: The Y component of the start position.
    :param Union[float, int] start_z: The Z component of the start position.
    :param Union[float, int] end_x: The X component of the end position.
    :param Union[float, int] end_y: The Y component of the end position.
    :param Union[float, int] end_z: The Z component of the end position.
    :param Union[float, int] radius: The radius of the sphere to cast.
    :rtype: int
    """
    pass    


def play_object_animation(object_id: int, name: str, start_time: Union[float, int],
                          end_time: Union[float, int], loop: int, tween_time: Union[float,
                          int]) -> None:
    """
    Plays an given animation on its parent object.

    Only objects loaded with `load_object_with_children()` will have animations assigned to them. Animation names are
    defined by the modelling program when the animations were created, you can discover what the names are by using
    `get_object_animation_name()`. The animation can be started and ended at any point in the animation using the start
    and end parameters, these are given in seconds, and if looping is turned on then the object will return to the given
    start time at the start of each loop. If you want the looping to be seamless then the bone positions at the start
    and end time must be exactly the same, as there will be no interpolation between them when it loops. The
    `tween_time` parameter can be used to interpolate between the current bone positions and the start time of the
    animation so that there is no sudden jump in bone positions. This tweening only happens once, it does not happen
    every loop, and does not contribute to the animation time. Essentially the animation is paused until tweening has
    finished. Note that as soon as this command is called the bones will be controlled by animation and cannot be moved
    with `set_object_bone_position()` or similar commands. You can regain manual control of individual bones by using
    `set_object_bone_can_animate()` on it. You can regain control of the entire bone structure by using
    `reset_object_animation()`.

    :param int object_id: The ID of the object to modify.
    :param str name: The name of the animation to play, defined by the modelling program.
    :param Union[float, int] start_time: The point in the animation at which the object should start playing, in
        seconds.
    :param Union[float, int] end_time: The point in the animation at which the object should stop playing, -1 to
        continue to the end.
    :param int loop: 1 to loop the animation forever, 0 to play once, any other positive integer to loop that many
        times.
    :param Union[float, int] tween_time: The time in seconds to transition from the objects current state to the first
        frame of animation.
    :rtype: None
    """
    pass    


def reset_object_animation(object_id: int) -> None:
    """
    Stops any playing animation and resets the object bones to their bind positions.

    :param int object_id: The ID of the object to modify.
    :rtype: None
    """
    pass    


def rotate_camera_global_x(camera_id: int, angle: Union[float, int]) -> None:
    """
    Rotates the specified camera around global X axis.

    Imagine looking at the camera as if it were an object positioned at 0,0,0 looking in a random direction. This
    command would roll it around the fixed X axis, the one which is used to define the positions of everything in the
    world.

    :param int camera_id: The ID of the camera to modify, the main camera is ID 1.
    :param Union[float, int] angle: The angle to rotate on the global X axis in degrees, positive pitches down, negative
        pitches up.
    :rtype: None
    """
    pass    


def rotate_camera_global_y(camera_id: int, angle: Union[float, int]) -> None:
    """
    Rotates the specified camera around global Y axis.

    Imagine looking at the camera as if it were an object positioned at 0,0,0 looking in a random direction. This
    command would turn it around the fixed Y axis, the one which is used to define the positions of everything in the
    world.

    :param int camera_id: The ID of the camera to modify, the main camera is ID 1.
    :param Union[float, int] angle: The angle to rotate on the global Y axis in degrees, positive turns right, negative
        turns left.
    :rtype: None
    """
    pass    


def rotate_camera_global_z(camera_id: int, angle: Union[float, int]) -> None:
    """
    Rotates the specified camera around global Z axis.

    Imagine looking at the camera as if it were an object positioned at 0,0,0 looking in a random direction. This
    command would roll it around the fixed Z axis, the one which is used to define the positions of everything in the
    world.

    :param int camera_id: The ID of the camera to modify, the main camera is ID 1.
    :param Union[float, int] angle: The angle to rotate on the global Z axis in degrees, negative is clockwise.
    :rtype: None
    """
    pass    


def rotate_camera_local_x(camera_id: int, angle: Union[float, int]) -> None:
    """
    Rotates the specified camera around its local X axis, i.e.

    if the camera were an airplane this command would make it pitch up and down no matter which direction it was facing.

    :param int camera_id: The ID of the camera to modify, the main camera is ID 1.
    :param Union[float, int] angle: The angle to rotate on the local X axis in degrees, positive looks down, negative
        looks up.
    :rtype: None
    """
    pass    


def rotate_camera_local_y(camera_id: int, angle: Union[float, int]) -> None:
    """
    Rotates the specified camera around its local Y axis, i.e.

    if the camera were an airplane this command would make it turn left and right no matter which direction it was
    facing.

    :param int camera_id: The ID of the camera to modify, the main camera is ID 1.
    :param Union[float, int] angle: The angle to rotate on the local Y axis in degrees, positive turns right, negative
        turns left.
    :rtype: None
    """
    pass    


def rotate_camera_local_z(camera_id: int, angle: Union[float, int]) -> None:
    """
    Rotates the specified camera around its local Z axis, i.e.

    if the camera were an airplane this command would make it roll left and right no matter which direction it was
    facing.

    :param int camera_id: The ID of the camera to modify, the main camera is ID 1.
    :param Union[float, int] angle: The angle to rotate on the local Z axis in degrees, negative is clockwise.
    :rtype: None
    """
    pass    


def rotate_object_bone_local_x(object_id: int, bone: int, angle: Union[float, int]) -> None:
    """
    Rotates the specified bone around its local X axis, i.e.

    if the bone were an airplane this command would make it pitch up and down no matter which direction it was facing.

    :param int object_id: The ID of the object that contains the bone.
    :param int bone: The index of the bone to modify.
    :param Union[float, int] angle: The angle to rotate on the local X axis in degrees, positive looks down, negative
        looks up.
    :rtype: None
    """
    pass    


def rotate_object_bone_local_y(object_id: int, bone: int, angle: Union[float, int]) -> None:
    """
    Rotates the specified bone around its local Y axis, i.e.

    if the bone were an airplane this command would make it turn left and right no matter which direction it was facing.

    :param int object_id: The ID of the object that contains the bone.
    :param int bone: The index of the bone to modify.
    :param Union[float, int] angle: The angle to rotate on the local Y axis in degrees, positive turns right, negative
        turns left.
    :rtype: None
    """
    pass    


def rotate_object_bone_local_z(object_id: int, bone: int, angle: Union[float, int]) -> None:
    """
    Rolls the specified bone around its local Z axis, i.e.

    if the bone were an airplane this command would make it do a barrel roll no matter which direction it was facing.

    :param int object_id: The ID of the object that contains the bone.
    :param int bone: The index of the bone to modify.
    :param Union[float, int] angle: The angle to rotate on the local Z axis in degrees, positive rolls anti-clockwise,
        negative rolls clockwise.
    :rtype: None
    """
    pass    


def rotate_object_global_x(object_id: int, angle: Union[float, int]) -> None:
    """
    Rotates the specified object around global X axis.

    Imagine the camera looking down the Z axis at an object with a random rotation. This command will pitch the object
    up and down relative to the camera regardless of which way the object is facing.

    :param int object_id: The ID of the object to modify.
    :param Union[float, int] angle: The angle to rotate on the global X axis in degrees, positive pitches down, negative
        pitches up.
    :rtype: None
    """
    pass    


def rotate_object_global_y(object_id: int, angle: Union[float, int]) -> None:
    """
    Rotates the specified object around global Y axis.

    Imagine the camera looking down the Z axis at an object with a random rotation. This command will turn the object
    left and right relative to the camera regardless of which way the object is facing.

    :param int object_id: The ID of the object to modify.
    :param Union[float, int] angle: The angle to rotate on the global Y axis in degrees, positive turns right, negative
        turns left.
    :rtype: None
    """
    pass    


def rotate_object_global_z(object_id: int, angle: Union[float, int]) -> None:
    """
    Rotates the specified object around global Z axis.

    Imagine the camera looking down the Z axis at an object with a random rotation. This command will roll the object
    left and right relative to the camera regardless of which way the object is facing.

    :param int object_id: The ID of the object to modify.
    :param Union[float, int] angle: The angle to rotate on the global Z axis in degrees, positive rolls anti-clockwise,
        negative rolls clockwise.
    :rtype: None
    """
    pass    


def rotate_object_local_x(object_id: int, angle: Union[float, int]) -> None:
    """
    Rotates the specified object around its local X axis, i.e.

    if the object were an airplane this command would make it pitch up and down no matter which direction it was facing.

    :param int object_id: The ID of the object to modify.
    :param Union[float, int] angle: The angle to rotate on the local X axis in degrees, positive looks down, negative
        looks up.
    :rtype: None
    """
    pass    


def rotate_object_local_y(object_id: int, angle: Union[float, int]) -> None:
    """
    Rotates the specified object around its local Y axis, i.e.

    if the object were an airplane this command would make it turn left and right no matter which direction it was
    facing.

    :param int object_id: The ID of the object to modify.
    :param Union[float, int] angle: The angle to rotate on the local Y axis in degrees, positive turns right, negative
        turns left.
    :rtype: None
    """
    pass    


def rotate_object_local_z(object_id: int, angle: Union[float, int]) -> None:
    """
    Rolls the specified object around its local Z axis, i.e.

    if the object were an airplane this command would make it do a barrel roll no matter which direction it was facing.

    :param int object_id: The ID of the object to modify.
    :param Union[float, int] angle: The angle to rotate on the local Z axis in degrees, positive rolls anti-clockwise,
        negative rolls clockwise.
    :rtype: None
    """
    pass    


def set_ambient_color(red: int, green: int, blue: int) -> None:
    """
    Sets a new color for the global ambient light.

    Values should be in the range 0-255 but are not limited to it. Values greater than 255 will over saturate things and
    values less than 0 will take light away. The default ambient color is 76,76,76.

    :param int red: The red component of the new color.
    :param int green: The green component of the new color.
    :param int blue: The blue component of the new color.
    :rtype: None
    """
    pass    


def set_camera_aspect(camera_id: int, aspect: Union[float, int]) -> None:
    """
    Sets the camera aspect ratio when rendering 3D.

    The default is `get_device_width()`/`get_device_height()` and provides a realistic 3D projection. If the device
    backbuffer size changes, for example if the device changes orientation, or the window size is changed, or
    `set_screen_resolution()` is called, then this value will reset to its default.

    :param int camera_id: The ID of the camera to modify, the main camera is ID 1.
    :param Union[float, int] aspect: The new aspect ratio to use.
    :rtype: None
    """
    pass    


def set_camera_bounds(camera_id: int, left: Union[float, int], right: Union[float, int],
                      top: Union[float, int], bottom: Union[float, int]) -> None:
    """
    Sets the parameters for an off center projection matrix.

    The near and far values are set separately with `set_camera_range()`. To use an off center projection matrix you
    must activate it with `set_camera_off_center()`.

    :param int camera_id: The ID of the camera to modify, the main camera is ID 1.
    :param Union[float, int] left: The left component of the projection matrix.
    :param Union[float, int] right: The right component of the projection matrix.
    :param Union[float, int] top: The top component of the projection matrix.
    :param Union[float, int] bottom: The bottom component of the projection matrix.
    :rtype: None
    """
    pass    


def set_camera_fov(camera_id: int, fov: Union[float, int]) -> None:
    """
    Sets the camera horizontal field of view (FOV).

    This determines the angle between the left and right of the camera view, the default being 70 and provides a
    realistic 3D projection. Using smaller values would look like the camera is zooming in on the scene without actually
    moving. This is sometimes used for dramatic effect in movies where the FOV zooms one way whilst the camera moves the
    other way. Using an FOV value of 0 is a special case that will generate an orthographic matrix instead of a
    projection matrix, this will make everything stay the same size no matter how near or far it is to the camera. The
    orthographic matrix will have a width of 40 world units with a height determined by the camera aspect ratio.

    :param int camera_id: The ID of the camera to modify, the main camera is ID 1.
    :param Union[float, int] fov: The field of view in degrees.
    :rtype: None
    """
    pass    


def set_camera_look_at(camera_id: int, x: Union[float, int], y: Union[float, int], z: Union[float,
                       int], roll: Union[float, int]) -> None:
    """
    Rotates the camera to look at a particular point in space with an optional roll value.

    "looking at" is defined as aligning the camera's local Z axis to point its positive side at the given point. This
    can be achieved using only the Y and X angles in Euler notation, so you can specify an optional Z angle in degrees
    to roll the camera left of right whilst always looking at the same spot.

    :param int camera_id: The ID of the camera to modify, the main camera is ID 1.
    :param Union[float, int] x: The X component of the position to look at.
    :param Union[float, int] y: The Y component of the position to look at.
    :param Union[float, int] z: The Z component of the position to look at.
    :param Union[float, int] roll: The Z angle to roll the camera when looking at the given position, negative is
        clockwise.
    :rtype: None
    """
    pass    


def set_camera_off_center(camera_id: int, active: Union[bool, int]) -> None:
    """
    Sets the camera to use an off center projection matrix.

    You must set the projection matrix values by using `set_camera_bounds()` and `set_camera_range()`.

    :param int camera_id: The ID of the camera to modify, the main camera is ID 1.
    :param Union[bool, int] active: True to use an off center projection matrix, False to use a normal matrix, default
        is False.
    :rtype: None
    """
    pass    


def set_camera_ortho_width(camera_id: int, width: Union[float, int]) -> None:
    """
    If the camera FOV is set to 0 then this will determine the width of the orthographic view, the default is 40.

    The height value will be calculated from it based on the camera aspect ratio. When using an orthographic projection
    everything remains the same size no matter how near or far it is to the camera, so when using the default width
    value, a cube of size 80 units would always fill the camera view when the camera is looking at it, since the 40 is
    measured from the center of the screen to the edge. This command will overwrite any values set with
    `set_camera_bounds()`.

    :param int camera_id: The ID of the camera to modify, the main camera is ID 1.
    :param Union[float, int] width: The width of the view in world coordinates.
    :rtype: None
    """
    pass    


def set_camera_position(camera_id: int, x: Union[float, int], y: Union[float, int], z: Union[float,
                        int]) -> None:
    """
    Sets the position of the specified camera.

    By default cameras are positioned at 0,0,0 The main camera is ID 1.

    :param int camera_id: The ID of the camera to modify, the main camera is ID 1.
    :param Union[float, int] x: The X component of the position.
    :param Union[float, int] y: The Y component of the position.
    :param Union[float, int] z: The Z component of the position.
    :rtype: None
    """
    pass    


def set_camera_range(camera_id: int, near: Union[float, int], far: Union[float, int]) -> None:
    """
    Sets the near and far planes of the camera.

    Due to rendering limitations not everything in front of the camera can be rendered so they must be limited to a
    visible range. Anything outside this range is clipped by the rendering system and is invisible. The near plane is
    the closest that an object can be to the camera and still be rendered, it must be greater than 0. Note that using
    very small values for the near plane will affect the accuracy of the depth buffer when rendering objects far away
    which might cause flickering on far away objects. This is because the depth buffer is not linear, instead it is
    skewed towards the near plane and the closer to 0 the near plane becomes the less of the depth buffer is available
    for far objects. The far plane is the maximum distance an object can be from the camera and still be rendered, it's
    maximum value is infinity but again the further you try to render an object from the near plane the less accurate
    depth buffering becomes. If an object crosses the near or far plane so that part of it is on one side and part is on
    the other the object will be cut by the plane and only the part within the view range will be visible. The default
    range is near=1, far=1000.

    :param int camera_id: The ID of the camera to modify, the main camera is ID 1.
    :param Union[float, int] near: The nearest that an object will be rendered.
    :param Union[float, int] far: The furthest that an object will be rendered.
    :rtype: None
    """
    pass    


def set_camera_rotation(camera_id: int, x: Union[float, int], y: Union[float, int], z: Union[float,
                        int]) -> None:
    """
    Sets the rotation of the specified camera using euler angles in degrees.

    Alternatively you can use `set_camera_rotation_quat()` to use a quaternion. By default cameras are created with the
    angles 0,0,0 in the order YXZ. Euler angles are compound angles where the camera starts at 0,0,0 and is then rotated
    using the given Y angle, then by the given X angle, then rolled by the given Z angle. Each 3D rotation can be
    represented by 2 Euler angle combinations, Y,X,Z and Y-180,X-180,Z-180 so either version may be returned by
    `get_camera_angle_x()`, `get_camera_angle_y()`, and `get_camera_angle_z()`. Quaternions and Euler angles can both be
    used at the same time. For example setting an Euler angle rotation will generate a quaternion representation that
    can be retrieved with `get_camera_quat_x()`, etc.

    :param int camera_id: The ID of the camera to modify, the main camera is ID 1.
    :param Union[float, int] x: The X component of the euler rotation.
    :param Union[float, int] y: The Y component of the euler rotation.
    :param Union[float, int] z: The Z component of the euler rotation.
    :rtype: None
    """
    pass    


def set_camera_rotation_quat(camera_id: int, w: Union[float, int], x: Union[float, int],
                             y: Union[float, int], z: Union[float, int]) -> None:
    """
    Sets the rotation of the specified camera using a quaternion.

    Alternatively you can use `set_camera_rotation()` to use Euler angles. By default cameras are created with the
    quaternion 1,0,0,0 in the order w,x,y,z. A Quaternion is a 4 dimensional representation of a 3D rotation with the
    property w^2+x^2+y^2+z^2 = 1 which allows easy interpolation between two rotations by linearly interpolating the two
    quaternions and normalising them. Each 3D rotation is represented by exactly 2 quaternions, w,x,y,z and -w,-x,-y,-z
    so either version may be returned by `get_camera_quat_w()`, `get_camera_quat_x()`, `get_camera_quat_y()`, and
    `get_camera_quat_z()`. Quaternions and Euler angles can both be used at the same time. For example setting a
    quaternion rotation will generate Euler representation that can be retrieved with `get_camera_angle_x()`, etc.

    :param int camera_id: The ID of the camera to modify, the main camera is ID 1.
    :param Union[float, int] w: The W component of the quaternion.
    :param Union[float, int] x: The X component of the quaternion.
    :param Union[float, int] y: The Y component of the quaternion.
    :param Union[float, int] z: The Z component of the quaternion.
    :rtype: None
    """
    pass    


def set_fog_color(red: int, green: int, blue: int) -> None:
    """
    Sets the 3D fog color.

    Objects will gradually fade to this color as they get further from the camera. Color values should be in the range 0
    to 255, but they are not limited to this and the system will accept out of range values, including negative.

    :param int red: The red component of the color.
    :param int green: The green component of the color.
    :param int blue: The blue component of the color.
    :rtype: None
    """
    pass    


def set_fog_mode(enabled: Union[bool, int]) -> None:
    """
    Sets 3D fog on or off, this can be used to create an atmospheric haze or fade objects to the background color to
    simulate reduced visibility.

    Fog will be automatically applied to all 3D objects if they are using the default shader. If you have applied your
    own shader with `set_object_shader()` then declare the function "mediump vec3 ApplyFog( mediump vec3 color, highp
    vec3 pointPos );" in the pixel shader which AGK will fill in for you at run time. "pointPos" is the pixel position
    in world coordinates, which you will need to pass in from the vertex shader.

    :param Union[bool, int] enabled: True to turn fog on, False to turn it off.
    :rtype: None
    """
    pass    


def set_fog_range(minimum: Union[float, int], maximum: Union[float, int]) -> None:
    """
    Sets the range of the 3D fog.

    No fog will occur within the minimum distance, after which the fog will begin to take affect. The maximum distance
    is not a limit and is only a rough guide for how far you want to be able to see in your scene. The fog increases
    exponentially to mimic reality, meaning it increases quickly at first then tails off and gradually reaches full
    intensity around the maximum distance.

    :param Union[float, int] minimum: The minimum distance for the fog, no fog will affect pixels within this distance
        from the camera.
    :param Union[float, int] maximum: The maximum distance for the fog, the fog will reach full intensity around this
        distance.
    :rtype: None
    """
    pass    


def set_fog_sun_color(red: int, green: int, blue: int) -> None:
    """
    Sets the 3D fog sun color.

    This is used in place of the normal fog color when the camera is facing the sun, as defined by the command
    `set_sun_direction()`. This can be used to simulate light scattering effects to make the air seem hazy. The fog sun
    color should be close to the sun color for best effect, but this need not be the case. Note that calling this
    command changes the fog calculation to a more complicated version that will reduce performance on mobile devices. To
    return to the faster method of calculating fog, make the fog sun color equal to the normal fog color.

    :param int red: The red component of the color.
    :param int green: The green component of the color.
    :param int blue: The blue component of the color.
    :rtype: None
    """
    pass    


def set_global_3d_depth(depth: int) -> None:
    """
    Sets the position of all 3D objects relative to 2D objects.

    For example using a global 3D depth of 100 would mean that all sprites at a depth less than or equal to 100 would
    appear above any 3D objects whilst sprites at a depth greater than 100 would appear below any 3D objects.

    :param int depth: The sprite depth to render 3D.
    :rtype: None
    """
    pass    


def set_object_alpha(object_id: int, alpha: int) -> None:
    """
    Sets the alpha value to use when drawing this object.

    This is the same alpha value that can be set in `set_object_color()`. Values should be in the range 0-255 but are
    not limited to it.

    :param int object_id: The ID of the object to modify.
    :param int alpha: The alpha component of the color.
    :rtype: None
    """
    pass    


def set_object_alpha_mask(object_id: int, enabled: Union[bool, int]) -> None:
    """
    Sets alpha masking on or off for this object.

    This is similar to transparency but only produces fully transparent or fully opaque pixels, there are no blended or
    semi-transparent pixels. If a pixel has an alpha value less than 128 it will be ignored, if it is greater than or
    equal to 128 then it will be drawn. This has less problems with depth ordering than when using
    `set_object_transparency()` but may be slightly slower in some cases. You should not use both transparency and alpha
    masking on the same object at the same time, only use one or the other.

    :param int object_id: The ID of the object to modify.
    :param Union[bool, int] enabled: True to use alpha masking, False to turn off alpha masking.
    :rtype: None
    """
    pass    


def set_object_animation_frame(object_id: int, name: str, time: Union[float, int],
                               tween_time: Union[float, int]) -> None:
    """
    Sets the object bone positions to match a given time in the animation.

    Only objects loaded with `load_object_with_children()` will have animations assigned to them. Animation names are
    defined by the modelling program when the animations were created, you can discover what the names are by using
    `get_object_animation_name()`. If the given time falls between keyframes then the bone positions will be
    interpolated between them. The `tween_time` parameter can be used to interpolate between the current bone positions
    and the given time of the animation so that there is no sudden jump in bone positions. Note that as soon as this
    command is called the bones will be controlled by animation and cannot be moved with `set_object_bone_position()` or
    similar commands. You can regain manual control of individual bones by using `set_object_bone_can_animate()` on it.
    You can regain control of the entire bone structure by using `reset_object_animation()`.

    :param int object_id: The ID of the object to modify.
    :param str name: The name of the animation to play, defined by the modelling program.
    :param Union[float, int] time: The point in the animation to read the bone positions, in seconds.
    :param Union[float, int] tween_time: The time in seconds to transition from the objects current state to the given
        frame.
    :rtype: None
    """
    pass    


def set_object_animation_speed(object_id: int, speed: Union[float, int]) -> None:
    """
    Sets the animation speed for the given object as a multiple of the default time, i.e.

    1.0 would use the times from the animation keyframes, 2.0 would play them twice as fast, 0.5 twice as slow, and so
    on. You can also use negative values to play the animation in reverse, or 0 to pause it.

    :param int object_id: The ID of the object to modify.
    :param Union[float, int] speed: The new animation speed to use for this object, default 1.0.
    :rtype: None
    """
    pass    


def set_object_blend_modes(object_id: int, src: int, dst: int) -> None:
    """
    When `set_object_transparency()` is set to 3 then the source and destination blend values can be specified manually
    using this command.

    The blend modes available are as follows:
     * 0 (BLEND_ZERO) = 0
     * 1 (BLEND_ONE) = 1
     * 2 (BLEND_SRC_ALPHA) = Source Pixel Alpha
     * 3 (BLEND_ONE_MINUS_SRC_ALPHA) = 1 - Source Pixel Alpha
     * 4 (BLEND_DST_ALPHA) = Destination Pixel Alpha
     * 5 (BLEND_ONE_MINUS_DST_ALPHA) = 1 - Destination Pixel Alpha
     * 6 (BLEND_SRC_COLOR) = Source Pixel Color (valid for destination mode only)
     * 7 (BLEND_ONE_MINUS_SRC_COLOR) = 1 - Source Pixel Color (valid for destination mode only)
     * 8 (BLEND_DST_COLOR) = Destination Pixel Color (valid for source mode only)
     * 9 (BLEND_ONE_MINUS_DST_COLOR) = 1 - Destination Pixel Color (valid for source mode only)
     * 10 (BLEND_SRC_ALPHA_SATURATE) = Alpha Saturate (valid for source mode only)

    The source pixel will be multiplied by the source mode, and the destination pixel will be multiplied by the
    destination mode. The two will then be added together to make the final pixel color. The source pixel is the pixel
    belonging to the object being drawn, whilst the destination pixel is the color of the pixel already on screen, which
    the current object is being drawn over.

    :param int object_id: The ID of the object to modify.
    :param int src: The blend mode to use for the source of the blend.
    :param int dst: The blend mode to use for the destination of the blend.
    :rtype: None
    """
    pass    


def set_object_bone_can_animate(object_id: int, bone: int, enabled: Union[bool, int]) -> None:
    """
    Sets whether the specified bone is controlled by animation or controlled manually.

    When controlled by animation then none of the `set_object_bone_position()` or similar commands will have any effect.
    When controlled manually the bone will maintain its current position unless modified by you.

    :param int object_id: The ID of the object that contains the bone.
    :param int bone: The index of the bone to modify.
    :param Union[bool, int] enabled: True to allow animation to affect this bone, False to allow manual control.
    :rtype: None
    """
    pass    


def set_object_bone_look_at(object_id: int, bone: int, x: Union[float, int], y: Union[float, int],
                            z: Union[float, int], roll: Union[float, int]) -> None:
    """
    Rotates the bone to look at a particular point in world space with an optional roll value.

    "looking at" is defined as aligning the bone's local Z axis to point its positive side at the given point. This can
    be achieved using only the Y and X angles in Euler notation, so you can specify an optional Z angle in degrees to
    roll the bone left of right whilst always looking at the same spot.

    :param int object_id: The ID of the object that contains the bone.
    :param int bone: The index of the bone to modify.
    :param Union[float, int] x: The X component of the position to look at.
    :param Union[float, int] y: The Y component of the position to look at.
    :param Union[float, int] z: The Z component of the position to look at.
    :param Union[float, int] roll: The Z angle to roll the bone when looking at the given position, negative is
        clockwise.
    :rtype: None
    """
    pass    


def set_object_bone_position(object_id: int, bone: int, x: Union[float, int], y: Union[float, int],
                             z: Union[float, int]) -> None:
    """
    Sets the position of the specified bone relative to its parent.

    :param int object_id: The ID of the object that contains the bone.
    :param int bone: The index of the bone to modify.
    :param Union[float, int] x: The X component of the position.
    :param Union[float, int] y: The Y component of the position.
    :param Union[float, int] z: The Z component of the position.
    :rtype: None
    """
    pass    


def set_object_bone_rotation(object_id: int, bone: int, x: Union[float, int], y: Union[float, int],
                             z: Union[float, int]) -> None:
    """
    Sets the rotation of the specified bone using euler angles in degrees.

    Alternatively you can use `set_object_bone_rotation_quat()` to use a quaternion.

    :param int object_id: The ID of the object that contains the bone.
    :param int bone: The index of the bone to modify.
    :param Union[float, int] x: The X component of the rotation.
    :param Union[float, int] y: The Y component of the rotation.
    :param Union[float, int] z: The Z component of the rotation.
    :rtype: None
    """
    pass    


def set_object_bone_rotation_quat(object_id: int, bone: int, w: Union[float, int], x: Union[float,
                                  int], y: Union[float, int], z: Union[float, int]) -> None:
    """
    Sets the rotation of the specified bone relative to its parent as a quaternion.

    :param int object_id: The ID of the object that contains the bone.
    :param int bone: The index of the bone to modify.
    :param Union[float, int] w: The W component of the rotation.
    :param Union[float, int] x: The X component of the rotation.
    :param Union[float, int] y: The Y component of the rotation.
    :param Union[float, int] z: The Z component of the rotation.
    :rtype: None
    """
    pass    


def set_object_cast_shadow(object_id: int, enabled: Union[bool, int]) -> None:
    """
    Sets an object to cast shadows on other objects.

    By default this is set to 0. An object can be set to both cast and receive shadows.

    :param int object_id: The ID of the object to cast shadows.
    :param Union[bool, int] enabled: True to make this object cast shadows, False to stop it casting shadows.
    :rtype: None
    """
    pass    


def set_object_collision_mode(object_id: int, enabled: Union[bool, int]) -> None:
    """
    Sets collision detection on or off for this object.

    :param int object_id: The ID of the object to modify.
    :param Union[bool, int] enabled: False to turn collision off, True to turn it on.
    :rtype: None
    """
    pass    


def set_object_color(object_id: int, red: int, green: int, blue: int, alpha: int) -> None:
    """
    Sets the diffuse color to use when drawing this object.

    Values should be in the range 0-255 but are not limited to it. Values greater than 255 will over saturate the object
    and values less than 0 will take light away.

    :param int object_id: The ID of the object to modify.
    :param int red: The red component of the color.
    :param int green: The green component of the color.
    :param int blue: The blue component of the color.
    :param int alpha: The alpha component of the color.
    :rtype: None
    """
    pass    


def set_object_color_emissive(object_id: int, red: int, green: int, blue: int) -> None:
    """
    Sets the emissive color to use when drawing this object.

    Values should be in the range 0-255 but are not limited to it. Values greater than 255 will over saturate the object
    and values less than 0 will take light away. The emissive color simulates light being generated by the object so it
    will gain this color even if it is not being lit by anything. This does not not affect any surrounding objects.

    :param int object_id: The ID of the object to modify.
    :param int red: The red component of the color.
    :param int green: The green component of the color.
    :param int blue: The blue component of the color.
    :rtype: None
    """
    pass    


def set_object_cull_mode(object_id: int, cull: int) -> None:
    """
    Sets whether this object should draw its back faces when rendering.

    Use mode 0 (CULL_FRONT_AND_BACK) = both front and back drawn, 1 (CULL_FRONT) = only front faces, 2 (CULL_BACK) =
    only back faces.

    By default only front faces are drawn (mode 1).

    :param int object_id: The ID of the object to modify.
    :param int cull: The cull mode to use for this object.
    :rtype: None
    """
    pass    


def set_object_depth_bias(object_id: int, bias: Union[float, int]) -> None:
    """
    Sets the depth bias when drawing this object to the screen.

    If two objects are very close together, one in front of the other, they can cause Z fighting where they appear to
    flicker between one object and the other being displayed in front of each other. For example a decal on the surface
    of another object. Z bias is designed to prevent this flickering by forcing (biasing) one object to always be in
    front of, or behind, the other. The bias value should be positive to bring this object towards the camera, and
    negative to push it backwards. This does not actually affect the position of the object, only its perceived position
    when the rendering system tests to see if the object should be drawn or not. If the object passes this biased depth
    test then it is drawn at its original position. The bias value is in multiples of the smallest z buffer value, so a
    bias value of 1 is the recommended value. Values smaller than this are not likely to have any effect, values bigger
    than this can be tried if a value of 1 does not work, try 1.5, 2.0, etc.

    :param int object_id: The ID of the object to modify.
    :param Union[float, int] bias: The bias amount, 0 to turn depth biasing off for this object.
    :rtype: None
    """
    pass    


def set_object_depth_range(object_id: int, near: Union[float, int], far: Union[float, int]) -> None:
    """
    Sets the range of depth values that this object is mapped to.

    By default this is 0 to 1 where 0 is the near plane and 1 is the far plane. For example setting a depth range of 1,1
    will make every pixel in this object have a depth value of 1 when comparing and writing to the depth buffer. Values
    will be clamped to the range 0 to 1, objects outside the near or far planes will still be clipped. Reverse mappings
    are allowed by setting near greater than far.

    :param int object_id: The ID of the object to modify.
    :param Union[float, int] near: The start of the depth range for this object.
    :param Union[float, int] far: The end of the depth range for this object.
    :rtype: None
    """
    pass    


def set_object_depth_read_mode(object_id: int, mode: int) -> None:
    """
    Sets the depth read mode when drawing this object to the screen.

    The object must pass the the depth test in order to be visible. The available options are:
     * 0 (DEPTH_NEVER)=never pass,
     * 1 (DEPTH_LT)=less than,
     * 2 (DEPTH_EQUAL)=equal,
     * 3 (DEPTH_LT_OR_EQUAL)=less than or equal,
     * 4 (DEPTH_GT)=greater than,
     * 5 (DEPTH_NOT_EQUAL)=not equal,
     * 6 (DEPTH_GT_OR_EQUAL)=greater than or equal,
     * 7 (DEPTH_ALWAYS)=always pass.

    By default all objects use the mode 1 (less than) which means they must be closer than any objects already drawn to
    be visible.

    :param int object_id: The ID of the object to modify.
    :param int mode: The depth mode to use for this object.
    :rtype: None
    """
    pass    


def set_object_depth_write(object_id: int, enabled: Union[bool, int]) -> None:
    """
    Sets the depth write mode when drawing this object to the screen.

    If it passes the depth test the object writes its depth value to the depth buffer to stop anything further behind
    from passing their depth tests. By default only objects that are closer (less than) the current depth value will
    overwrite the current contents of the screen. You can turn off this writing to the depth buffer for this object,
    this can be useful for transparent objects that shouldn't block drawing behind themselves. By default all opaque
    objects have depth write turned on and all transparent objects have depth write turned off.

    :param int object_id: The ID of the object to modify.
    :param Union[bool, int] enabled: False to turn depth write off for this object, True to turn it on.
    :rtype: None
    """
    pass    


def set_object_fog_mode(object_id: int, enabled: Union[bool, int]) -> None:
    """
    Turns fog on or off when drawing this object.

    By default all objects receive fog when it is turned on with `set_fog_mode()`.

    :param int object_id: The ID of the object to modify.
    :param Union[bool, int] enabled: False to turn fog off, True to turn it on.
    :rtype: None
    """
    pass    


def set_object_image(object_id: int, image_id: int, stage: int) -> None:
    """
    Sets all meshes in this object to use this image when rendering.

    You can set textures separately for each mesh by using `set_object_mesh_image()`. Each mesh can have up to 8 images
    assigned to it in the texture stages 0 to 7. If you are unsure of which texture stage to use, place the image in
    stage 0. Texture stages can be used to assign multiple images to a mesh, for example you might put the base
    (diffuse) texture in stage 0, a normal map in stage 1, and a light map in stage 2. The shader used to draw this
    object can then combine the various textures into a pixel value to show on the screen. Using an image value of 0 for
    a particular texture stage removes any assigned image from that stage.

    :param int object_id: The ID of the object to modify.
    :param int image_id: The ID of the image to assign to this object.
    :param int stage: The texture stage to use for this image.
    :rtype: None
    """
    pass    


def set_object_light_map(object_id: int, image_id: int) -> None:
    """
    Sets all meshes in this object to use the specified image as a lightmap.

    You can set a light map for a single mesh by using `set_object_mesh_light_map()`. The lightmap will be placed in
    texture stage 1, overwriting anything that is already there and will have a shader generated that combines it with
    texture stage 0, and any dynamic lighting, to correctly light the object. If you are setting your own shader with
    `set_object_shader()` then your shader will have to make use of the lightmap itself as AGK will not modify your
    shader in this way.

    The lightmap will use the second set of UV coordinates, if available, otherwise it will use the same UV coordinates
    as the base texture.

    :param int object_id: The ID of the object to modify.
    :param int image_id: The ID of the image to use as a light map.
    :rtype: None
    """
    pass    


def set_object_light_mode(object_id: int, enabled: Union[bool, int]) -> None:
    """
    Turns lighting on or off when drawing this object.

    :param int object_id: The ID of the object to modify.
    :param Union[bool, int] enabled: False to turn lighting off, True to turn it on.
    :rtype: None
    """
    pass    


def set_object_look_at(object_id: int, x: Union[float, int], y: Union[float, int], z: Union[float,
                       int], roll: Union[float, int]) -> None:
    """
    Rotates the object to look at a particular point in space with an optional roll value.

    "looking at" is defined as aligning the object's local Z axis to point its positive side at the given point. This
    can be achieved using only the Y and X angles in Euler notation, so you can specify an optional Z angle in degrees
    to roll the object left of right whilst always looking at the same spot.

    :param int object_id: The ID of the object to modify.
    :param Union[float, int] x: The X component of the position to look at.
    :param Union[float, int] y: The Y component of the position to look at.
    :param Union[float, int] z: The Z component of the position to look at.
    :param Union[float, int] roll: The Z angle to roll the object when looking at the given position, negative is
        clockwise.
    :rtype: None
    """
    pass    


def set_object_mesh_collision_mode(object_id: int, mesh: int, enabled: Union[bool, int]) -> None:
    """
    Sets collision detection on or off for a single mesh in a object.

    :param int object_id: The ID of the object to modify.
    :param int mesh: The index of the mesh to change collison mode, first mesh is at index 1.
    :param Union[bool, int] enabled: False to turn collision off, True to turn it on.
    :rtype: None
    """
    pass    


def set_object_mesh_image(object_id: int, mesh: int, image_id: int, stage: int) -> None:
    """
    Sets an object mesh to use this image when rendering.

    A mesh can have up to 8 images assigned to it in the texture stages 0 to 7. If you are unsure of which texture stage
    to use, place the image in stage 0. Texture stages can be used to assign multiple images to a mesh, for example you
    might put the base (diffuse) texture in stage 0, a normal map in stage 1, and a light map in stage 2. The shader
    used to draw this object can then combine the various textures into a pixel value to show on the screen. Using an
    image value of 0 for a particular texture stage removes any assigned image from that stage. Mesh indices are in the
    range 1 to `get_object_num_meshes()`.

    :param int object_id: The ID of the object to modify.
    :param int mesh: The index of the mesh to modify, first mesh is at index 1.
    :param int image_id: The ID of the image to assign to this object.
    :param int stage: The texture stage to use for this image.
    :rtype: None
    """
    pass    


def set_object_mesh_light_map(object_id: int, mesh: int, image_id: int) -> None:
    """
    Sets an object mesh to use the specified image as a lightmap.

    The lightmap will be placed in texture stage 1, overwriting anything that is already there and will have a shader
    generated that combines it with texture stage 0, and any dynamic lighting, to correctly light the object. If you are
    setting your own shader with `set_object_shader()` then your shader will have to make use of the lightmap itself as
    AGK will not modify your shader in this way. Mesh indices are in the range 1 to `get_object_num_meshes()`.

    :param int object_id: The ID of the object to modify.
    :param int mesh: The index of the mesh to modify, first mesh is at index 1.
    :param int image_id: The ID of the image to use as a light map.
    :rtype: None
    """
    pass    


def set_object_mesh_normal_map(object_id: int, mesh: int, image_id: int) -> None:
    """
    Sets an object mesh to use the specified image as a normal map.

    The normal map will be placed in texture stage 2, overwriting anything that is already there and will have a shader
    generated that combines it with any dynamic lighting, to correctly light the object. If you are setting your own
    shader with `set_object_shader()` then your shader will have to make use of the normal map itself as AGK will not
    modify your shader in this way. Mesh indices are in the range 1 to `get_object_num_meshes()`.

    :param int object_id: The ID of the object to modify.
    :param int mesh: The index of the mesh to modify, first mesh is at index 1.
    :param int image_id: The ID of the image to use as a normal map.
    :rtype: None
    """
    pass    


def set_object_mesh_normal_map_scale(object_id: int, mesh: int, u: Union[float, int],
                                     v: Union[float, int]) -> None:
    """
    Scales the normal map UV coordinates by the specified amount.

    This does not affect any other texture, but does stack on top of the object's UV offset and scale. A scale value of
    1.0 would use unmodified UVs, a scale value of 2.0 would double the UV value, and so on.

    :param int object_id: The ID of the object to modify.
    :param int mesh: The index of the mesh to modify, first mesh is at index 1.
    :param Union[float, int] u: The amount to scale the normal map in the U direction.
    :param Union[float, int] v: The amount to scale the normal map in the V direction.
    :rtype: None
    """
    pass    


def set_object_mesh_shader(object_id: int, mesh: int, shader_id: int) -> None:
    """
    Sets the shader used to draw this mesh, the shader must have been loaded with `load_shader()`.

    A shader is like a script sent to the GPU to tell it how to combine the polygon and texture data to display it on
    screen. By default meshes are assigned an internal shader that will handle lighting and texturing. If you use a
    shader ID of 0 the mesh is assigned the internal shader. Mesh indices are in the range 1 to
    `get_object_num_meshes()`.

    :param int object_id: The ID of the object to modify.
    :param int mesh: The index of the mesh to modify, first mesh is at index 1.
    :param int shader_id: The ID of the shader to use.
    :rtype: None
    """
    pass    


def set_object_mesh_uv_offset(object_id: int, mesh: int, stage: int, u: Union[float, int],
                              v: Union[float, int]) -> None:
    """
    Modifies the mesh UVs to shift them by the specified offset.

    This may push the UV coordinates outside the range 0.0 to 1.0, in which case the image wrap mode will be used to
    either clamp or repeat the texture. Use `set_image_wrap_u()` and `set_image_wrap_v()` to set the wrap mode. Note
    that the image must be a power of 2 in size to use the repeat mode.

    :param int object_id: The ID of the object to modify.
    :param int mesh: The index of the mesh to modify.
    :param int stage: The texture stage of the UVs to modify, in the range 0 to 7.
    :param Union[float, int] u: The offset to use in the U direction, the default is 0.
    :param Union[float, int] v: The offset to use in the V direction, the default is 0.
    :rtype: None
    """
    pass    


def set_object_mesh_uv_scale(object_id: int, mesh: int, stage: int, u: Union[float, int],
                             v: Union[float, int]) -> None:
    """
    Modifies the mesh UVs to scale them by the specified amount.

    This may push the UV coordinates outside the range 0.0 to 1.0, in which case the image wrap mode will be used to
    either clamp or repeat the texture. Use `set_image_wrap_u()` and `set_image_wrap_v()` to set the wrap mode. A scale
    value of 1 will leave the UV coordinates with their default values, whilst a scale value of 2.0 would double the
    number of times the texture appears across the mesh (assuming the wrap mode is set to repeat). Note that the image
    must be a power of 2 in size to use the repeat mode.

    :param int object_id: The ID of the object to modify.
    :param int mesh: The index of the mesh to modify.
    :param int stage: The texture stage of the UVs to modify, in the range 0 to 7.
    :param Union[float, int] u: The scale to use in the U direction, the default is 1.
    :param Union[float, int] v: The scale to use in the V direction, the default is 1.
    :rtype: None
    """
    pass    


def set_object_mesh_visible(object_id: int, mesh: int, visible: Union[bool, int]) -> None:
    """
    Sets whether this object's mesh is visible or not.

    :param int object_id: The ID of the object to modify.
    :param int mesh: The index of the mesh to check, first mesh is at index 1.
    :param Union[bool, int] visible: True to set this object's mesh as visible, False to hide it.
    :rtype: None
    """
    pass    


def set_object_normal_map(object_id: int, image_id: int) -> None:
    """
    Sets all meshes in this object to use the specified image as a normal map.

    You can set a normal map for a single mesh by using `set_object_mesh_normal_map()`. The normal map will be placed in
    texture stage 2, overwriting anything that is already there and will have a shader generated that combines it with
    any dynamic lighting, to correctly light the object. If you are setting your own shader with `set_object_shader()`
    then your shader will have to make use of the normal map itself as AGK will not modify your shader in this way.

    The normal map will use the second set of UV coordinates, if available, otherwise it will use the same UV
    coordinates as the base texture. If there is also an image in texture stage 1 (such as a light map) then the normal
    map will always use the base UVs.

    :param int object_id: The ID of the object to modify.
    :param int image_id: The ID of the image to use as a normal map.
    :rtype: None
    """
    pass    


def set_object_normal_map_scale(object_id: int, u: Union[float, int], v: Union[float, int]) -> None:
    """
    Scales the normal map UV coordinates by the specified amount.

    This does not affect any other texture, but does stack on top of the object's UV offset and scale. A scale value of
    1.0 would use unmodified UVs, a scale value of 2.0 would double the UV value, and so on.

    :param int object_id: The ID of the object to modify.
    :param Union[float, int] u: The amount to scale the normal map in the U direction.
    :param Union[float, int] v: The amount to scale the normal map in the V direction.
    :rtype: None
    """
    pass    


def set_object_position(object_id: int, x: Union[float, int], y: Union[float, int], z: Union[float,
                        int]) -> None:
    """
    Sets the position of the specified object.

    By default objects are positioned at 0,0,0.

    :param int object_id: The ID of the object to modify.
    :param Union[float, int] x: The X component of the position.
    :param Union[float, int] y: The Y component of the position.
    :param Union[float, int] z: The Z component of the position.
    :rtype: None
    """
    pass    


def set_object_receive_shadow(object_id: int, enabled: Union[bool, int]) -> None:
    """
    Sets an object to receive shadows from other objects.

    By default this is set to 1. An object can be set to both cast and receive shadows.

    :param int object_id: The ID of the object to receive shadows.
    :param Union[bool, int] enabled: True to make this object receive shadows, False to stop it receiving shadows.
    :rtype: None
    """
    pass    


def set_object_rotation(object_id: int, x: Union[float, int], y: Union[float, int], z: Union[float,
                        int]) -> None:
    """
    Sets the rotation of the specified object using euler angles in degrees.

    Alternatively you can use `set_object_rotation_quat()` to use a quaternion. By default objects are created with the
    angles 0,0,0 in the order YXZ. Euler angles are compound angles where the object starts at 0,0,0 and is then rotated
    using the given Y angle, then by the given X angle, then rolled by the given Z angle. Each 3D rotation can be
    represented by 2 Euler angle combinations, Y,X,Z and Y-180,X-180,Z-180 so either version may be returned by
    `get_object_angle_x()`, `get_object_angle_y()`, and `get_object_angle_z()`. Quaternions and Euler angles can both be
    used at the same time. For example setting a quaternion rotation will generate equivalent Euler values that can be
    retrieved with `get_object_angle_x()`, `get_object_angle_y()`, and `get_object_angle_z()`.

    :param int object_id: The ID of the object to modify.
    :param Union[float, int] x: The X component of the euler rotation.
    :param Union[float, int] y: The Y component of the euler rotation.
    :param Union[float, int] z: The Z component of the euler rotation.
    :rtype: None
    """
    pass    


def set_object_rotation_quat(object_id: int, w: Union[float, int], x: Union[float, int],
                             y: Union[float, int], z: Union[float, int]) -> None:
    """
    Sets the rotation of the specified object using a quaternion.

    Alternatively you can use `set_object_rotation()` to use Euler angles. By default objects are created with the
    quaternion 1,0,0,0 in the order w,x,y,z. A Quaternion is a 4 dimensional representation of a 3D rotation with the
    property w^2+x^2+y^2+z^2 = 1 which allows easy interpolation between two rotations by linearly interpolating the two
    quaternions and normalising them. Each 3D rotation is represented by exactly 2 quaternions, w,x,y,z and -w,-x,-y,-z
    so either version may be returned by `get_object_quat_w()`, `get_object_quat_x()`, `get_object_quat_y()`, and
    `get_object_quat_z()`. Quaternions and Euler angles can both be used at the same time. For example setting a
    quaternion rotation will generate equivalent Euler values that can be retrieved with `get_object_angle_x()`,
    `get_object_angle_y()`, and `get_object_angle_z()`.

    :param int object_id: The ID of the object to modify.
    :param Union[float, int] w: The W component of the quaternion.
    :param Union[float, int] x: The X component of the quaternion.
    :param Union[float, int] y: The Y component of the quaternion.
    :param Union[float, int] z: The Z component of the quaternion.
    :rtype: None
    """
    pass    


def set_object_scale(object_id: int, x: Union[float, int], y: Union[float, int], z: Union[float,
                     int]) -> None:
    """
    Modifies the object size in the X, Y, and Z directions.

    A scale value of 1,1,1 returns the object to its original size, a scale value of 2 would make the object twice as
    big, 0.5 would be half the size, and so on. This command does not stack, so calling it twice with a value of 2 would
    not make it 4 times bigger, it would remain 2 times bigger. Note that using different values for the X, Y, and Z
    directions like so 1,2,1 is called a non-uniform scale, whilst 1.5,1.5,1.5 would be a uniform scale. Non-uniform
    scaling requires that any shader used by this object use the agk_WorldNormal matrix for any normal transformations
    to look correct. If this object was loaded with `load_object_with_children()` command and has child objects, or has
    objects attached to it with `fix_object_to_object()`, then they will also be scaled by this amount in addition to
    their own scaling. Note that this will not work correctly with bone animated objects, use
    `set_object_scale_permanent()` instead.

    :param int object_id: The ID of the object to modify.
    :param Union[float, int] x: The amount to scale the object on the X axis.
    :param Union[float, int] y: The amount to scale the object on the Y axis.
    :param Union[float, int] z: The amount to scale the object on the Z axis.
    :rtype: None
    """
    pass    


def set_object_scale_permanent(object_id: int, x: Union[float, int], y: Union[float, int],
                               z: Union[float, int]) -> None:
    """
    Modifies the object size in the X, Y, and Z directions.

    This modifies the object's vertices which makes this a permanent change, and is slower than `set_object_scale()`.
    This command does not read or affect the values set with `set_object_scale()` so using `set_object_scale(id, 2, 2,
    2)` and then setting a permanent scale of 3,3,3 would still draw the object 2 times bigger than normal, which means
    6 times bigger than when you started. This command does not affect any child objects that may have been loaded with
    it, nor any objects attached to it with `fix_object_to_object()`. This command will work on bone animated objects as
    long as the scale is uniform, i.e. the X, Y, and Z scale values are all the same.

    :param int object_id: The ID of the object to modify.
    :param Union[float, int] x: The amount to scale the object on the X axis.
    :param Union[float, int] y: The amount to scale the object on the Y axis.
    :param Union[float, int] z: The amount to scale the object on the Z axis.
    :rtype: None
    """
    pass    


def set_object_screen_culling(object_id: int, enabled: Union[bool, int]) -> None:
    """
    Sets whether the object will be culled when it moves off screen.

    By default AGK will attempt to detect when an object has moved off screen, and objects that are no longer on screen
    will no longer be sent to the render pipeline. If the vertex shader modifies the vertices from their normal
    positions then this should be turned off as AGK can't know in advance where the object will be drawn.

    :param int object_id: The ID of the object to modify.
    :param Union[bool, int] enabled: False to turn off screen culling, True to turn it on (default).
    :rtype: None
    """
    pass    


def set_object_shader(object_id: int, shader_id: int) -> None:
    """
    Sets the shader used to draw the meshes in this object, each mesh can have its own shader set with
    `set_object_mesh_shader()`, this command sets all meshes in this object to use the specified shader.

    The shader must have been loaded with `load_shader()`. A shader is like a script sent to the GPU to tell it how to
    combine the polygon and texture data to display it on screen. By default meshes are assigned an internal shader that
    will handle lighting and texturing. If you use a shader ID of 0 the meshes are assigned the internal shader.

    :param int object_id: The ID of the object to modify.
    :param int shader_id: The ID of the shader to use.
    :rtype: None
    """
    pass    


def set_object_shader_constant_array_by_name(object_id: int, name: str, index: int,
                                             value1: Union[float, int],
                                             value2: Optional[Union[float, int]] = 0.0,
                                             value3: Optional[Union[float, int]] = 0.0,
                                             value4: Optional[Union[float, int]] = 0.0) -> None:
    """
    Sets a shader constant array index for an object by name, the constant must be marked as "uniform" in the shader
    source. The object will set the specified constant to this value for any shader that it is applied to it. Array
    indices start at 0, if the array index is out of bounds then it will be ignored and no changes will be made. All
    shader values have 1 to 4 components, this command accepts 4 values and discards any that are not used by the named
    variable.

    :param int object_id: The ID of the object to modify.
    :param str name: The name of the constant to change, as defined in the shader source file.
    :param int index: The index of the element within the array to modify.
    :param Union[float, int] value1: The X or R component of the new value, this value will always be used.
    :param Optional[Union[float, int]] value2: The Y or G component of the new value, if the constant only uses 1
        component this value is discarded.
    :param Optional[Union[float, int]] value3: The Z or B component of the new value, if the constant only uses 2
        components this value is discarded.
    :param Optional[Union[float, int]] value4: The W or A component of the new value, if the constant only uses 3
        components this value is discarded.
    :rtype: None
    """
    pass    


def set_object_shader_constant_by_name(object_id: int, name: str, value1: Union[float, int],
                                       value2: Optional[Union[float, int]] = 0.0,
                                       value3: Optional[Union[float, int]] = 0.0,
                                       value4: Optional[Union[float, int]] = 0.0) -> None:
    """
    Sets a shader constant for an object by name, the constant must be marked as "uniform" in the shader source.

    The object will set the specified constant to this value for any shader that it is applied to it. All shader values
    have 1 to 4 components, this command accepts 4 values and discards any that are not used by the named variable.

    :param int object_id: The ID of the object to modify.
    :param str name: The name of the constant to change, as defined in the shader source file.
    :param Union[float, int] value1: The X or R component of the new value, this value will always be used.
    :param Optional[Union[float, int]] value2: The Y or G component of the new value, if the constant only uses 1
        component this value is discarded.
    :param Optional[Union[float, int]] value3: The Z or B component of the new value, if the constant only uses 2
        components this value is discarded.
    :param Optional[Union[float, int]] value4: The W or A component of the new value, if the constant only uses 3
        components this value is discarded.
    :rtype: None
    """
    pass    


def set_object_shader_constant_default(object_id: int, name: str) -> None:
    """
    Stops an object setting the given constant name in its shaders and uses the shader's default value from now on.

    :param int object_id: The ID of the object to modify.
    :param str name: The name of the constant to stop changing.
    :rtype: None
    """
    pass    


def set_object_transparency(object_id: int, mode: int) -> None:
    """
    Sets the transparency mode for this object, 0 (TRANSPARENCY_NONE) is opaque, 1 (TRANSPARENCY_ALPHA) is alpha
    blended, 2 (TRANSPARENCY_ADDITIVE) is additive blended, 3 (TRANSPARENCY_CUSTOM) is custom blending.

    Using a transparency value greater than 0 will slow down rendering, it also doesn't write transparent objects to the
    Z buffer so it might cause some depth ordering problems. There is an alternative form of transparency called Alpha
    Masking that is useful if you only need fully transparent or fully opaque pixels but no blending in between. See
    `set_object_alpha_mask()` for more details.

    When using mode 3 (TRANSPARENCY_CUSTOM) the blend values must be specified with `set_object_blend_modes()` otherwise
    the object will not be transparent.

    :param int object_id: The ID of the object to modify.
    :param int mode: The transparency mode to use for this object.
    :rtype: None
    """
    pass    


def set_object_uv_offset(object_id: int, stage: int, u: Union[float, int], v: Union[float,
                         int]) -> None:
    """
    Modifies all meshes in the object to use the specified UV offset, see `set_object_mesh_uv_offset()` for more
    information.

    :param int object_id: The ID of the object to modify.
    :param int stage: The texture stage of the UVs to modify, in the range 0 to 7.
    :param Union[float, int] u: The offset to use in the U direction, the default is 0.
    :param Union[float, int] v: The offset to use in the V direction, the default is 0.
    :rtype: None
    """
    pass    


def set_object_uv_scale(object_id: int, stage: int, u: Union[float, int], v: Union[float,
                        int]) -> None:
    """
    Modifies all meshes in the object to use the specified UV scale, see `set_object_mesh_uv_scale()` for more
    information.

    :param int object_id: The ID of the object to modify.
    :param int stage: The texture stage of the UVs to modify, in the range 0 to 7.
    :param Union[float, int] u: The scale to use in the U direction, the default is 1.
    :param Union[float, int] v: The scale to use in the V direction, the default is 1.
    :rtype: None
    """
    pass    


def set_object_visible(object_id: int, visible: Union[bool, int]) -> None:
    """
    Sets whether this object is visible or not.

    It will still participate in collisions and other non-visual interactions.

    :param int object_id: The ID of the object to modify.
    :param Union[bool, int] visible: True to set this object as visible, False to hide it.
    :rtype: None
    """
    pass    


def set_point_light_color(light_id: int, red: int, green: int, blue: int) -> None:
    """
    Changes the point light to a new color.

    Values should be in the range 0-255 but are not limited to it. Values greater than 255 will over saturate things and
    values less than 0 will take light away.

    :param int light_id: The ID of the light to modify.
    :param int red: The red component of the light color.
    :param int green: The green component of the light color.
    :param int blue: The blue component of the light color.
    :rtype: None
    """
    pass    


def set_point_light_mode(light_id: int, mode: int) -> None:
    """
    Sets the point light to vertex or pixel mode.

    Vertex mode is faster but pixel mode has better quality. By default lights are created in vertex mode. A mesh can be
    lit by up to 8 vertex lights and 4 pixel lights at a time, if you add more lights than this then the closest lights
    will be used by the mesh.

    :param int light_id: The ID of the light to modify.
    :param int mode: 0 (POINT_LIGHT_VERTEX) for vertex, 1 (POINT_LIGHT_PIXEL) for pixel mode.
    :rtype: None
    """
    pass    


def set_point_light_position(light_id: int, x: Union[float, int], y: Union[float, int],
                             z: Union[float, int]) -> None:
    """
    Places the point light at a new position.

    :param int light_id: The ID of the light to modify.
    :param Union[float, int] x: The X component of the new position.
    :param Union[float, int] y: The Y component of the new position.
    :param Union[float, int] z: The Z component of the new position.
    :rtype: None
    """
    pass    


def set_point_light_radius(light_id: int, radius: Union[float, int]) -> None:
    """
    Changes the point light to a new radius of affect.

    Objects greater than this distance from the light will receive zero light from it.

    :param int light_id: The ID of the light to modify.
    :param Union[float, int] radius: The distance that the light can affect.
    :rtype: None
    """
    pass    


def set_shader_constant_array_by_name(shader_id: int, name: str, index: int, value1: Union[float,
                                      int], value2: Optional[Union[float, int]] = 0.0,
                                      value3: Optional[Union[float, int]] = 0.0,
                                      value4: Optional[Union[float, int]] = 0.0) -> None:
    """
    Sets a shader constant array index by name, the constant must be marked as "uniform" in the shader source.

    Array indices start at 0, if the array index is out of bounds then it will be ignored and no changes will be made.
    This will affect all objects drawn using this shader. All shader values have 1 to 4 components, this command accepts
    4 values and discards any that are not used by the named variable.

    :param int shader_id: The ID of the shader to modify.
    :param str name: The name of the constant to change, as defined in the shader source file.
    :param int index: The index of the element within the array to modify.
    :param Union[float, int] value1: The X or R component of the new value, this value will always be used.
    :param Optional[Union[float, int]] value2: The Y or G component of the new value, if the constant only uses 1
        component this value is discarded.
    :param Optional[Union[float, int]] value3: The Z or B component of the new value, if the constant only uses 2
        components this value is discarded.
    :param Optional[Union[float, int]] value4: The W or A component of the new value, if the constant only uses 3
        components this value is discarded.
    :rtype: None
    """
    pass    


def set_shader_constant_by_name(shader_id: int, name: str, value1: Union[float, int],
                                value2: Optional[Union[float, int]] = 0.0,
                                value3: Optional[Union[float, int]] = 0.0,
                                value4: Optional[Union[float, int]] = 0.0) -> None:
    """
    Sets a shader constant by name, the constant must be marked as "uniform" in the shader source.

    This will affect all objects drawn using this shader. All shader values have 1 to 4 components, this command accepts
    4 values and discards any that are not used by the named variable.

    :param int shader_id: The ID of the shader to modify.
    :param str name: The name of the constant to change, as defined in the shader source file.
    :param Union[float, int] value1: The X or R component of the new value, this value will always be used.
    :param Optional[Union[float, int]] value2: The Y or G component of the new value, if the constant only uses 1
        component this value is discarded.
    :param Optional[Union[float, int]] value3: The Z or B component of the new value, if the constant only uses 2
        components this value is discarded.
    :param Optional[Union[float, int]] value4: The W or A component of the new value, if the constant only uses 3
        components this value is discarded.
    :rtype: None
    """
    pass    


def set_shadow_bias(bias: Union[float, int]) -> None:
    """
    Sets the bias to shift shadows so that object surfaces don't shadow themselves, default is 0.001.

    This can help prevent shadow artifacts on surfaces that are in light but also casting a shadow behind themselves.

    :param Union[float, int] bias: The distance to shift shadows.
    :rtype: None
    """
    pass    


def set_shadow_cascade_values(cascade1: Union[float, int], cascade2: Union[float, int],
                              cascade3: Union[float, int]) -> None:
    """
    When using cascade shadow maps (`set_shadow_mapping_mode(SHADOW_MAP_CASCADE)`), this command sets the range that
    each cascade map will cover. In total there are 4 cascade shadow maps, the fourth one always covers the entire
    shadowed area (cascade4 = 1.0), by default the third cascade covers half the shadowed area (`cascade3` = 0.5), the
    second cascade covers a quarter of the shadowed area (`cascade2` = 0.25), and the first cascade covers one eighth of
    the shadowed area (`cascade1` = 0.125). Since all the cascade shadow maps use the same resolution, the smaller the
    area it covers the greater the shadow detail will be in that area. The cascade shadow maps are ordered so that the
    smallest one is closest to the camera, and the largest is the furthest away. In this way the shadows close to the
    camera should have high detail whilst the ones furthest away, which area less noticeable, will have lower detail.
    Note that whilst using a smaller area for a particular cascade will increase the shadow quality, it will reduce the
    area which that cascade covers, so shadow quality will drop to the next level sooner as the distance from the camera
    increases.

    Cascade levels must be in the range 0.0 to 1.0, and each level must be greater than the previous level, i.e.
    `cascade2` must be greater than `cascade1`, and so on. If these rules are broken then this command will do nothing.

    :param Union[float, int] cascade1: The smallest cascade level, must be less than `cascade2`, must be greater than
        0.0
    :param Union[float, int] cascade2: The second cascade level, must be less than `cascade3`
    :param Union[float, int] cascade3: The third cascade level, must be less than 1.0
    :rtype: None
    """
    pass    


def set_shadow_light_step_size(step: Union[float, int]) -> None:
    """
    Limits the directional light angle to steps of the given size rather than being a continuous value.

    This can prevent shadow shimmering if the directional light is slowly changing its angle, such as the sun moving
    across the sky. By default this is set to 0 which disables the step size and keeps the angle as a continuous value.
    Values in the range 0.1 to 2.0 seem to work best. This only applies if the `set_shadow_mapping_mode()` is set to
    Uniform.

    :param Union[float, int] step: The light angle step size in degrees.
    :rtype: None
    """
    pass    


def set_shadow_mapping_mode(mode: int) -> None:
    """
    Turns shadow mapping on or off, by default this is off.

    Shadows are only generated by the the global directional light, which can be controlled with the
    `set_sun_direction()` command. Note that this is not guaranteed to be supported on all devices, you can check for
    the current device by calling `get_shadow_mapping_supported()`. There are currently three shadow modes that can be
    used, mode 1 (SHADOW_MAP_UNIFORM) uses Uniform shadow mapping which has lower but consistent quality. Mode 2
    (SHADOW_MAP_LISPSM) uses Light Space Perspective shadow mapping (LiSPSM) which has higher quality in most cases but
    if the camera is looking in the same direction as the light then it is no better than Uniform shadow mapping. Light
    Space Perspective also suffers from shadow shimmering as the camera moves whereas Uniform is more stable. Both have
    about the same performance. Mode 3 (SHADOW_MAP_CASCADE) uses Cascade shadow mapping which uses multiple shadow maps
    to maintain high quality near the camera whilst still allowing lower quality shadows in the distance. This method
    has much lower performance than the previous two methods but results in better quality shadows in all cases.

    Note that when using modes 1 (SHADOW_MAP_UNIFORM) and 2 (SHADOW_MAP_LISPSM), texture stage 7 on all objects
    receiving shadow is reserved for the shadow map. When using shadow mode 3 (SHADOW_MAP_CASCADE) then texture stages
    4, 5, 6, and 7 are reserved for the shadow maps.

    :param int mode: 0 (SHADOW_MAP_NONE) to turn it off, 1 (SHADOW_MAP_UNIFORM) to use Uniform shadows, 2
        (SHADOW_MAP_LISPSM) to use LiPSM shadows, 3 (SHADOW_MAP_CASCADE) to use Cascade shadows.
    :rtype: None
    """
    pass    


def set_shadow_map_size(width: int, height: int) -> None:
    """
    Sets the shadow map resolution in pixels.

    Good values are 512x512 or 1024x1024, it does not need to be a power of two in size. The higher the resolution the
    better quality the shadows will be, although performance will be lower with higher resolution shadow maps.

    :param int width: The width in pixels to use for the shadow map.
    :param int height: The height in pixels to use for the shadow map.
    :rtype: None
    """
    pass    


def set_shadow_range(range: Union[float, int]) -> None:
    """
    Sets the range from the camera that shadows will be drawn.

    Ideally this would be set to the camera far range from `set_camera_range()`, but drawing shadows all the way to the
    far plane may take some quality away from those shadows closer to the camera. Therefore setting the shadow range
    lower than the camera far range may improve shadow quality at the expense of distant objects not having shadows. The
    actual shadow range will be the lower value of the the camera far range and this shadow range, so you can safely set
    it larger than the camera far range without any effect on quality. If you later adjust the camera far range then the
    shadow range will not change accordingly, you must set it separately.

    Use a value of -1 to ignore this value and always use the camera far range for shadows. By default this is set to
    -1.

    :param Union[float, int] range: The distance to stop drawing shadows, -1 to use the camera far range instead.
    :rtype: None
    """
    pass    


def set_shadow_smoothing(mode: int) -> None:
    """
    Sets the smoothing mode for the shadow map.

    Mode 0 turns smoothing off and results in the fastest shadows but produces hard edges. Mode 1 is slightly slower but
    produces softer shadows by sampling the shadow map multiple times. Mode 2 uses random multisampling to avoid banding
    produced by mode 1, but is slower still.

    :param int mode: 0 (SHADOW_SMOOTHING_NONE) to use no smoothing, 1 (SHADOW_SMOOTHING_MULTISAMPLE) to use
        multismapling, 2 (SHADOW_SMOOTHING_RANDOM_MULTISAMPLE) to use random multisampling.
    :rtype: None
    """
    pass    


def set_sky_box_horizon_color(red: int, green: int, blue: int) -> None:
    """
    Sets the color that will appear at the horizon.

    By default this is 255,255,255. Colors should be in the range 0 to 255, although this is not limited and values
    outside this range will be accepted, including negative values.

    :param int red: The red component of the sky color.
    :param int green: The green component of the sky color.
    :param int blue: The blue component of the sky color.
    :rtype: None
    """
    pass    


def set_sky_box_horizon_size(size: Union[float, int], height: Union[float, int]) -> None:
    """
    Sets the size and height of the horizon.

    By default the size is 4.0 and the height is 0.0. This affects how high the horizon color extends before becoming
    the sky color. The height value is in world coordinates and everything at or below this height will be the horizon
    color. Above this height the horizon is blended into the sky color until at a certain point only the sky color
    remains. The horizon will always be at the specified height in the world, even if the camera moves up and down. The
    size value is not relative to any world units and needs to be set to your liking, then effective range is from 0.1
    to about 50.0, but can be set higher. If the view range is small then the height value will appear to have greater
    effect as the sky box is drawn closer to the camera than if the view range was larger. For example a horizon height
    of 100 with a small view range will appear very high, but when the view range is larger the camera is viewing the
    horizon from much further away, so a height change of 100 units will have less effect.

    :param Union[float, int] size: The size of the horizon above the horizon height.
    :param Union[float, int] height: The height that the horizon starts.
    :rtype: None
    """
    pass    


def set_sky_box_sky_color(red: int, green: int, blue: int) -> None:
    """
    Sets the color that will fill the majority of the sky.

    By default this is 161,183,209. Colors should be in the range 0 to 255, although this is not limited and values
    outside this range will be accepted, including negative values.

    :param int red: The red component of the sky color.
    :param int green: The green component of the sky color.
    :param int blue: The blue component of the sky color.
    :rtype: None
    """
    pass    


def set_sky_box_sun_color(red: int, green: int, blue: int) -> None:
    """
    Sets the color of the sun, if visible.

    By default this is 255,230,179. Colors should be in the range 0 to 255, although this is not limited and values
    outside this range will be accepted, including negative values. Note that due to the way the sun color is added to
    the sky color, sun colors darker than the sky color may result in an unexpected sun color where one or more color
    components is completely missing. If this happens then scaling up the sun color, going above 255 if necessary, will
    remove it. The sun color has some affect on the size of the sun in addition to `set_sky_box_sun_size()`, with
    brighter colors making it bigger.

    :param int red: The red component of the sky color.
    :param int green: The green component of the sky color.
    :param int blue: The blue component of the sky color.
    :rtype: None
    """
    pass    


def set_sky_box_sun_size(sun: Union[float, int], halo: Union[float, int]) -> None:
    """
    Sets the size of the sun and its halo, if visible.

    The size values are not relative to any world units and must be in the range 1.0 to 100.0. The default values are
    5.0 for the sun and 50.0 for the halo.

    :param Union[float, int] sun: The size of the sun.
    :param Union[float, int] halo: The size of the halo around the sun.
    :rtype: None
    """
    pass    


def set_sky_box_sun_visible(visible: Union[bool, int]) -> None:
    """
    Sets whether the sky box will draw a sun at the location of the current directional light.

    It's position can be set with `set_sun_direction()`, but it will not use the directional light color, you can set
    that separately with `set_sky_box_sun_color()`. Note that setting the sun visible changes the sky box drawing
    calculations to make them more complicated which may have an impact on performance.

    :param Union[bool, int] visible: True to draw the sun, False to hide it.
    :rtype: None
    """
    pass    


def set_sky_box_visible(visible: Union[bool, int]) -> None:
    """
    Sets whether the sky box object is visible or not.

    By default it is not visible. The sky box will always appear behind all other 3D objects and will be drawn at the
    maximum visible view range, which is set with `set_camera_range()`. The sky box has an optional sun that will be
    drawn to match the current directional light direction, set with `set_sun_direction()`. However it will not use the
    directional light color, so you can have the directional light as one color and the sky box sun as another color.

    :param Union[bool, int] visible: True to show the skybox, False to hide it.
    :rtype: None
    """
    pass    


def set_sun_active(active: Union[bool, int]) -> None:
    """
    Sets whether the global directional light shines or not.

    :param Union[bool, int] active: True to active it, False to deactivate it.
    :rtype: None
    """
    pass    


def set_sun_color(red: int, green: int, blue: int) -> None:
    """
    Sets a new color for the global directional light.

    Values should be in the range 0-255 but are not limited to it. Values greater than 255 will over saturate things and
    values less than 0 will take light away.

    :param int red: The red component of the new color.
    :param int green: The green component of the new color.
    :param int blue: The blue component of the new color.
    :rtype: None
    """
    pass    


def set_sun_direction(x: Union[float, int], y: Union[float, int], z: Union[float, int]) -> None:
    """
    Sets the direction for the global directional light to shine.

    :param Union[float, int] x: The X component of the new direction.
    :param Union[float, int] y: The Y component of the new direction.
    :param Union[float, int] z: The Z component of the new direction.
    :rtype: None
    """
    pass    


def stop_object_animation(object_id: int) -> None:
    """
    Stops any animation that is currently playing on the object and leaves the bones in their current position.

    If the object is currently tweening then the tween will also be stopped with the bones left mid-tween.

    :param int object_id: The ID of the object to modify.
    :rtype: None
    """
    pass    


def add_3d_particles_color_key_frame(emitter_id: int, time: Union[float, int], red: int, green: int,
                                     blue: int, alpha: int) -> None:
    """
    Adds a color change at a certain point in a particle's life.

    For example a color added with time=1 will make the particle equal the given color when it has been alive for 1
    second. If color interpolation is turned on using `set_3d_particles_color_interpolation()` the particle will
    gradually transform from its current color to the next color. For example if you add three colors, red when time=1,
    green when time=2, and blue when time=3, then the particle will start its life as red (as that is the nearest color)
    and remain completely red until it is 1 second old. When the particle is between 1 and 2 seconds old it will
    gradually change from red to green until it is 2 seconds old, at this point it is completely green. When the
    particle is between 2 and 3 seconds old it will gradually change from green to blue until it is 3 seconds old, at
    this point it is completely blue. The particle will remain completely blue until the end of its life as no other
    colors have been added.

    :param int emitter_id: The ID of the emitter to modify.
    :param Union[float, int] time: The time that particles should become this color.
    :param int red: The red component of the new color.
    :param int green: The green component of the new color.
    :param int blue: The blue component of the new color.
    :param int alpha: The alpha component of the new color.
    :rtype: None
    """
    pass    


def add_3d_particles_force(emitter_id: int, start_time: Union[float, int], end_time: Union[float,
                           int], x: Union[float, int], y: Union[float, int], z: Union[float,
                           int]) -> None:
    """
    Adds a force that will act at a given time in every particle's life.

    For example a force set to start at time 2 and end at time 3 will start influencing particles when they have been
    alive for 2 seconds. It will continue to act on those particles until they have been alive for 3 seconds. The
    force's influence is defined by an x, y, and z value that represent acceleration in units per second. For example a
    force with x=5 will adjust a particle's horizontal speed by adding 5 units for every second the force is active, if
    the force is only active for 0.5 seconds the particle would then be moving 2.5 units per second faster in the X
    direction. Multiple forces can be acting on a particle at the same time if their timings overlap.

    :param int emitter_id: The ID of the emitter to modify.
    :param Union[float, int] start_time: The time in a particle's life at which this force should start having an
        effect.
    :param Union[float, int] end_time: The time in a particle's life at which this force should stop having an effect.
    :param Union[float, int] x: The x component of the force's influence on a particle's speed in units per second.
    :param Union[float, int] y: The y component of the force's influence on a particle's speed in units per second.
    :param Union[float, int] z: The z component of the force's influence on a particle's speed in units per second.
    :rtype: None
    """
    pass    


def add_3d_particles_scale_key_frame(emitter_id: int, time: Union[float, int], scale: Union[float,
                                     int]) -> None:
    """
    Adds a size change at a certain point in a particle's life.

    Scale values are relative to the value set by `set_3d_particles_size()` so a scale of 2 means double its normal size
    and 0.5 is half its normal size. A scale added with time=1 will make the particle gradually transform to the given
    until it has been alive for 1 second when it will match the given size. The particle will then gradually transform
    from that size to the next size (if a next size exists).

    :param int emitter_id: The ID of the emitter to modify.
    :param Union[float, int] time: The time that particles should become this size.
    :param Union[float, int] scale: The scale relative to the normal particle size, must be greater then or equal to 0.
    :rtype: None
    """
    pass    


def clear_3d_particles_colors(emitter_id: int) -> None:
    """
    Clears all colors that have been assigned to the emitter, the particles will maintain whatever color they currently
    have.

    :param int emitter_id: The ID of the emitter to modify.
    :rtype: None
    """
    pass    


def clear_3d_particles_forces(emitter_id: int) -> None:
    """
    Clears all forces assigned to this emitter.

    All forces will immediately stop influencing particles.

    :param int emitter_id: The ID of the emitter to modify.
    :rtype: None
    """
    pass    


def clear_3d_particles_scales(emitter_id: int) -> None:
    """
    Clears all size modifiers that have been assigned to the emitter, the particles will maintain whatever size they
    currently are.

    :param int emitter_id: The ID of the emitter to modify.
    :rtype: None
    """
    pass    


def create_3d_particles(x: Union[float, int], y: Union[float, int], z: Union[float, int]) -> int:
    """
    Creates a particle emitter with the given ID and the given location in world coordinates.

    Particle emitters create a flow of small sprites that last for a fixed amount of time before disappearing. The
    particles can be influenced by forces during their life using `add_3d_particles_force()`. They can also change color
    over time using `add_3d_particles_color_key_frame()`.

    Particles cannot be modified individually and behave as a group using the same texture. This allows AGK to draw them
    more efficiently than a similar number of normal objects.

    :param Union[float, int] x: The x coordinate to position this emitter.
    :param Union[float, int] y: The y coordinate to position this emitter.
    :param Union[float, int] z: The z coordinate to position this emitter.
    :rtype: int
    """
    pass    


def create_3d_particles_id(emitter_id: int, x: Union[float, int], y: Union[float, int],
                           z: Union[float, int]) -> None:
    """
    Creates a particle emitter with the given ID and the given location in world coordinates.

    Particle emitters create a flow of small sprites that last for a fixed amount of time before disappearing. The
    particles can be influenced by forces during their life using `add_3d_particles_force()`. They can also change color
    over time using `add_3d_particles_color_key_frame()`.

    Particles cannot be modified individually and behave as a group using the same texture. This allows AGK to draw them
    more efficiently than a similar number of normal objects.

    :param int emitter_id: The ID to use when referencing this 3D particle emitter.
    :param Union[float, int] x: The x coordinate to position this emitter.
    :param Union[float, int] y: The y coordinate to position this emitter.
    :param Union[float, int] z: The z coordinate to position this emitter.
    :rtype: None
    """
    pass    


def delete_3d_particles(emitter_id: int) -> None:
    """
    Deletes a 3D particle emitter and all its particles.

    If any particles were currently visible they will disappear instantly.

    :param int emitter_id: The ID of the emitter to delete.
    :rtype: None
    """
    pass    


def draw_3d_particles(emitter_id: int) -> None:
    """
    Immediately draws the particles to the backbuffer at its current position, size, and rotation.

    This is useful if you want to setup a scene for `get_image()` to capture. Remember to use `clear_screen()` to clear
    any of your own drawing before calling `sync()` or `render()` for the actual frame otherwise your drawing may appear
    twice in the final render.

    :param int emitter_id: The ID of the emitter to draw.
    :rtype: None
    """
    pass    


def get_3d_particles_active(emitter_id: int) -> bool:
    """
    Returns False if the given particles have been paused using `set_3d_particles_active()`, or True if they are
    currently updating as normal (default).

    :param int emitter_id: The ID of the emitter to check.
    :rtype: bool
    """
    pass    


def get_3d_particles_direction_range1(emitter_id: int) -> float:
    """
    Returns the first emitter angle in degrees.

    This value represents the amount of deviation a particle can have from the emitter direction when emitted. An angle
    of 0 means there is no deviation while an angle of 360 means a particle can be travelling in any direction in that
    plane when emitted.

    :param int emitter_id: The ID of the emitter to check.
    :rtype: float
    """
    pass    


def get_3d_particles_direction_range2(emitter_id: int) -> float:
    """
    Returns the second emitter angle in degrees.

    This value represents the amount of deviation a particle can have from the emitter direction when emitted. An angle
    of 0 means there is no deviation while an angle of 360 means a particle can be travelling in any direction in that
    plane when emitted.

    :param int emitter_id: The ID of the emitter to check.
    :rtype: float
    """
    pass    


def get_3d_particles_direction_x(emitter_id: int) -> float:
    """
    Returns the X component of the emitter direction, which is the base direction that particles will be moving when
    they are created.

    Particles can vary their direction slightly when emitted based on the current `set_3d_particles_direction()` value.

    :param int emitter_id: The ID of the emitter to check.
    :rtype: float
    """
    pass    


def get_3d_particles_direction_y(emitter_id: int) -> float:
    """
    Returns the y component of the emitter direction, which is the base direction that particles will be moving when
    they are created.

    Particles can vary their direction slightly when emitted based on the current `set_3d_particles_direction()` value.

    :param int emitter_id: The ID of the emitter to check.
    :rtype: float
    """
    pass    


def get_3d_particles_direction_z(emitter_id: int) -> float:
    """
    Returns the z component of the emitter direction, which is the base direction that particles will be moving when
    they are created.

    Particles can vary their direction slightly when emitted based on the current `set_3d_particles_direction()` value.

    :param int emitter_id: The ID of the emitter to check.
    :rtype: float
    """
    pass    


def get_3d_particles_exists(emitter_id: int) -> bool:
    """
    Returns True if a 3D particle emitter exists at the given ID, False if not.

    :param int emitter_id: The ID of the emitter to check.
    :rtype: bool
    """
    pass    


def get_3d_particles_frequency(emitter_id: int) -> float:
    """
    Returns the current frequency of particle generation in particles per second.

    This value is independent of frame rate.

    :param int emitter_id: The ID of the emitter to check.
    :rtype: float
    """
    pass    


def get_3d_particles_life(emitter_id: int) -> float:
    """
    Returns the current life of particles in seconds.

    It is not possible to get the current life of individual particles. This value is independent of frame rate.

    :param int emitter_id: The ID of the emitter to check.
    :rtype: float
    """
    pass    


def get_3d_particles_max_reached(emitter_id: int) -> bool:
    """
    Returns True if the emitter has emitted the number of particles specified in `set_3d_particles_max()` and all
    emitted particles have since died, otherwise returns False.

    If the max is set at -1 this will always return False. To reset the count and make the emitter start emitting again
    use `reset_3d_particle_count()`.

    :param int emitter_id: The ID of the emitter to check.
    :rtype: bool
    """
    pass    


def get_3d_particles_size(emitter_id: int) -> float:
    """
    Returns the current size of all particles in world coordinates.

    For details on setting the particle size see `set_3d_particles_size()`.

    :param int emitter_id: The ID of the emitter to check.
    :rtype: float
    """
    pass    


def get_3d_particles_visible(emitter_id: int) -> bool:
    """
    Returns False if the given particles have been set as invisible using `set_3d_particles_visible()`, or True if they
    are currently set as visible (default).

    This does not check if the particles are within the visible viewport.

    :param int emitter_id: The ID of the emitter to check.
    :rtype: bool
    """
    pass    


def get_3d_particles_x(emitter_id: int) -> float:
    """
    Returns the current X position of the emitter, this is the point that new particles will appear from.

    It is not possible to get the position of individual particles, they are merely created, follow a path influenced by
    forces, and then disappear.

    :param int emitter_id: The ID of the emitter to check.
    :rtype: float
    """
    pass    


def get_3d_particles_y(emitter_id: int) -> float:
    """
    Returns the current Y position of the emitter, this is the point that new particles will appear from.

    It is not possible to get the position of individual particles, they are merely created, follow a path influenced by
    forces, and then disappear.

    :param int emitter_id: The ID of the emitter to check.
    :rtype: float
    """
    pass    


def get_3d_particles_z(emitter_id: int) -> float:
    """
    Returns the current Z position of the emitter, this is the point that new particles will appear from.

    It is not possible to get the position of individual particles, they are merely created, follow a path influenced by
    forces, and then disappear.

    :param int emitter_id: The ID of the emitter to check.
    :rtype: float
    """
    pass    


def offset_3d_particles(emitter_id: int, x: Union[float, int], y: Union[float, int], z: Union[float,
                        int]) -> None:
    """
    Immediately moves all existing particles by the given offset.

    For example an offset of x=3,y=5,z=0 would move all particles to the right by 3 units and down 5 units. This does
    not affect the particle emitter but can be used in conjunction with `set_3d_particles_position()` to move both the
    emitter and the particles that already exist.

    :param int emitter_id: The ID of the emitter to modify.
    :param Union[float, int] x: The distance to move the particles in the X direction.
    :param Union[float, int] y: The distance to move the particles in the Y direction.
    :param Union[float, int] z: The distance to move the particles in the Z direction.
    :rtype: None
    """
    pass    


def reset_3d_particle_count(emitter_id: int) -> None:
    """
    Resets the emitted particle count when the emitter has been set with a maximum number of particles using
    `set_3d_particles_max()`.

    You can check when the emitter has reached its maximum count using `get_3d_particles_max_reached()`. If the maximum
    is set at -1 then this command has no effect.

    :param int emitter_id: The ID of the emitter to modify.
    :rtype: None
    """
    pass    


def set_3d_particles_active(emitter_id: int, active: Union[bool, int]) -> None:
    """
    Sets whether the emitted particles are updated every frame.

    Set to True to update particles as normal, False to pause them.

    Particles will continue to be visible when paused. To hide particles use `set_3d_particles_visible()`.

    :param int emitter_id: The ID of the emitter to modify.
    :param Union[bool, int] active: True to update normally, False to pause.
    :rtype: None
    """
    pass    


def set_3d_particles_color_interpolation(emitter_id: int, mode: int) -> None:
    """
    Sets the interpolation mode for color changes.

    Colors can be set at certain points in a particle's life using `add_3d_particles_color_key_frame()` and the particle
    will either blend between these colors (smooth interpolation) or quickly change when it reaches the next color
    change (no interpolation).

    :param int emitter_id: The ID of the emitter to modify.
    :param int mode: 1 (INTERPOLATE_SMOOTH)=smooth interpolation, 0 (INTERPOLATE_NONE)=no interpolation.
    :rtype: None
    """
    pass    


def set_3d_particles_direction(emitter_id: int, vx: Union[float, int], vy: Union[float, int],
                               vz: Union[float, int], roll: Union[float, int]) -> None:
    """
    Sets the initial direction of new particles when they emerge from the emitter.

    This can be used along with the `set_3d_particles_direction_range()` command to set the range of variation from this
    initial direction that new particles can choose. This also sets the initial speed of the particles by taking the
    length of the vector as units per second. For example if the initial direction is vx=10, vy=-15, vz=0 particles will
    begin by moving in the X direction at a rate of 10 units per second and in the Y direction at a rate of 15 units per
    second and will continue this rate of motion for their entire life unless influenced by forces added with
    `add_3d_particles_force()`.

    :param int emitter_id: The ID of the emitter to modify.
    :param Union[float, int] vx: The x direction that particles will move initially.
    :param Union[float, int] vy: The y direction that particles will move initially.
    :param Union[float, int] vz: The z direction that particles will move initially.
    :param Union[float, int] roll: The angle to turn the emitter as it is facing in the given direction.
    :rtype: None
    """
    pass    


def set_3d_particles_direction_range(emitter_id: int, angle1: Union[float, int],
                                     angle2: Union[float, int]) -> None:
    """
    Sets the range of direction in degrees that a particle can choose when it first starts.

    This takes the base direction set with `set_3d_particles_direction()` and adjusts it by a random amount between 0
    and `angle1` / 2 degrees in one direction and `angle2` / 2 degrees in the perpendicular direction. For example an
    `angle1` of 0 and an `angle2` of 0 would mean that all new particles follow exactly the direction specified earlier.
    An `angle1` of 360 and an `angle2` of 0 would mean that particles could appear travelling in any direction in a flat
    circle, whilst an `angle1` of 360 and an `angle2` of 180 would mean that particles would travel in any direction in
    a sphere. The angles form a pyramid aligned with the particle emitter direction specified earlier. `angle1` must be
    between 0 and 360, `angle2` must be between 0 and 180.

    :param int emitter_id: The ID of the emitter to modify.
    :param Union[float, int] angle1: The range of variation a particle can choose from the emitter direction.
    :param Union[float, int] angle2: The perpendicular range of variation a particle can choose from the emitter
        direction.
    :rtype: None
    """
    pass    


def set_3d_particles_frequency(emitter_id: int, freq: Union[float, int]) -> None:
    """
    Sets the frequency of new particle generation.

    The freq value states how many particles should be produced per second, this is independent of frame rate. This is
    one of the two values that affects the number of particles generated, the other being `set_particles_life()`. The
    maximum number of particles that can be on screen at any one time is freq*life, with life being the number of
    seconds a particle lives before it disappears.

    :param int emitter_id: The ID of the emitter to modify.
    :param Union[float, int] freq: The rate of new particle production in particles per second.
    :rtype: None
    """
    pass    


def set_3d_particles_image(emitter_id: int, image_id: int) -> None:
    """
    Sets the image to use for each particle.

    :param int emitter_id: The ID of the emitter to modify.
    :param int image_id: The ID of an image to use for emitted particles.
    :rtype: None
    """
    pass    


def set_3d_particles_life(emitter_id: int, time: Union[float, int]) -> None:
    """
    Sets the life of particles in seconds once they have been emitted.

    After particles have been alive for the given number of seconds they will disappear. This is one of the two values
    that affects the number of particles generated, the other being `set_3d_particles_frequency()`. The maximum number
    of particles that can be on screen at any one time is freq*life, with freq being the number of particles emitted per
    second. This value is independent of frame rate.

    :param int emitter_id: The ID of the emitter to modify.
    :param Union[float, int] time: The time in seconds that a particle is visible.
    :rtype: None
    """
    pass    


def set_3d_particles_max(emitter_id: int, maximum: int) -> None:
    """
    Sets the maximum number of particles that will be emitted.

    If this value is equal to -1 then the number is infinite. The emitter will keep a count of the total number of
    particles it emits and stop when the limit is reached. To check if the emitter has reached its limit use
    `get_3d_particles_max_reached()`. To reset the count and make it start emitting again use
    `reset_3d_particle_count()`.

    :param int emitter_id: The ID of the emitter to modify.
    :param int maximum: The maximum number of particles to emit.
    :rtype: None
    """
    pass    


def set_3d_particles_position(emitter_id: int, x: Union[float, int], y: Union[float, int],
                              z: Union[float, int]) -> None:
    """
    Sets the position of the 3D particle emitter.

    This is the position that new particles will emerge from and does not affect particles that are already visible.

    :param int emitter_id: The ID of the emitter to modify.
    :param Union[float, int] x: The new x coordinate for the emitter in world coordinates.
    :param Union[float, int] y: The new y coordinate for the emitter in world coordinates.
    :param Union[float, int] z: The new z coordinate for the emitter in world coordinates.
    :rtype: None
    """
    pass    


def set_3d_particles_size(emitter_id: int, size: Union[float, int]) -> None:
    """
    Sets the size of all particles in world coordinates.

    Setting a large number of particles to a large size will perform poorly on mobile devices that have a low fill rate
    (number of pixels it can draw per second).

    :param int emitter_id: The ID of the emitter to modify.
    :param Union[float, int] size: Size of the particles.
    :rtype: None
    """
    pass    


def set_3d_particles_start_zone(emitter_id: int, x1: Union[float, int], y1: Union[float, int],
                                z1: Union[float, int], x2: Union[float, int], y2: Union[float, int],
                                z2: Union[float, int]) -> None:
    """
    Sets the area around the emitter where new particles may appear.

    The values are relative to the emitter position, for example a zone of 0,0,0,0 would mean that all particles start
    on the emitter position point. A zone of -10 in x and +10 x, with y and z being 0 (-10,0,0,10,0,0) would create a
    line centered on the emitter position that particles would randomly appear along. A box zone where x, y, and z are
    non-zero would mean that particles could start at any point inside the box.

    :param int emitter_id: The ID of the emitter to modify.
    :param Union[float, int] x1: The x coordinate of the top left corner of the start zone.
    :param Union[float, int] y1: The y coordinate of the top left corner of the start zone.
    :param Union[float, int] z1: The z coordinate of the top left corner of the start zone.
    :param Union[float, int] x2: The x coordinate of the bottom right corner of the start zone.
    :param Union[float, int] y2: The y coordinate of the bottom right corner of the start zone.
    :param Union[float, int] z2: The z coordinate of the bottom right corner of the start zone.
    :rtype: None
    """
    pass    


def set_3d_particles_transparency(emitter_id: int, mode: int) -> None:
    """
    Set the particle transparency to a particular setting, with a choice of no transparency, alpha transparency, and
    additive blending.

    By default particles are created with alpha transparency.

    :param int emitter_id: The ID of the particle emitter to modify.
    :param int mode: The transparency mode for these particles, 0 (TRANSPARENCY_NONE)=off, 1 (TRANSPARENCY_ALPHA)=alpha
        transparency, 2 (TRANSPARENCY_ADDITIVE)=additive blending.
    :rtype: None
    """
    pass    


def set_3d_particles_velocity_range(emitter_id: int, v1: Union[float, int], v2: Union[float,
                                    int]) -> None:
    """
    Sets a minimum and maximum multiplier that will affect particles being emitted.

    This can be used to ensure that there will be some variation in velocity when particles are emitted.

    :param int emitter_id: The ID of the emitter to modify.
    :param Union[float, int] v1: The minimum velocity multiplier.
    :param Union[float, int] v2: The maximum velocity multiplier.
    :rtype: None
    """
    pass    


def set_3d_particles_visible(emitter_id: int, visible: Union[bool, int]) -> None:
    """
    Sets whether the emitted particles are drawn.

    Set to True to show particles, False to hide them. Particles will still update whilst hidden, you can stop particles
    updating with `set_3d_particles_active()`.

    :param int emitter_id: The ID of the emitter to modify.
    :param Union[bool, int] visible: True to show, False to hide.
    :rtype: None
    """
    pass    


def update_3d_particles(emitter_id: int, time: Union[float, int]) -> None:
    """
    Immediately advances the particle emitter by the given amount of time.

    If you want to advance a high frequency emitter by a large time period such as 1 second you should call this command
    multiple times with a small time value such as 0.02 so that it creates new particles in batches and spreads them out
    evenly. Calling it once with a large time value of 1 second would create a huge batch of particles all at once and
    move them together as a blob instead of spreading them out.

    :param int emitter_id: The ID of the emitter to check.
    :param Union[float, int] time: The time in seconds to advance the emitter.
    :rtype: None
    """
    pass    


def add_3d_physics_ragdoll_bone(start_bone: int, end_bone: int, diameter: Union[float, int],
                                collision_group: int, collision_mask: int) -> int:
    """
    Creates a ragdoll bone capsule between the objects start and end bone location.

    Returns ragdoll bone ID. If this command fails to create a bone it will return a -1.

    :param int start_bone: object's start bone ID.
    :param int end_bone: object's end bone ID.
    :param Union[float, int] diameter: Size of the capsule that will be the ragdoll bone.
    :param int collision_group: Collision group that this Physics object belongs too.
    :param int collision_mask: Collision groups you want masked from collision.
    :rtype: int
    """
    pass    


def add_3d_physics_ragdoll_hinge_joint(ragdoll_bone1: int, ragdoll_bone2: int, object_bone: int,
                                       rotation_vector_id: int, minimum: Union[float, int],
                                       maximum: Union[float, int]) -> None:
    """
    Creates a physics hinge joint between ragdoll bone A and B at the location of the objects bone.

    :param int ragdoll_bone1: ID of the Ragdoll bone returned from `add_3d_physics_ragdoll_bone()`.
    :param int ragdoll_bone2: ID of the Ragdoll bone returned from `add_3d_physics_ragdoll_bone()`.
    :param int object_bone: ID of the bone in the object which will be the location of the ragdoll joint.
    :param int rotation_vector_id: ID of the vector with the rotation of the joint.
    :param Union[float, int] minimum: Float value in angular degrees.
    :param Union[float, int] maximum: Float value in angular degrees.
    :rtype: None
    """
    pass    


def add_3d_physics_ragdoll_twist_joint(ragdoll_bone1: int, ragdoll_bone2: int, object_bone: int,
                                       rotation_vector_id: int, limits_vector_id: int) -> None:
    """
    Creates a physics Cone Twist joint between ragdoll bone A and B at the location of the objects bone.

    :param int ragdoll_bone1: ID of the Ragdoll bone returned from `add_3d_physics_ragdoll_bone()`.
    :param int ragdoll_bone2: ID of the Ragdoll bone returned from `add_3d_physics_ragdoll_bone()`.
    :param int object_bone: ID of the bone in the object which will be the location of the ragdoll joint.
    :param int rotation_vector_id: ID of the vector with the rotation of the joint.
    :param int limits_vector_id: ID of the vector with the joint limits.
    :rtype: None
    """
    pass    


def add_object_shape_box(object_id: int, position_vector_id: int, rotation_vector_id: int,
                         size_vector_id: int) -> None:
    """
    Adds a box collision shape to a compound shape.

    First set the objects shape to a compound collision shape with `set_object_shape_compound()`.

    :param int object_id: Object ID.
    :param int position_vector_id: The vector ID of the vector with the world position for the center of the shape.
    :param int rotation_vector_id: The vector ID of the vector with the world rotation of the shape.
    :param int size_vector_id: The vector ID of the vector with the size of the shape.
    :rtype: None
    """
    pass    


def add_object_shape_capsule(object_id: int, position_vector_id: int, rotation_vector_id: int,
                             size_vector_id: int, axis: int) -> None:
    """
    Adds a capsule collision shape to a compound shape.

    First set the objects shape to a compound collision shape with `set_object_shape_compound()`.

    :param int object_id: Object ID.
    :param int position_vector_id: The vector ID of the vector with the world position for the center of the shape.
    :param int rotation_vector_id: The vector ID of the vector with the world rotation of the shape.
    :param int size_vector_id: The vector ID of the vector with the size of the shape.
    :param int axis: 0 (AXIS_X)= X axis, 1 (AXIS_Y)= Y axis, 2 (AXIS_Z)= Z axis.
    :rtype: None
    """
    pass    


def add_object_shape_cone(object_id: int, position_vector_id: int, rotation_vector_id: int,
                          size_vector_id: int, axis: int) -> None:
    """
    Adds a cone collision shape to a compound shape.

    First set the objects shape to a compound collision shape with `set_object_shape_compound()`.

    :param int object_id: Object ID.
    :param int position_vector_id: The vector ID of the vector with the world position for the center of the shape.
    :param int rotation_vector_id: The vector ID of the vector with the world rotation of the shape.
    :param int size_vector_id: The vector ID of the vector with the size of the shape.
    :param int axis: 0 (AXIS_X)= X axis, 1 (AXIS_Y)= Y axis, 2 (AXIS_Z)= Z axis.
    :rtype: None
    """
    pass    


def add_object_shape_cylinder(object_id: int, position_vector_id: int, rotation_vector_id: int,
                              size_vector_id: int, axis: int) -> None:
    """
    Adds a cylinder collision shape to a compound shape.

    First set the objects shape to a compound collision shape with `set_object_shape_compound()`.

    :param int object_id: Object ID.
    :param int position_vector_id: The vector ID of the vector with the world position for the center of the shape.
    :param int rotation_vector_id: The vector ID of the vector with the world rotation of the shape.
    :param int size_vector_id: The vector ID of the vector with the size of the shape.
    :param int axis: 0 (AXIS_X)= X axis, 1 (AXIS_Y)= Y axis, 2 (AXIS_Z)= Z axis.
    :rtype: None
    """
    pass    


def add_object_shape_sphere(object_id: int, position_vector_id: int, diameter: Union[float,
                            int]) -> None:
    """
    Adds a sphere collision shape to a compound shape.

    First set the objects shape to a compound collision shape with `set_object_shape_compound()`.

    :param int object_id: Object ID.
    :param int position_vector_id: The vector ID of the vector with the world position for the center of the shape.
    :param Union[float, int] diameter: Size of sphere shape.
    :rtype: None
    """
    pass    


def assign_to_3d_physics_ragdoll_bone_object_bone(ragdoll_bone: int, object_bone: int) -> None:
    """
    Assigns the objects bone to the ragdoll bone.

    The objects bones that are in between the bones that are used to create a ragdoll bone.

    :param int ragdoll_bone: ID of ragdoll bone.
    :param int object_bone: ID of objects bone to be controlled by the ragdoll bone.
    :rtype: None
    """
    pass    


def create_3d_physics_6dof_joint(object_id1: int, object_id2: int, position_vector_id: int,
                                 rotation_vector_id: int) -> int:
    """
    Creates a 6 degrees of freedom joint between object a and b.

    Returns a joint ID.

    :param int object_id1: First object ID.
    :param int object_id2: Second object ID.
    :param int position_vector_id: Vector ID.
    :param int rotation_vector_id: Vector ID.
    :rtype: int
    """
    pass    


def create_3d_physics_character_controller(object_id: int, axis: int, offset_vector_id: int,
                                           orientation_vector_id: int, crouch_scale: Union[float,
                                           int]) -> None:
    """
    Creates a 3D physics Character Controller for the model.

    Character controller can be created on the X, Y, or Z axis. For example a standing character would be on the Y axis.
    A lying down character could be on the X or Z. If the model has an offset from origin the `offset_vector_id` is
    needed to line up the character controller with the object. If the object does not face down the positive Z axis use
    the `orientation_vector_id` to adjust. Crouch scale adjusts the crouch capsule size to fit the height of your
    crouched model.

    :param int object_id: Object ID.
    :param int axis: 0 (AXIS_X)= X axis, 1 (AXIS_Y)= Y axis, 2 (AXIS_Z)= Z axis.
    :param int offset_vector_id: This vector is half the amount that the model is offset from origin.
    :param int orientation_vector_id: This vector is used to line up the rotation of your model with the character
        controller.
    :param Union[float, int] crouch_scale: Percentage amount to scale the crouched capsule to fit crouched model.
    :rtype: None
    """
    pass    


def create_3d_physics_cone_twist_joint(object_id1: int, object_id2: int, position_vector_id: int,
                                       rotation_vector_id: int, disable_collisions: Union[bool,
                                       int]) -> int:
    """
    Creates a Cone Twist joint between object a and b.

    The `rotation_vector_id` parameter should be an axis in the form (0,1,0) for vertical, (1,0,0) for horizontal along
    the X axis, (0,0,1) for horizontal along the Z axis, or any combination of these. The rotation vector does not need
    to be normalized. The joint will spin along the given axis and rotate freely within a cone along this axis. The cone
    limits can be specified with `set_3d_physics_joint_cone_twist_limits()`. Returns a joint ID.

    :param int object_id1: First object ID.
    :param int object_id2: Second object ID.
    :param int position_vector_id: Vector ID.
    :param int rotation_vector_id: Vector ID.
    :param Union[bool, int] disable_collisions: True = collisions will be disabled between linked objects, False
        collisions will be enabled between linked objects.
    :rtype: int
    """
    pass    


def create_3d_physics_dynamic_body(object_id: int) -> None:
    """
    Deletes the existing physics body and creates a dynamic body for the object with a box collision shape and a mass of
    5.0 Based on the objects size.

    :param int object_id: Object ID.
    :rtype: None
    """
    pass    


def create_3d_physics_fixed_joint(object_id1: int, object_id2: int, position_vector_id: int) -> int:
    """
    Creates a Fixed joint between object a and b.

    Returns a joint ID.

    :param int object_id1: First object ID.
    :param int object_id2: Second object ID.
    :param int position_vector_id: Vector ID.
    :rtype: int
    """
    pass    


def create_3d_physics_hinge_joint(object_id1: int, object_id2: int, position_vector_id: int,
                                  rotation_vector_id: int, disable_collisions: Union[bool,
                                  int]) -> int:
    """
    Creates a hinge joint between object a and b.

    The `rotation_vector_id` parameter should be an axis in the form (0,1,0) for vertical, (1,0,0) for horizontal along
    the X axis, (0,0,1) for horizontal along the Z axis, or any combination of these. The rotation vector does not need
    to be normalized. Returns a joint ID.

    :param int object_id1: First object ID.
    :param int object_id2: Second object ID.
    :param int position_vector_id: Vector ID.
    :param int rotation_vector_id: Vector ID.
    :param Union[bool, int] disable_collisions: True = collisions will be disabled between linked objects, False
        collisions will be enabled between linked objects.
    :rtype: int
    """
    pass    


def create_3d_physics_kinematic_body(object_id: int) -> None:
    """
    Deletes the existing physics body and creates a box collision shape and kinematic physics body for the object.

    A kinematic body can be moved by using the agk commands for position and rotation of objects. Note: A kinematic body
    can only interact with a dynamic body and will pass through a static body.

    :param int object_id: Object ID.
    :rtype: None
    """
    pass    


def create_3d_physics_pick_joint(object_id: int, position_vector_id: int) -> int:
    """
    Returns Joint ID.

    :param int object_id: Object ID.
    :param int position_vector_id: ID of the position Vector.
    :rtype: int
    """
    pass    


def create_3d_physics_ragdoll(object_id: int, weight: Union[float, int]) -> None:
    """
    Starts the creation of a Physics ragdoll for the object.

    You must add at least one bone to the ragdoll before you call `finalize_3d_physics_ragdoll()`. The models bones must
    have a zero rotation in the default position/first frame of the animation.

    :param int object_id: Object ID.
    :param Union[float, int] weight: Total weight in lbs. This weight gets divided up among the ragdoll bones based on
        volume of the bones.
    :rtype: None
    """
    pass    


def create_3d_physics_ray() -> int:
    """
    Returns the ID of the ray created.

    :rtype: int
    """
    pass    


def create_3d_physics_slider_joint(object_id1: int, object_id2: int, position_vector_id: int,
                                   rotation_vector_id: int) -> int:
    """
    Creates a Slider joint between object a and b.

    The `rotation_vector_id` parameter should be an axis in the form (0,1,0) for vertical, (1,0,0) for horizontal along
    the X axis, (0,0,1) for horizontal along the Z axis, or any combination of these. The rotation vector does not need
    to be normalized. Returns a joint ID.

    :param int object_id1: First object ID.
    :param int object_id2: Second object ID.
    :param int position_vector_id: Vector ID.
    :param int rotation_vector_id: Vector ID.
    :rtype: int
    """
    pass    


def create_3d_physics_static_body(object_id: int) -> None:
    """
    Deletes the existing physics body and creates a Static triangle mesh collision shape and physics body for the
    object.

    :param int object_id: Object ID.
    :rtype: None
    """
    pass    


def create_3d_physics_static_plane(x: Union[float, int], y: Union[float, int], z: Union[float, int],
                                   offset: Union[float, int]) -> int:
    """
    Creates a static plane.

    Returns a static Plane ID.

    :param Union[float, int] x: X value of the normal vector.
    :param Union[float, int] y: Y value of the normal vector.
    :param Union[float, int] z: Z value of the  normal vector.
    :param Union[float, int] offset: How much the plane will be offset from its world position.
    :rtype: int
    """
    pass    


def create_3d_physics_world(scale: Union[float, int] = 40.0) -> None:
    """
    You must create the the Physics world before calling any other physics commands.

    Calling `create_3d_physics_world()` creates the physics world using the default scale factor of 40. This function
    will create the physics world with a different scale factor. The scale is not the size of the world, it is the
    factor by which all the data passed in is scaled down by to convert it to the Bullet Physics scale for the physics
    calculations. Then the data from Bullet is scaled up before it is passed to the AGK 3D world. The default scale
    factor will be correct if your average character size is 72 AGK units tall. Then the default gravity of -10.0 meters
    per second on the Y axis will give the correct visual result. The Bullet Physics solver has a minimum size for
    objects. Objects below this size will cause instability with the solver. At the default scale factor of 40 the
    smallest dimension that the solver can handle is about 3.5 AGK units. To calculate the scale factor first determine
    your character's height in meters, a character of 72 units tall would be 1.8288 meters (or 6ft). Then divide the
    character's height in units by the characters height in meters, for this example the scale factor would be (72 /
    1.8) = 40.

    :param Union[float, int] scale: The default scale factor is 40.
    :rtype: None
    """
    pass    


def crouch_3d_physics_character_controller(object_id: int) -> None:
    """
    Crouches the controller.

    :param int object_id: Object ID.
    :rtype: None
    """
    pass    


def debug_3d_physics_character_controller(object_id: int, enabled: Union[bool, int]) -> None:
    """
    Shows the Capsule objects the represent the controller.

    :param int object_id: Object ID.
    :param Union[bool, int] enabled: True to show the debug character controller.
    :rtype: None
    """
    pass    


def debug_3d_physics_world() -> None:
    """
    Call in loop before step physics.

    Draws the debug overlay of the 3D physics world. Note: This command does not currently work needs the ability to
    draw wireframe in AGK.

    :rtype: None
    """
    pass    


def delete_3d_physics_body(object_id: int) -> None:
    """
    Removes the physics body from the world and deletes it.

    :param int object_id: Object ID.
    :rtype: None
    """
    pass    


def delete_3d_physics_character_controller(object_id: int) -> None:
    """
    Deletes the controller for the object.

    :param int object_id: Object ID.
    :rtype: None
    """
    pass    


def delete_3d_physics_joint(joint_id: int) -> None:
    """
    Deletes the physics joint.

    :param int joint_id: ID of joint.
    :rtype: None
    """
    pass    


def delete_3d_physics_pick_joint(joint_id: int) -> None:
    """
    Deletes pick joint.

    :param int joint_id: ID of Joint.
    :rtype: None
    """
    pass    


def delete_3d_physics_ragdoll(object_id: int) -> None:
    """
    Deletes the Ragdoll for the object.

    :param int object_id: Object ID.
    :rtype: None
    """
    pass    


def delete_3d_physics_ray(ray_id: int) -> None:
    """
    Deletes a physics ray and all associated data.

    :param int ray_id: ID of the ray to delete.
    :rtype: None
    """
    pass    


def delete_3d_physics_static_plane(plane_id: int) -> None:
    """
    Deletes the static plane.

    :param int plane_id: Static plane ID.
    :rtype: None
    """
    pass    


def delete_3d_physics_world() -> None:
    """
    Deletes the entire 3D physics world.

    :rtype: None
    """
    pass    


def finalize_3d_physics_ragdoll() -> None:
    """
    Finishes the construction of the ragdoll.

    Call this command when you have added all the bones and joints for your ragdoll. Make sure you call
    `create_3d_physics_ragdoll()` first before calling this command.

    :rtype: None
    """
    pass    


def get_3d_physics_active_objects() -> int:
    """
    Returns the total number of active objects in the physics world.

    :rtype: int
    """
    pass    


def get_3d_physics_character_controller_exists(object_id: int) -> bool:
    """
    Returns a True if the object has a controller otherwise False.

    :param int object_id: Object ID.
    :rtype: bool
    """
    pass    


def get_3d_physics_character_controller_gravity(object_id: int) -> float:
    """
    Returns the controller gravity.

    :param int object_id: Object ID.
    :rtype: float
    """
    pass    


def get_3d_physics_character_controller_max_slope(object_id: int) -> float:
    """
    Returns the maximum slope in degrees.

    :param int object_id: Object ID.
    :rtype: float
    """
    pass    


def get_3d_physics_joint_enabled(joint_id: int) -> bool:
    """
    Returns True when the joint is enabled; otherwise, False.

    :param int joint_id: ID of joint.
    :rtype: bool
    """
    pass    


def get_3d_physics_joint_position_vector(joint_id: int) -> int:
    """
    Returns the vector ID.

    :param int joint_id: ID of a Joint.
    :rtype: int
    """
    pass    


def get_3d_physics_joint_rotation_vector(joint_id: int) -> int:
    """
    Returns the joints X rotation angle in degrees.

    :param int joint_id: The ID of the joint.
    :rtype: int
    """
    pass    


def get_3d_physics_ragdoll_exist(object_id: int) -> int:
    """
    Returns true if a ragdoll exists for the object.

    :param int object_id: Object ID.
    :rtype: int
    """
    pass    


def get_3d_physics_ragdoll_from_bone_object(ragdoll_bone: int) -> int:
    """
    Returns the object ID of the Model with the ragdoll which contains the ragdoll bone object passed in.

    :param int ragdoll_bone: Object ID of a ragdoll bone capsule.
    :rtype: int
    """
    pass    


def get_3d_physics_ray_cast_closest_contact_position(ray_id: int, out_vector_id: int) -> bool:
    """
    Returns true if there is a closest contact vector and fills the vector `out_vector_id`. First create a vector with
    `create_vector3()` then pass in the ID. The vector you have created and passed in will be filled with the results.

    :param int ray_id: ID of the ray.
    :param int out_vector_id: ID of the vector that will be filled with the position.
    :rtype: bool
    """
    pass    


def get_3d_physics_ray_cast_closest_object_hit(ray_id: int) -> int:
    """
    Return the Closest Object hit by the ray.

    :param int ray_id: ID of the ray.
    :rtype: int
    """
    pass    


def get_3d_physics_ray_cast_contact_position(ray_id: int, hit_index: int,
                                             out_vector_id: int) -> bool:
    """
    Returns true if there is a contact vector and fills the vector `out_vector_id`. First create a vector with
    `create_vector3()` then pass in the ID. The vector you have created and passed in will be filled with the results.

    :param int ray_id: ID of the ray.
    :param int hit_index: Value returned by `get_3d_physics_ray_cast_fraction()` command.
    :param int out_vector_id: ID of the vector that will be filled with the position.
    :rtype: bool
    """
    pass    


def get_3d_physics_ray_cast_fraction(ray_id: int) -> float:
    """
    Returns the distance along the ray until collision where 1.0 = full length, 0.0 = beginning.

    :param int ray_id: ID of the ray.
    :rtype: float
    """
    pass    


def get_3d_physics_ray_cast_normal_vector(ray_id: int, out_vector_id: int) -> None:
    """
    Fills the vector passed in with the Normals values from the ray.

    First create a physics ray then cast the ray before calling `get_3d_physics_ray_cast_normal_vector()`.

    :param int ray_id: The ID of the ray which is returned by calling `create_3d_physics_ray()`.
    :param int out_vector_id: The ID of a vector. Vector ID is the return value from `create_vector3()` command.
    :rtype: None
    """
    pass    


def get_3d_physics_ray_cast_num_hits(ray_id: int) -> int:
    """
    Returns the total number of hits the ray has along its length.

    :param int ray_id: The ID of the ray which is returned by calling `create_3d_physics_ray()`.
    :rtype: int
    """
    pass    


def get_3d_physics_ray_cast_object_hit(ray_id: int, hit_index: int) -> int:
    """
    Return the ID of the Object hit by the ray at the index.

    :param int ray_id: ID of the ray.
    :param int hit_index: Value returned by `get_3d_physics_ray_cast_fraction()` command.
    :rtype: int
    """
    pass    


def get_3d_physics_total_joints() -> int:
    """
    Returns the total number of joints in the physics world.

    :rtype: int
    """
    pass    


def get_3d_physics_total_objects() -> int:
    """
    Returns the total number of physics objects in the world.

    :rtype: int
    """
    pass    


def get_object_3d_physics_angular_damp(object_id: int) -> float:
    """
    Returns the Angular Damping value.

    :param int object_id: Object ID.
    :rtype: float
    """
    pass    


def get_object_3d_physics_angular_sleeping_threshold(object_id: int) -> float:
    """
    Returns the angular Sleeping threshold for the Physics Object.

    :param int object_id: Object ID.
    :rtype: float
    """
    pass    


def get_object_3d_physics_angular_velocity_x(object_id: int) -> float:
    """
    Return the X component of the angular velocity vector.

    :param int object_id: Object ID.
    :rtype: float
    """
    pass    


def get_object_3d_physics_angular_velocity_y(object_id: int) -> float:
    """
    Return the Y component of the angular velocity vector.

    :param int object_id: Object ID.
    :rtype: float
    """
    pass    


def get_object_3d_physics_angular_velocity_z(object_id: int) -> float:
    """
    Return the Z component of the angular velocity vector.

    :param int object_id: Object ID.
    :rtype: float
    """
    pass    


def get_object_3d_physics_contact_object_b() -> int:
    """
    Returns the object ID of the second object in the contact.

    :rtype: int
    """
    pass    


def get_object_3d_physics_contact_vector(out_vector_id: int) -> int:
    """
    Returns true if there is a contact vector and fills the vector `out_vector_id`. First create a vector with
    `create_vector3()` then pass in the ID. The vector you have created and passed in will be filled with the results.

    :param int out_vector_id: The ID of the vector to be filled with the results.
    :rtype: int
    """
    pass    


def get_object_3d_physics_contact_x() -> float:
    """
    Returns X position of contact.

    :rtype: float
    """
    pass    


def get_object_3d_physics_contact_y() -> float:
    """
    Returns Y position of contact.

    :rtype: float
    """
    pass    


def get_object_3d_physics_contact_z() -> float:
    """
    Returns Z position of contact.

    :rtype: float
    """
    pass    


def get_object_3d_physics_first_contact(object_id: int) -> bool:
    """
    Returns true if object has had a contact in the physics step.

    :param int object_id: Object ID.
    :rtype: bool
    """
    pass    


def get_object_3d_physics_friction(object_id: int) -> float:
    """
    Returns the friction for the physics object.

    :param int object_id: Object ID.
    :rtype: float
    """
    pass    


def get_object_3d_physics_group(object_id: int) -> int:
    """
    Returns the objects collision group.

    By default all physics objects are in one group and are not masked. If you use collision groups and masks you must
    use them for all physics objects.

    :param int object_id: Object ID.
    :rtype: int
    """
    pass    


def get_object_3d_physics_linear_damp(object_id: int) -> float:
    """
    Return the linear Damping value.

    :param int object_id: Object ID.
    :rtype: float
    """
    pass    


def get_object_3d_physics_linear_sleeping_threshold(object_id: int) -> float:
    """
    Returns the linear Sleeping threshold for the Physics Object.

    :param int object_id: Object ID.
    :rtype: float
    """
    pass    


def get_object_3d_physics_linear_velocity_x(object_id: int) -> float:
    """
    Returns the X component of the Linear Velocity vector.

    :param int object_id: Object ID.
    :rtype: float
    """
    pass    


def get_object_3d_physics_linear_velocity_y(object_id: int) -> float:
    """
    Returns the X component of the Linear Velocity vector.

    :param int object_id: Object ID.
    :rtype: float
    """
    pass    


def get_object_3d_physics_linear_velocity_z(object_id: int) -> float:
    """
    Returns the X component of the Linear Velocity vector.

    :param int object_id: Object ID.
    :rtype: float
    """
    pass    


def get_object_3d_physics_mask(object_id: int) -> int:
    """
    Returns the objects collision mask.

    By default all physics objects are in one group and are not masked. If you use collision groups and masks you must
    use them for all physics objects.

    :param int object_id: Object ID.
    :rtype: int
    """
    pass    


def get_object_3d_physics_mass(object_id: int) -> float:
    """
    Returns the objects mass.

    :param int object_id: Object ID.
    :rtype: float
    """
    pass    


def get_object_3d_physics_max_linear_velocity(object_id: int) -> float:
    """
    Returns the max linear velocity for the physics object.

    :param int object_id: object ID
    :rtype: float
    """
    pass    


def get_object_3d_physics_next_contact() -> bool:
    """
    Returns true if there is another contact to report.

    :rtype: bool
    """
    pass    


def get_object_3d_physics_restitution(object_id: int) -> float:
    """
    Gets the current restitution value for the physics object.

    :param int object_id: Object ID.
    :rtype: float
    """
    pass    


def get_object_3d_physics_rolling_friction(object_id: int) -> float:
    """
    Returns the rolling friction for the physics object.

    :param int object_id: Object ID.
    :rtype: float
    """
    pass    


def get_objects_3d_physics_contact_position_vector(object_id1: int, object_id2: int,
                                                   out_vector_id: int) -> bool:
    """
    Fills `out_vector_id` with contact position. Returns false if no contact. First create a vector with
    `create_vector3()` then pass in the ID. The vector you have created and passed in will be filled with the results.

    :param int object_id1: First object ID.
    :param int object_id2: Second object ID.
    :param int out_vector_id: ID of the position vector to be filled. Create this vector first.
    :rtype: bool
    """
    pass    


def is_3d_physics_ragdoll_static(object_id: int) -> bool:
    """
    Returns True if the Ragdoll is static.

    :param int object_id: Object ID.
    :rtype: bool
    """
    pass    


def jump_3d_physics_character_controller(object_id: int) -> None:
    """
    Moves the controller up to the jump height.

    :param int object_id: Object ID.
    :rtype: None
    """
    pass    


def load_object_shape(object_id: int, filename: str) -> bool:
    """
    loads a collision shape from a .bcs (Bullet Collision Shape) file and sets it to the object.

    Returns True if succeeded.

    :param int object_id: Object ID.
    :param str filename: File name.
    :rtype: bool
    """
    pass    


def move_3d_physics_character_controller(object_id: int, direction: int, velocity: Union[float,
                                         int]) -> None:
    """
    Moves the Controller.

    :param int object_id: Object ID.
    :param int direction: 0 (CONTROLLER_MOVE_STOP)= stop, 1 (CONTROLLER_MOVE_FORWARD)= forward, 2
        (CONTROLLER_MOVE_BACKWARD)= backward, 3 (CONTROLLER_MOVE_STRAFE_LEFT)= strafe left, 4
        (CONTROLLER_MOVE_STRAFE_RIGHT)= strafe right.
    :param Union[float, int] velocity: Travel speed.
    :rtype: None
    """
    pass    


def move_3d_physics_character_controller_xz(object_id: int, x: Union[float, int], z: Union[float,
                                            int], velocity: Union[float, int]) -> None:
    """
    Moves the Controller.

    :param int object_id: Object ID.
    :param Union[float, int] x: The amount to move in the x direction, this will be normalised with the z direction
    :param Union[float, int] z: The amount to move in the z direction, this will be normalised with the x direction
    :param Union[float, int] velocity: Travel speed.
    :rtype: None
    """
    pass    


def ray_3d_physics_exist(ray_id: int) -> int:
    """
    Return True if the ray exists.

    Returns False if it does not.

    :param int ray_id: ID of the ray.
    :rtype: int
    """
    pass    


def ray_cast_3d_physics(ray_id: int, from_vector_id: int, to_vector_id: int,
                        all_or_closest: int) -> None:
    """
    Cast a ray.

    :param int ray_id: ID of the ray.
    :param int from_vector_id: ID of the starting point vector. Create a vector with the `create_vector3()` command.
    :param int to_vector_id: ID of the destination vector.
    :param int all_or_closest: 1 (RAY_CAST_ALL)= all contacts, 0 (RAY_CAST_CLOSEST)= closest contact.
    :rtype: None
    """
    pass    


def ray_cast_3d_physics_object(object_id: int, ray_id: int, from_vector_id: int, to_vector_id: int,
                               all_or_closest: int) -> int:
    """
    Cast a ray and checks against the object.

    :param int object_id: ID of object to check against.
    :param int ray_id: ID of the ray.
    :param int from_vector_id: ID of the starting point vector. Create a vector with the `create_vector3()` command.
    :param int to_vector_id: ID of the destination vector.
    :param int all_or_closest: 1 (RAY_CAST_ALL)= all contacts, 0 (RAY_CAST_CLOSEST)= closest contact.
    :rtype: int
    """
    pass    


def reset_3d_physics_world() -> None:
    """
    This deletes the physics world and all the shapes, rigid bodies, joints, joint motors, ragdolls and character
    controllers.

    Then recreates an empty physics world with default scale and gravity. You will then need to recreate all the shapes,
    rigid bodies, joints, joint motors, ragdolls and character controllers that you require.

    :rtype: None
    """
    pass    


def rotate_3d_physics_character_controller(object_id: int, angle: Union[float, int]) -> None:
    """
    Rotates the controller.

    :param int object_id: Object ID.
    :param Union[float, int] angle: Amount in degrees.
    :rtype: None
    """
    pass    


def save_object_shape(object_id: int, filename: str) -> bool:
    """
    Saves the objects collision shape to a .bcs (Bullet Collision Shape) file.

    Returns True if succeeded.

    :param int object_id: Object ID.
    :param str filename: The name of the file as a string.
    :rtype: bool
    """
    pass    


def set_3d_physics_character_controller_fall_speed(object_id: int, speed: Union[float,
                                                   int]) -> None:
    """
    Sets the speed at which the controller will fall.

    :param int object_id: Object ID.
    :param Union[float, int] speed: Default value is 55.0 which is the terminal velocity of a sky diver in meters per
        second.
    :rtype: None
    """
    pass    


def set_3d_physics_character_controller_gravity(object_id: int, gravity: Union[float, int]) -> None:
    """
    Sets the gravity for the character controller.

    This gravity is not the same as the physics world gravity. and only affects the individual character controller.

    :param int object_id: Object ID.
    :param Union[float, int] gravity: Default value is (9.8 * 3).
    :rtype: None
    """
    pass    


def set_3d_physics_character_controller_jump_speed(object_id: int, speed: Union[float,
                                                   int]) -> None:
    """
    Set the speed at which the controller moves up when jump is called.

    :param int object_id: Object ID.
    :param Union[float, int] speed: Default is 10.0.
    :rtype: None
    """
    pass    


def set_3d_physics_character_controller_max_slope(object_id: int, angle: Union[float, int]) -> None:
    """
    set the max slope in angle degrees that a controller can climb.

    :param int object_id: Object ID.
    :param Union[float, int] angle: Default value is 45.0 degrees.
    :rtype: None
    """
    pass    


def set_3d_physics_character_controller_position(object_id: int, x: Union[float, int],
                                                 y: Union[float, int], z: Union[float,
                                                 int]) -> None:
    """
    Repositions the Controller to the new coordinates passed in.

    Do not position the controller inside another physics object.

    :param int object_id: Object ID.
    :param Union[float, int] x: The new X coordinate.
    :param Union[float, int] y: The new Y coordinate.
    :param Union[float, int] z: The new Z coordinate.
    :rtype: None
    """
    pass    


def set_3d_physics_character_controller_step_height(object_id: int, height: Union[float,
                                                    int]) -> None:
    """
    Sets the height that the controller can step up and over.

    :param int object_id: Object ID.
    :param Union[float, int] height: Step height in world values.
    :rtype: None
    """
    pass    


def set_3d_physics_gravity(vector_id: int) -> None:
    """
    Sets the gravity of the physics world, gravity is in meters per second.

    Gravity is set to (0.0, -10.0, 0.0) by default. You only need to call this command if you need to change from the
    default setting.

    :param int vector_id: The ID of the vector to use as gravity.
    :rtype: None
    """
    pass    


def set_3d_physics_gravity_xyz(x: Optional[Union[float, int]] = 0, y: Optional[Union[float,
                               int]] = 0, z: Optional[Union[float, int]] = 0) -> None:
    """
    Sets the gravity of the physics world, gravity is in meters per second.

    Gravity is set to (0.0, -10.0, 0.0) by default. You only need to call this command if you need to change from the
    default setting.

    :param Optional[Union[float, int]] x: The value of gravity on the X axis in meters per second.
    :param Optional[Union[float, int]] y: The value of gravity on the Y axis in meters per second.
    :param Optional[Union[float, int]] z: The value of gravity on the Z axis in meters per second.
    :rtype: None
    """
    pass    


def set_3d_physics_hinge_joint_max_motor_impulse(joint_id: int, max_impulse: Union[float,
                                                 int]) -> None:
    """
    Sets the maximum motor Impulse value for a hinge joint.

    Enable joint first with `set_3d_physics_hinge_joint_motor_is_enabled()`.

    :param int joint_id: ID of joint.
    :param Union[float, int] max_impulse: The maximum impulse value to be applied to the joint motor.
    :rtype: None
    """
    pass    


def set_3d_physics_hinge_joint_motor_is_enabled(joint_id: int, enabled: Union[bool, int]) -> None:
    """
    Enables a hinge joint motor.

    :param int joint_id: ID of joint.
    :param Union[bool, int] enabled: True to enable.
    :rtype: None
    """
    pass    


def set_3d_physics_hinge_joint_motor_velocity(joint_id: int, target_velocity: Union[float,
                                              int]) -> None:
    """
    Set the target velocity for a hinge joint.

    Must be called in the loop. Enable joint first with `set_3d_physics_hinge_joint_motor_is_enabled()`.

    :param int joint_id: ID of joint.
    :param Union[float, int] target_velocity: The target velocity to be used.
    :rtype: None
    """
    pass    


def set_3d_physics_joint_breaking_threshold(joint_id: int, threshold: Union[float, int]) -> None:
    """
    Sets the breaking threshold for the joint.

    :param int joint_id: ID of joint.
    :param Union[float, int] threshold: Breaking threshold value.
    :rtype: None
    """
    pass    


def set_3d_physics_joint_cone_twist_limits(joint_id: int, swing_span1: Union[float, int],
                                           swing_span2: Union[float, int], twist_span: Union[float,
                                           int]) -> None:
    """
    Sets the angular limits for a cone twist joint in degrees.

    To unlock a particular value set it to 360.

    :param int joint_id: ID of joint.
    :param Union[float, int] swing_span1: Angle in degrees.
    :param Union[float, int] swing_span2: Angle in degrees.
    :param Union[float, int] twist_span: Angle in degrees.
    :rtype: None
    """
    pass    


def set_3d_physics_joint_enabled(joint_id: int, enabled: Union[bool, int]) -> None:
    """
    Sets the joint to enabled.

    :param int joint_id: ID of joint.
    :param Union[bool, int] enabled: False will disable joint.
    :rtype: None
    """
    pass    


def set_3d_physics_joint_hinge_limits(joint_id: int, minimum: Union[float, int],
                                      maximum: Union[float, int]) -> None:
    """
    Sets the angular limits for a hinge joint in degrees.

    To unlock the joint set the lower limit greater than upper limit.

    :param int joint_id: ID of joint.
    :param Union[float, int] minimum: The minimum angle in degrees.
    :param Union[float, int] maximum: The maximum angle in degrees.
    :rtype: None
    """
    pass    


def set_3d_physics_joint_slider_angular_limits(joint_id: int, minimum: Union[float, int],
                                               maximum: Union[float, int]) -> None:
    """
    Sets the Angular limits for a slider joint.

    To unlock the joint set the lower limit greater than upper limit.

    :param int joint_id: ID of joint.
    :param Union[float, int] minimum: The lower limit in degrees.
    :param Union[float, int] maximum: The upper limit in degrees.
    :rtype: None
    """
    pass    


def set_3d_physics_joint_slider_linear_limits(joint_id: int, minimum: Union[float, int],
                                              maximum: Union[float, int]) -> None:
    """
    Sets the Linear limits for a slider joint.

    To unlock the joint set the lower limit greater than upper limit.

    :param int joint_id: ID of joint.
    :param Union[float, int] minimum: The lower limit.
    :param Union[float, int] maximum: The upper limit.
    :rtype: None
    """
    pass    


def set_3d_physics_ragdoll_bones_visible(object_id: int, visible: Union[bool, int]) -> None:
    """
    Shows the ragdoll bone objects and hides the object.

    :param int object_id: Object ID.
    :param Union[bool, int] visible: True to make visible, False to hide.
    :rtype: None
    """
    pass    


def set_3d_physics_ragdoll_damping(linear: Union[float, int], angular: Union[float, int]) -> None:
    """
    Sets the damping for the ragdoll being created.

    The default values should be good for most situations. Only call if you wish to change these values. Must be called
    before `finalize_3d_physics_ragdoll()`.

    :param Union[float, int] linear: Default value is 0.08.
    :param Union[float, int] angular: Default value is 0.95.
    :rtype: None
    """
    pass    


def set_3d_physics_ragdoll_deactivation(object_id: int, disabled: Union[bool, int]) -> None:
    """
    Keeps physics ragdoll active.

    Does not allow the automatic deactivation when ragdoll comes to rest.

    :param int object_id: Object ID.
    :param Union[bool, int] disabled: True to disable.
    :rtype: None
    """
    pass    


def set_3d_physics_ragdoll_deactivation_time(time: Union[float, int]) -> None:
    """
    Sets the deactivation time for the ragdoll being created.

    The default values should be good for most situations. Only call if you wish to change these values. Must be called
    before `finalize_3d_physics_ragdoll()`.

    :param Union[float, int] time: Default value is 0.8.
    :rtype: None
    """
    pass    


def set_3d_physics_ragdoll_sleeping_thresholds(linear: Union[float, int], angular: Union[float,
                                               int]) -> None:
    """
    Sets the sleeping thresholds for the ragdoll being created.

    The default values should be good for most situations. Only call if you wish to change these values. Must be called
    before `finalize_3d_physics_ragdoll()`.

    :param Union[float, int] linear: Default value is 1.8.
    :param Union[float, int] angular: Default value is 2.8.
    :rtype: None
    """
    pass    


def set_3d_physics_ragdoll_static(object_id: int, enabled: Union[bool, int]) -> None:
    """
    Sets the ragdoll static by changing the mass of all the ragdoll bones to zero.

    :param int object_id: Object ID.
    :param Union[bool, int] enabled: True to enable.
    :rtype: None
    """
    pass    


def set_3d_physics_slider_joint_max_linear_motor_force(joint_id: int, force: Union[float,
                                                       int]) -> None:
    """
    Sets the joints motor to the maximum linear force.

    :param int joint_id: ID of joint.
    :param Union[float, int] force: The maximum linear force to be applied to the joint motor.
    :rtype: None
    """
    pass    


def set_3d_physics_slider_joint_powered_linear_motor_is_enabled(joint_id: int, enabled: Union[bool,
                                                                int]) -> None:
    """
    Set the slider joints powered linear motor to enabled.

    :param int joint_id: ID of joint.
    :param Union[bool, int] enabled: True to enable.
    :rtype: None
    """
    pass    


def set_3d_physics_slider_joint_target_linear_motor_velocity(joint_id: int, velocity: Union[float,
                                                             int]) -> None:
    """
    Sets the target linear Motor Velocity for the physics slider joint.

    :param int joint_id: ID of joint.
    :param Union[float, int] velocity: The linear velocity to be applied to the joint motor.
    :rtype: None
    """
    pass    


def set_3d_physics_static_plane_position(plane_id: int, x: Union[float, int], y: Union[float, int],
                                         z: Union[float, int]) -> None:
    """
    Sets the position of the static plane.

    :param int plane_id: Static plane ID.
    :param Union[float, int] x: The world X position.
    :param Union[float, int] y: The world Y position.
    :param Union[float, int] z: The world Z position.
    :rtype: None
    """
    pass    


def set_3d_physics_static_plane_rotation(plane_id: int, x: Union[float, int], y: Union[float, int],
                                         z: Union[float, int]) -> None:
    """
    Sets the rotation of the static Plane.

    :param int plane_id: Static plane ID.
    :param Union[float, int] x: The world X angle of rotation.
    :param Union[float, int] y: The world Y angle of rotation.
    :param Union[float, int] z: The world Z angle of rotation.
    :rtype: None
    """
    pass    


def set_3d_physics_twist_joint_max_motor_impulse(joint_id: int, impulse: Union[float, int]) -> None:
    """
    Sets the max motor Impulse value for a Twist joint.

    Enable joint first with `set_3d_physics_twist_joint_motor_is_enabled()`.

    :param int joint_id: ID of joint.
    :param Union[float, int] impulse: The maximum impulse to be applied to the joint motor.
    :rtype: None
    """
    pass    


def set_3d_physics_twist_joint_motor_is_enabled(joint_id: int, enabled: Union[bool, int]) -> None:
    """
    Enables a twist joint motor.

    :param int joint_id: The joint ID
    :param Union[bool, int] enabled: True to enable.
    :rtype: None
    """
    pass    


def set_3d_physics_twist_joint_motor_rotation_target(joint_id: int,
                                                     rotation_vector_id: int) -> None:
    """
    Set the target velocity for a twist joint.

    Must be called in the loop. Enable joint first with `set_3d_physics_twist_joint_motor_is_enabled()`.

    :param int joint_id: ID of joint.
    :param int rotation_vector_id: The ID of a vector which has the rotation target for a twist joint motor.
    :rtype: None
    """
    pass    


def set_object_3d_physics_angular_velocity(object_id: int, vector_id: int,
                                           initial_speed: Union[float, int]) -> None:
    """
    Sets the angular velocity of the object. The angle vector is automatically normalized.

    :param int object_id: Object ID.
    :param int vector_id: ID of direction Vector.
    :param Union[float, int] initial_speed: The initial speed.
    :rtype: None
    """
    pass    


def set_object_3d_physics_angular_velocity_xyz(object_id: int, x: Union[float, int], y: Union[float,
                                               int], z: Union[float, int],
                                               initial_speed: Union[float, int]) -> None:
    """
    Sets the angular velocity of the object. The angle vector is automatically normalized.

    :param int object_id: Object ID.
    :param Union[float, int] x: The X component of the angle vector.
    :param Union[float, int] y: The Y component of the angle vector.
    :param Union[float, int] z: The Z component of the angle vector.
    :param Union[float, int] initial_speed: The initial speed.
    :rtype: None
    """
    pass    


def set_object_3d_physics_anisotropic_friction(object_id: int, mode: int) -> None:
    """
    This will set the type of anisotropic friction.

    :param int object_id: Object ID.
    :param int mode: 0 (ANISOTROPIC_FRICTION_DISABLED), 1 (ANISOTROPIC_FRICTION), or 2 (ANISOTROPIC_ROLLING_FRICTION).
    :rtype: None
    """
    pass    


def set_object_3d_physics_can_sleep(object_id: int, enabled: Union[bool, int]) -> None:
    """
    All dynamic objects are automatically put to sleep at rest.

    This will stop the dynamic object from being automatically put to sleep.

    :param int object_id: Object ID.
    :param Union[bool, int] enabled: True to enable.
    :rtype: None
    """
    pass    


def set_object_3d_physics_damping(object_id: int, linear: Union[float, int], angular: Union[float,
                                  int]) -> None:
    """
    Sets the linear and angular damping for the object.

    :param int object_id: Object ID.
    :param Union[float, int] linear: The amount of linear damping applied to the object.
    :param Union[float, int] angular: The amount of angular damping applied to the object.
    :rtype: None
    """
    pass    


def set_object_3d_physics_deactivation_time(object_id: int, time: Union[float, int]) -> None:
    """
    Sets the deactivation time for the physics object.

    This is the amount of time the physics object waits when it comes to rest before it becomes deactivated.

    :param int object_id: Object ID.
    :param Union[float, int] time: The amount of time before deactivating.
    :rtype: None
    """
    pass    


def set_object_3d_physics_friction(object_id: int, friction: Union[float, int]) -> None:
    """
    This will set the friction for dynamic and static objects.

    :param int object_id: Object ID.
    :param Union[float, int] friction: Friction value as a float.
    :rtype: None
    """
    pass    


def set_object_3d_physics_group_and_mask(object_id: int, group: int, mask: int) -> None:
    """
    Sets the objects collision group and mask.

    By default all physics objects are in one group and are not masked. If you use collision groups and masks you must
    use them for all physics objects in the world.

    :param int object_id: Object ID.
    :param int group: Collision group that this Physics object belongs too.
    :param int mask: Collision groups you want masked from collision.
    :rtype: None
    """
    pass    


def set_object_3d_physics_linear_velocity(object_id: int, vector_id: int,
                                          initial_speed: Union[float, int]) -> None:
    """
    Sets the linear velocity vector for the object.

    The direction vector is automatically normalized.

    :param int object_id: Object ID.
    :param int vector_id: ID of the direction vector.
    :param Union[float, int] initial_speed: The initial speed.
    :rtype: None
    """
    pass    


def set_object_3d_physics_linear_velocity_xyz(object_id: int, x: Union[float, int], y: Union[float,
                                              int], z: Union[float, int],
                                              initial_speed: Union[float, int]) -> None:
    """
    Sets the linear velocity vector for the object.

    The direction vector is automatically normalized.

    :param int object_id: Object ID.
    :param Union[float, int] x: The X component of the direction vector.
    :param Union[float, int] y: The Y component of the direction vector.
    :param Union[float, int] z: The Z component of the direction vector.
    :param Union[float, int] initial_speed: The initial speed.
    :rtype: None
    """
    pass    


def set_object_3d_physics_mass(object_id: int, mass: Union[float, int]) -> None:
    """
    Sets the mass of the object.

    :param int object_id: Object ID.
    :param Union[float, int] mass: Mass of the object.
    :rtype: None
    """
    pass    


def set_object_3d_physics_max_linear_velocity(object_id: int, maximum: Union[float, int]) -> None:
    """
    This will set the max linear velocity for the dynamic object.

    This will prevent objects from going too fast to be seen on screen.

    :param int object_id: Object ID.
    :param Union[float, int] maximum: Max speed an object can reach.
    :rtype: None
    """
    pass    


def set_object_3d_physics_restitution(object_id: int, friction: Union[float, int]) -> None:
    """
    Sets the restitution friction for the object.

    You can set the Restitution for dynamic and static objects.

    :param int object_id: Object ID.
    :param Union[float, int] friction: The amount of friction applied to the object.
    :rtype: None
    """
    pass    


def set_object_3d_physics_rolling_friction(object_id: int, friction: Union[float, int]) -> None:
    """
    This will set the rolling friction for static and dynamic objects.

    :param int object_id: Object ID.
    :param Union[float, int] friction: Rolling friction value as a float.
    :rtype: None
    """
    pass    


def set_object_3d_physics_sleeping_threshold(object_id: int, angular: Union[float, int],
                                             linear: Union[float, int]) -> None:
    """
    Sets the 3d physics sleeping thresholds for the object.

    :param int object_id: Object ID.
    :param Union[float, int] angular: Angular velocity.
    :param Union[float, int] linear: Linear velocity.
    :rtype: None
    """
    pass    


def set_object_shape_box(object_id: int, vector_id: Optional[int] = None) -> None:
    """
    Sets the collision shape to a box based on the size passed in.

    You must first create a physics body for the object or this command will fail.

    :param int object_id: Object ID.
    :param Optional[int] vector_id: ID of a dimension vector.
    :rtype: None
    """
    pass    


def set_object_shape_box_xyz(object_id: int, x: Union[float, int], y: Union[float, int],
                             z: Union[float, int]) -> None:
    """
    Sets the collision shape to a box based on the size passed in.

    You must first create a physics body for the object or this command will fail.

    :param int object_id: Object ID.
    :param Union[float, int] x: Dimension on the x axis.
    :param Union[float, int] y: Dimension on the Y axis.
    :param Union[float, int] z: Dimension on the Z axis.
    :rtype: None
    """
    pass    


def set_object_shape_capsule(object_id: int, axis: int, vector_id: Optional[int] = None) -> None:
    """
    Sets the collision shape to a capsule based on the size passed in.

    You must first create a physics body for the object or this command will fail.

    :param int object_id: Object ID.
    :param int axis: 0 (AXIS_X)=X axis, 1 (AXIS_Y)=Y axis, 2 (AXIS_Z)=Z axis orientation.
    :param Optional[int] vector_id: ID of the dimension vector.
    :rtype: None
    """
    pass    


def set_object_shape_capsule_xyz(object_id: int, axis: int, x: Union[float, int], y: Union[float,
                                 int], z: Union[float, int]) -> None:
    """
    Sets the collision shape to a capsule based on the size passed in.

    You must first create a physics body for the object or this command will fail.

    :param int object_id: Object ID.
    :param int axis: 0 (AXIS_X)=X axis, 1 (AXIS_Y)=Y axis, 2 (AXIS_Z)=Z axis orientation.
    :param Union[float, int] x: Dimension on the x axis.
    :param Union[float, int] y: Dimension on the Y axis.
    :param Union[float, int] z: Dimension on the Z axis.
    :rtype: None
    """
    pass    


def set_object_shape_compound(object_id: int) -> None:
    """
    Sets the objects collision shape to a compound shape ready to add more shapes.

    The object must be dynamic.

    :param int object_id: Object ID.
    :rtype: None
    """
    pass    


def set_object_shape_cone(object_id: int, axis: int, height: Optional[Union[float, int]] = None,
                          diameter: Optional[Union[float, int]] = None) -> None:
    """
    Sets the collision shape to a cone based on the size passed in.

    You must first create a physics body for the object or this command will fail. Returns shape ID.

    :param int object_id: Object ID.
    :param int axis: 0 (AXIS_X)=X axis, 1 (AXIS_Y)=Y axis, 2 (AXIS_Z)=Z axis orientation.
    :param Optional[Union[float, int]] height: Height on the y.  When given, diameter must also be given.
    :param Optional[Union[float, int]] diameter: Diameter on the x and z.  When given, height must also be given.
    :rtype: None
    """
    pass    


def set_object_shape_convex_hull(object_id: int) -> None:
    """
    Sets the objects collision shape to a convex hull based on the size of the object. You must first create a physics
    body for the object or this command will fail.

    :param int object_id: Object ID.
    :rtype: None
    """
    pass    


def set_object_shape_cylinder(object_id: int, axis: int, height: Optional[Union[float, int]] = None,
                              diameter: Optional[Union[float, int]] = None) -> None:
    """
    Sets the collision shape to a cylinder based on the size of the object.

    You must first create a physics body for the object or this command will fail.

    :param int object_id: Object ID.
    :param int axis: 0 (AXIS_X)=X axis, 1 (AXIS_Y)=Y axis, 2 (AXIS_Z)=Z axis orientation.
    :param Optional[Union[float, int]] height: Height on the y.
    :param Optional[Union[float, int]] diameter: Diameter on the x and z.
    :rtype: None
    """
    pass    


def set_object_shape_sphere(object_id: int, diameter: Optional[Union[float, int]] = None) -> None:
    """
    Sets the collision shape to a sphere based on the size of the object.

    You must first create a physics body for the object or this command will fail.

    :param int object_id: Object ID.
    :param Optional[Union[float, int]] diameter: Size of sphere.
    :rtype: None
    """
    pass    


def set_object_shape_static_polygon(object_id: int) -> None:
    """
    Sets the objects collision shape to a static triangle mesh based on the size of the object.

    The object becomes a static object a triangle mesh shape can not be dynamic. You must first create a physics body
    for the object or this command will fail.

    :param int object_id: Object ID.
    :rtype: None
    """
    pass    


def sphere_cast_3d_physics(ray_id: int, from_vector_id: int, to_vector_id: int, radius: Union[float,
                           int]) -> None:
    """
    Casts a sphere collision shape along the length of the ray.

    :param int ray_id: The ID of the ray which is returned by calling `create_3d_physics_ray()`.
    :param int from_vector_id: The ID of the vector holding the start point.
    :param int to_vector_id: The ID of the vector holding the end point.
    :param Union[float, int] radius: The radius of the sphere to cast.
    :rtype: None
    """
    pass    


def sphere_cast_3d_physics_object(object_id: int, ray_id: int, from_vector_id: int,
                                  to_vector_id: int, radius: Union[float, int]) -> bool:
    """
    Casts a sphere collision shape along the length of the ray.

    Returns True if the specified object has been hit and False if it has not.

    :param int object_id: Object ID.
    :param int ray_id: The ID of the ray which is returned by calling `create_3d_physics_ray()`.
    :param int from_vector_id: The ID of the vector holding the start point.
    :param int to_vector_id: The ID of the vector holding the end point.
    :param Union[float, int] radius: The radius of the sphere to cast.
    :rtype: bool
    """
    pass    


def stand_3d_physics_character_controller(object_id: int) -> None:
    """
    Stands the controller.

    :param int object_id: Object ID.
    :rtype: None
    """
    pass    


def step_3d_physics_world() -> None:
    """
    Call before the `sync()` command at the bottom of the loop.

    This will step the physics world. Keeps physics constant regardless of framerate. Not calling this command will
    pause the physics world action.

    :rtype: None
    """
    pass    


def update_3d_physics_pick_joint(joint_id: int, position_vector_id: int) -> None:
    """
    Sets new position of pick joint.

    :param int joint_id: ID of Joint.
    :param int position_vector_id: ID of the position Vector.
    :rtype: None
    """
    pass    


def cache_reward_ad_chartboost() -> None:
    """
    Caches a fullscreen reward video advert for display later using Chartboost.

    Before calling this function you must have set your ad account details with `set_chartboost_details()`. Both iOS and
    Android use caching to preload ads before displaying them. If an ad has already been cached then this will do
    nothing. Unlike AdMob, reward videos will not automatically start caching with Chartboost unless you call this
    command. This is because Chartboost uses the same details for both interstitials and reward videos so AGK can't know
    in advance which you are using. Since video ads can use a lot of mobile data their caching process will not be
    started automatically. You only need to call this once, after a reward video ad has been displayed a new one will be
    cached automatically. Failure to load an ad may be because the ad provider has run out of ads to show to users in a
    particular country. You can check if an ad is waiting to be displayed with `get_reward_ad_loaded_chartboost()`.

    :rtype: None
    """
    pass    


def create_advert(size: int, horizontal_align: int, vertical_align: int, test_ads: Union[bool,
                  int]) -> None:
    """
    Creates an advert for revenue generation.

    Before calling this function you must have set your ad account details with one of the other commands such as
    `set_admob_details()`. Not all platforms support all ad providers so setting as many account details as possible
    will allow AGK to select a suitable ad for this platform.

    This advert will typically be a 320x50 banner displayed somewhere around the edge of your app. Creating an ad when
    one already exists will replace the existing ad. The type parameter can be used to select the size of the banner:
     * 0 (ADVERT_BANNER)=Banner(320x50),
     * 1 (ADVERT_LARGE_BANNER)=LargeBanner,
     * 2 (ADVERT_MEDIUM_RECTANGLE)=MediumRectangle,
     * 3 (ADVERT_FULL_BANNER)=FullBanner,
     * 4 (ADVERT_LEADERBOARD)=Leaderboard,
     * 5 (ADVERT_SMART_BANNER)=SmartBanner,
     * 6 (ADVERT_FLUID_BANNER)=FluidBanner.

    :param int size: The size of the banner to create.
    :param int horizontal_align: The horizontal position of the ad, 0 (ALIGN_LEFT)=left, 1 (ALIGN_CENTER)=center, 2
        (ALIGN_RIGHT)=right.
    :param int vertical_align: The vertical position of the ad, 0 (ALIGN_TOP)=top, 1 (ALIGN_CENTER)=center, 2
        (ALIGN_BOTTOM)=bottom.
    :param Union[bool, int] test_ads: Set to True to receive a non-paying test ad, False to receive a real ad.
    :rtype: None
    """
    pass    


def create_advert_ex(size: int, horizontal_align: int, vertical_align: int, test_ads: Union[bool,
                     int], x: Union[float, int], y: Union[float, int]) -> None:
    """
    Creates an advert for revenue generation.

    Before calling this function you must have set your ad account details with one of the other commands such as
    `set_admob_details()`. Not all platforms support all ad providers so setting as many account details as possible
    will allow AGK to select a suitable ad for this platform.

    This advert will typically be a 320x50 banner displayed somewhere around the edge of your app. Creating an ad when
    one already exists will replace the existing ad. This is an extended version of the `create_advert()` command that
    takes optional offset values for positioning the ad. The type parameter can be used to select the size of the
    banner:
     * 0 (ADVERT_BANNER)=Banner(320x50),
     * 1 (ADVERT_LARGE_BANNER)=LargeBanner,
     * 2 (ADVERT_MEDIUM_RECTANGLE)=MediumRectangle,
     * 3 (ADVERT_FULL_BANNER)=FullBanner,
     * 4 (ADVERT_LEADERBOARD)=Leaderboard,
     * 5 (ADVERT_SMART_BANNER)=SmartBanner,
     * 6 (ADVERT_FLUID_BANNER)=FluidBanner.

    :param int size: The size of the banner to create.
    :param int horizontal_align: The horizontal position of the ad, 0 (ALIGN_LEFT)=left, 1 (ALIGN_CENTER)=center, 2
        (ALIGN_RIGHT)=right.
    :param int vertical_align: The vertical position of the ad, 0 (ALIGN_TOP)=top, 1 (ALIGN_CENTER)=center, 2
        (ALIGN_BOTTOM)=bottom.
    :param Union[bool, int] test_ads: Set to True to receive a non-paying test ad, False to receive a real ad.
    :param Union[float, int] x: When `horizontal_align` is equal to 0 or 2 this value offsets the ad from the specified
        edge.
    :param Union[float, int] y: When `vertical_align` is equal to 0 or 2 this value offsets the ad from the specified
        edge.
    :rtype: None
    """
    pass    


def delete_advert() -> None:
    """
    Clears a previously displayed ad.

    :rtype: None
    """
    pass    


def get_consent_status_admob() -> int:
    """
    Returns the current user consent status, it returns one of the following values:

    -2 = `load_consent_status_admob()` has not yet been called, you must call it before proceeding further

    -1 = `load_consent_status_admob()` is in the process of loading the user consent status, please wait

    0 = User has not yet been asked, AdMob ads will default to not using personal information, call
    `request_consent_admob()` to prompt the user for consent

    1 = User has refused consent, any AdMob ads displayed will not use personal information

    2 = User has given consent, any AdMob ads displayed will use personal information

    :rtype: int
    """
    pass    


def get_fullscreen_advert_loaded_admob() -> bool:
    """
    Returns True if there is an AdMob interstitial ad preloaded and ready to be displayed, otherwise False.

    If so you can display it with `show_fullscreen_advert_admob()`. Adverts are preloaded as soon as you set your AdMob
    details and after every fullscreen advert is dismissed by the user. If this command continues to return False then
    ad loading may have failed due to the provider running out of ads and AGK will stop trying to load them. In this
    case you should try your other ad providers instead. If you find all your ad providers are returning False then you
    can try calling `show_fullscreen_advert_admob()` anyway, it will not display anything as there is nothing loaded,
    but it will restart the loading process to see if any new adverts have become available.

    :rtype: bool
    """
    pass    


def get_fullscreen_advert_loaded_chartboost() -> bool:
    """
    Returns True if there is an Chartboost interstitial ad preloaded and ready to be displayed, otherwise False.

    If so you can display it with `show_fullscreen_advert_chartboost()`. Adverts are preloaded as soon as you set your
    Chartboost details and after every fullscreen advert is dismissed by the user. If this command continues to return 0
    then ad loading may have failed due to the provider running out of ads and AGK will stop trying to load them. In
    this case you should try your other ad providers instead. If you find all your ad providers are returning False then
    you can try calling `show_fullscreen_advert_chartboost()` anyway, it will not display anything as there is nothing
    loaded, but it will restart the loading process to see if any new adverts have become available.

    :rtype: bool
    """
    pass    


def get_reward_ad_loaded_admob() -> bool:
    """
    Returns True if there is an AdMob reward ad preloaded and ready to be displayed, otherwise False.

    If so you can display it with `show_reward_ad_admob()`. Adverts are preloaded as soon as you set your AdMob reward
    details and after every reward advert is dismissed by the user. If this command continues to return False then ad
    loading may have failed due to the provider running out of ads and AGK will stop trying to load them. In this case
    you should try your other ad providers instead. If you find all your ad providers are returning False then you can
    try calling `show_reward_ad_admob()` anyway, it will not display anything as there is nothing loaded, but it will
    restart the loading process to see if any new adverts have become available.

    :rtype: bool
    """
    pass    


def get_reward_ad_loaded_chartboost() -> bool:
    """
    Returns True if there is a Chartboost reward ad preloaded and ready to be displayed, otherwise False.

    If so you can display it with `show_reward_ad_chartboost()`. Adverts are preloaded after calling
    `cache_reward_ad_chartboost()` and after every reward advert is dismissed by the user. If this command continues to
    return False then ad loading may have failed due to the provider running out of ads and AGK will stop trying to load
    them. In this case you should try your other ad providers instead. If you find all your ad providers are returning
    False then you can try calling `cache_reward_ad_chartboost()` again, to restart the loading process to see if any
    new adverts have become available.

    :rtype: bool
    """
    pass    


def get_reward_ad_rewarded_admob() -> bool:
    """
    Returns True if the previously displayed reward ad resulted in a reward that should be given to the user, for
    example some in-game coins.

    When `show_reward_ad_admob()` is called this is set to False and only set to True if the user completed the reward
    video, otherwise it will stay at False. After you have given the user a reward you can set it back to False by using
    `reset_reward_admob()`.

    :rtype: bool
    """
    pass    


def get_reward_ad_rewarded_chartboost() -> bool:
    """
    Returns True if the previously displayed reward ad resulted in a reward that should be given to the user, for
    example some in-game coins.

    When `show_reward_ad_admob()` is called this is set to False and only set to True if the user completed the reward
    video, otherwise it will stay at False. After you have given the user a reward you can set it back to False by using
    `reset_reward_admob()`.

    :rtype: bool
    """
    pass    


def get_reward_ad_value_admob() -> int:
    """
    Returns the value of the currently loaded reward ad, this will return 0 if the reward value is unknown. If no reward
    ad is currently loaded then this value is undefined, it might be 0 or it might be the value of a previous ad. You
    should ask the user if they want to view the reward ad before showing it, along with the reward they will get for
    doing so. You can use this value function to determine an appropriate reward. This value will remain unchanged if
    `reset_reward_admob()` is called.

    :rtype: int
    """
    pass    


def load_consent_status_admob(publisher_id: str, privacy_policy_url: str) -> None:
    """
    Loads the current user consent status from the AdMob server, this must be done before calling
    `request_consent_admob()`.

    You should wait for `get_consent_status_admob()` to return a non-negative value before using the other AdMob consent
    commands.

    :param str publisher_id: The publisher ID for you AdMob account
    :param str privacy_policy_url: A URL to your privacy policy, this will be shown to the user as a link on the consent
        dialog
    :rtype: None
    """
    pass    


def override_consent_admob(consent: int) -> None:
    """
    Forces AdMob to use the given consent value when showing ads, this is not saved to the AdMob server and overrides
    the normal consent process.

    This is used if you have you own method of aquiring user consent to show personalised ads. Note that the GDPR
    requires you by law to have the consent from EU users before showing them personalised ads.

    :param int consent: The consent value to use, 1=non-personalised, 2=personalised
    :rtype: None
    """
    pass    


def override_consent_chartboost(consent: int) -> None:
    """
    Forces Chartboost to use the given consent value when showing ads, by default AGK shows non-personalised ads from
    Chartboost. This command can be used if you have you own method of aquiring user consent to show personalised ads.
    Note that the GDPR requires you by law to have the consent from EU users before showing them personalised ads.

    :param int consent: The consent value to use, 1=non-personalised, 2=personalised
    :rtype: None
    """
    pass    


def request_advert_refresh() -> None:
    """
    Call this command to request a new advert.

    Usually adverts will be provided automatically. You may only want to do this when switching to new screens within
    your application.

    :rtype: None
    """
    pass    


def request_consent_admob() -> None:
    """
    Displays a popup dialog asking the user for consent to show personalised ads.

    The user's response will automatically be used to modify the AdMob settings so that ads are displayed in accordance
    with the user's preferences. The consent status will also be saved on the AdMob server so that a future call to
    `load_consent_status_admob()` can retrieve the value. You can call this command at any time during your app so that
    the user can change their preference, the user must be able to do this somewhere within your app.

    This consent does not apply to Chartboost or Amazon, it only asks for consent to show personalised ads from AdMob.
    You will need your own method of requesting consent for Chartboost and Amazon.

    :rtype: None
    """
    pass    


def reset_reward_admob() -> None:
    """
    Sets the AdMob rewarded value to False.

    You can use this after detecting the reward event and acting on so that you don't reward the user more than once.

    :rtype: None
    """
    pass    


def reset_reward_chartboost() -> None:
    """
    Sets the Chartboost rewarded value to False.

    You can use this after detecting the reward event and acting on so that you don't reward the user more than once.

    :rtype: None
    """
    pass    


def set_admob_child_rating(rating: int) -> None:
    """
    Sets the content rating for AdMob ads if your app is targeted at children. This must be called before
    `set_admob_details()`.

    :param int rating: 0 (ADMOB_NORMAL_ADS) = normal ads, 1 (ADMOB_CHILD_SAFE_ADS) = child safe ads.
    :rtype: None
    """
    pass    


def set_admob_details(ad_unit_id: str) -> None:
    """
    Sets your AdMob account details to be used by banner ads and interstitial (fullscreen) ads.

    Note that this only supports one or the other, you can either set a banner ad unit ID, or an interstitial ad unit
    ID, but not both at the same time.

    After calling this command an attempt will be made to cache an interstitial so you can display it immediately later.
    You can check the progress of this by using `get_fullscreen_advert_loaded_admob()`.

    AdMob ads are currently supported by iOS and Android.

    :param str ad_unit_id: Ad unit ID as provided by AdMob.
    :rtype: None
    """
    pass    


def set_admob_reward_ad_details(ad_unit_id: str) -> None:
    """
    Sets your AdMob account details to be used by reward video ads.

    After calling this command an attempt will be made to cache a reward video so you can display it immediately later.
    You can check the progress of this by using `get_reward_ad_loaded_admob()`.

    AdMob reward videos are currently supported by iOS and Android.

    :param str ad_unit_id: Ad unit ID as provided by AdMob (not the App ID).
    :rtype: None
    """
    pass    


def set_admob_testing(enabled: Union[bool, int]) -> None:
    """
    Sets whether the AdMob ads will be test ads or paying ads.

    This should be called before `set_admob_details()` to ensure all ads are test ads. By default paying ads will be
    shown. Note that if you display paying ads when testing you must not click on them or your AdMob account may be
    suspended.

    :param Union[bool, int] enabled: False to show paying ads, True to show test ads.
    :rtype: None
    """
    pass    


def set_advert_location(horizontal_align: int, vertical_align: int, width: Union[float,
                        int]) -> None:
    """
    Positions the advert created with `create_advert()` somewhere on screen and attempts to scale it to a certain width.

    Since the advert will have its own aspect ratio the height will be calculated from the width. This provides rough
    positioning by letting you choose between left, centered, or right justify for the horizontal and vertical
    positions. This is not guaranteed to work on all advert providers, currently only Inneractive can scale ads to a
    specific width.

    :param int horizontal_align: The horizontal position of the ad, 0 (ALIGN_LEFT)=left, 1 (ALIGN_CENTER)=center, 2
        (ALIGN_RIGHT)=right.
    :param int vertical_align: The vertical position of the ad, 0 (ALIGN_TOP)=top, 1 (ALIGN_CENTER)=center, 2
        (ALIGN_BOTTOM)=bottom.
    :param Union[float, int] width: The desired width of the ad, it will be scaled to this width.
    :rtype: None
    """
    pass    


def set_advert_location_ex(horizontal_align: int, vertical_align: int, x: Union[float, int],
                           y: Union[float, int], width: Union[float, int]) -> None:
    """
    Positions the advert created with `create_advert()` somewhere on screen and attempts to scale it to a certain width.

    Since the advert will have its own aspect ratio the height will be calculated from the width. This provides rough
    positioning by letting you choose between left, centered, or right justify for the horizontal and vertical
    positions. This is not guaranteed to work on all advert providers, currently only Inneractive can scale ads to a
    specific width.

    :param int horizontal_align: The horizontal position of the ad, 0 (ALIGN_LEFT)=left, 1 (ALIGN_CENTER)=center, 2
        (ALIGN_RIGHT)=right.
    :param int vertical_align: The vertical position of the ad, 0 (ALIGN_TOP)=top, 1 (ALIGN_CENTER)=center, 2
        (ALIGN_BOTTOM)=bottom.
    :param Union[float, int] x: When `horizontal_align` is equal to 0 or 2 this value offsets the ad from the specified
        edge.
    :param Union[float, int] y: When `vertical_align` is equal to 0 or 2 this value offsets the ad from the specified
        edge.
    :param Union[float, int] width: The desired width of the ad, it will be scaled to this width.
    :rtype: None
    """
    pass    


def set_advert_position(x: Union[float, int], y: Union[float, int], width: Union[float,
                        int]) -> None:
    """
    Positions the advert created with `create_advert()` somewhere on screen and attempts to scale it to a certain width.

    Since the advert will have its own aspect ratio the height will be calculated from the width. This is not guaranteed
    to work on all advert providers, currently only Inneractive can scale and move ads to an absolute position.

    :param Union[float, int] x: The x position of the top left corner of the ad.
    :param Union[float, int] y: The y position of the top left corner of the ad.
    :param Union[float, int] width: The desired width of the ad, it will be scaled to this width.
    :rtype: None
    """
    pass    


def set_advert_visible(visible: Union[bool, int]) -> None:
    """
    Set the visibility of any advert.

    :param Union[bool, int] visible: True will display the advert and False will hide it.
    :rtype: None
    """
    pass    


def set_chartboost_details(key1: str, key2: str) -> None:
    """
    Sets your Chartboost account details to be used by interstitial (fullscreen) ads and reward video ads.

    After calling this command an attempt will be made to cache an interstitial so you can display it immediately later.
    You can check the progress of this by using `get_fullscreen_advert_loaded_chartboost()`. Note that this command will
    not automatically cache a reward video ad, you must do that manually with `cache_reward_ad_chartboost()`.

    Chartboost ads are currently supported by Android and iOS.

    :param str key1: App ID.
    :param str key2: App Signature.
    :rtype: None
    """
    pass    


def set_inneractive_details(code: str) -> None:
    """
    Sets your Inneractive account details to be used by `create_advert()`.

    Not all platforms support all ad providers so setting as many account details as possible will allow AGK to select a
    suitable ad for this platform.

    Inneractive is currently supported by iOS, Android, Windows, and Mac.

    :param str code: Your account code provided by Inneractive.
    :rtype: None
    """
    pass    


def show_fullscreen_advert_admob() -> None:
    """
    Creates a fullscreen (interstitial) advert for revenue generation using AdMob.

    Before calling this function you must have set your ad account details with `set_admob_details()`. Both iOS and
    Android use caching to preload ads before displaying them. If an ad has been loaded when you call this command then
    it will be displayed immediately, otherwise it will attempt to load an ad for next time you call this command.
    Failure to load an ad may be because the ad provider has run out of ads to show to users in a particular country.
    You can check if an ad is waiting to be displayed with `get_fullscreen_advert_loaded_admob()`. Your app will be
    paused when the advert is displayed, and will resume when the advert is dismissed.

    :rtype: None
    """
    pass    


def show_fullscreen_advert_chartboost() -> None:
    """
    Creates a fullscreen (interstitial) advert for revenue generation using Chartboost.

    Before calling this function you must have set your ad account details with `set_chartboost_details()`. Both iOS and
    Android use caching to preload ads before displaying them. If an ad has been loaded when you call this command then
    it will be displayed immediately, otherwise it will attempt to load an ad for next time you call this command.
    Failure to load an ad may be because the ad provider has run out of ads to show to users in a particular country.
    You can check if an ad is waiting to be displayed with `get_fullscreen_advert_loaded_chartboost()`. Your app will be
    paused when the advert is displayed, and will resume when the advert is dismissed.

    :rtype: None
    """
    pass    


def show_reward_ad_admob() -> None:
    """
    Creates a fullscreen reward video advert for revenue generation using AdMob.

    Before calling this function you must have set your ad account details with `set_admob_reward_ad_details()`. Both
    iOS and Android use caching to preload ads before displaying them. If an ad has been loaded when you call this
    command then it will be displayed immediately, otherwise it will attempt to load an ad for next time you call this
    command. Failure to load an ad may be because the ad provider has run out of ads to show to users in a particular
    country. You can check if an ad is waiting to be displayed with `get_reward_ad_loaded_admob()`. Your app will be
    paused when the advert is displayed, and will resume when the advert is dismissed. Check
    `get_reward_ad_rewarded_admob()` to see if the user completed watching the reward ad and should be rewarded. It will
    be set to 0 when you call this command, and then set to 1 when they have finished watching.

    :rtype: None
    """
    pass    


def show_reward_ad_chartboost() -> None:
    """
    Creates a fullscreen reward video advert for revenue generation using Chartboost.

    Before calling this function you must have set your ad account details with `set_chartboost_details()`. Both iOS and
    Android use caching to preload ads before displaying them. If an ad has been loaded when you call this command then
    it will be displayed immediately, otherwise it will attempt to load an ad for next time you call this command. For
    Chartboost you must start the caching process manually with `cache_reward_ad_chartboost()`, you only need to call
    this once. After a reward video ad has been displayed a new one will be cached automatically. Failure to load an ad
    may be because the ad provider has run out of ads to show to users in a particular country. You can check if an ad
    is waiting to be displayed with `get_reward_ad_loaded_chartboost()`. Your app will be paused when the advert is
    displayed, and will resume when the advert is dismissed. Check `get_reward_ad_rewarded_chartboost()` to see if the
    user completed watching the reward ad and should be rewarded. It will be set to 0 when you call this command, and
    then set to 1 when they have finished watching.

    :rtype: None
    """
    pass    


def get_drawing_setup_time() -> float:
    """
    Returns the number of seconds and fractions of seconds spent setting up the world ready for drawing.

    This includes calculating what is visible, transforming sprites into their screen positions and sending vertices to
    the GPU.

    :rtype: float
    """
    pass    


def get_drawing_time() -> float:
    """
    Returns the time spent swapping the backbuffer and (if necessary) waiting for the GPU to catch up ready for the next
    frame.

    :rtype: float
    """
    pass    


def get_image_memory_usage() -> float:
    """
    Returns the amount of memory in megabytes currently being used by all loaded images (including images used by
    fonts).

    This can help track down problems with GPU memory which can cause a crash if it runs out. Every image you load will
    be placed in GPU memory, even if you don't use it, so loading too many large images could use up all the memory.

    :rtype: float
    """
    pass    


def get_loaded_images() -> int:
    """
    Returns the number of images currently loaded into the app.

    :rtype: int
    """
    pass    


def get_managed_sprite_count() -> int:
    """
    Returns the number of sprites that are being managed by the internal sprite manager.

    It is responsible for updating sprite animation and calculating which sprites are visible and need to be sent for
    drawing. It also sorts the sprites when necessary for correct transparency drawing.

    As long as not too many sprites are sent for drawing the sprite manager should be able to handle several hundred
    sprites.

    :rtype: int
    """
    pass    


def get_managed_sprite_draw_calls() -> int:
    """
    Returns the number of OpenGL draw calls used to draw all managed sprites.

    Generally the lower this number the better the performance. AGK attempts to batch sprites into as few draw calls as
    possible, it does this by looking for sprites with the same texture and drawing them at the same time.

    :rtype: int
    """
    pass    


def get_managed_sprite_drawn_count() -> int:
    """
    Returns the number of sprites that were actually sent for rendering to the GPU last frame, the more that get drawn
    the slower the app will run.

    :rtype: int
    """
    pass    


def get_managed_sprite_sorted_count() -> int:
    """
    Returns the number of sprites that the internal sprite manager had to sort into their correct positions since the
    last frame. Sprites only need resorting if they change depth or texture during the current frame.

    :rtype: int
    """
    pass    


def get_particle_drawn_quad_count() -> int:
    """
    Returns the number of individual particles that were drawn last frame using a quad method.

    The higher this number the more work the engine is doing handling particles.

    :rtype: int
    """
    pass    


def get_physics_time() -> float:
    """
    Returns the number of seconds and fractions of seconds spent updating the physics simulation.

    :rtype: float
    """
    pass    


def get_pixels_drawn() -> int:
    """
    Returns an estimate of the number of pixels that were drawn to the screen last frame.

    Generally the lower this value the better the performance. The number of pixels drawn can be greater than the number
    of pixels in the screen since overlapping sprites might draw the same pixel twice.

    :rtype: int
    """
    pass    


def get_unassigned_image_file_name(index: int) -> str:
    """
    Returns the filename of the specified unassigned image.

    :param int index: The index of the unassigned image, between 1 and the value returned by `get_unassigned_images()`.
    :rtype: str
    """
    pass    


def get_unassigned_images() -> int:
    """
    Returns the number of images currently loaded into the app but are not assigned to a sprite or text object.

    This is useful for debugging to check you have deleted all unused images when switching from a menu to a level, or
    from one level to another.

    :rtype: int
    """
    pass    


def get_update_time() -> float:
    """
    Returns the number of seconds and fractions of seconds spent updating everything in the world except physics.

    This includes sprite animation, emulating input, and handling sounds.

    :rtype: float
    """
    pass    


def abs(value: Union[float, int]) -> float:
    """
    Returns absolute of a value, that is the positive version of the number.

    :param Union[float, int] value: The value to convert.
    :rtype: float
    """
    pass    


def acos(a: Union[float, int]) -> float:
    """
    Returns the arccosine of a value in degrees.

    :param Union[float, int] a: The value to pass into the arccosine function.
    :rtype: float
    """
    pass    


def acos_rad(a: Union[float, int]) -> float:
    """
    Returns the arccosine of a value in radians.

    :param Union[float, int] a: The value to pass into the arccosine function.
    :rtype: float
    """
    pass    


def asc(text: str) -> int:
    """
    Converts a single character string to the Unicode value it represents.

    :param str text: The string character to convert to the Unicode value.
    :rtype: int
    """
    pass    


def asin(a: Union[float, int]) -> float:
    """
    Returns the arcsine of a value in degrees.

    :param Union[float, int] a: The value to pass into the arcsine function.
    :rtype: float
    """
    pass    


def asin_rad(a: Union[float, int]) -> float:
    """
    Returns the arcsine of a value in radians.

    :param Union[float, int] a: The value to pass into the arcsine function.
    :rtype: float
    """
    pass    


def atan(a: Union[float, int]) -> float:
    """
    Returns the arctangent of a value in degrees in the range -90 to 90.

    :param Union[float, int] a: The value to pass into the arctangent function.
    :rtype: float
    """
    pass    


def atan2(y: Union[float, int], x: Union[float, int]) -> float:
    """
    Returns the angle of an x,y vector in degrees in the range -180 to 180.

    This exactly matches the C++ atan2 function with degrees.

    :param Union[float, int] y: The y value to pass to atan2.
    :param Union[float, int] x: The x value to pass to atan2.
    :rtype: float
    """
    pass    


def atan2_rad(y: Union[float, int], x: Union[float, int]) -> float:
    """
    Returns the angle of an x,y vector in radians in the range -pi to pi.

    This exactly matches the C++ atan2 function.

    :param Union[float, int] y: The y value to pass to atan2.
    :param Union[float, int] x: The x value to pass to atan2.
    :rtype: float
    """
    pass    


def atan_full(x: Union[float, int], y: Union[float, int]) -> float:
    """
    Returns the angle in degrees between x=0 y=-1 (up) and the given vector in a clockwise direction.

    Returns a value from 0 to 360. This command is proprietary to AGK and is useful in 2D situations. If you are looking
    for an equivalent to atan2 in C++ use the AGK command ATan2 instead.

    :param Union[float, int] x: The x component of the vector to check.
    :param Union[float, int] y: The y component of the vector to check.
    :rtype: float
    """
    pass    


def atan_full_rad(x: Union[float, int], y: Union[float, int]) -> float:
    """
    Returns the angle in radians between x=0 y=-1 (up) and the given vector in a clockwise direction.

    Returns a value from 0 to 2*PI. This command is proprietary to AGK and is useful in 2D situations. If you are
    looking for an equivalent to atan2 in C++ use the AGK command `atan2_rad()` instead.

    :param Union[float, int] x: The x component of the vector to check.
    :param Union[float, int] y: The y component of the vector to check.
    :rtype: float
    """
    pass    


def atan_rad(a: Union[float, int]) -> float:
    """
    Returns the arctangent of a value in radians in the range -pi/2 to pi/2.

    :param Union[float, int] a: The value to pass into the arctangent function.
    :rtype: float
    """
    pass    


def byte_len(text: str) -> int:
    """
    Returns the number of bytes in the given string.

    Note that for strings encoded in UTF-8 this may not be equal to the number of characters in the string, as each
    character can use up to 4 bytes.

    :param str text: The string to measure the length of.
    :rtype: int
    """
    pass    


def ceil(value: Union[float, int]) -> int:
    """
    Rounds a float to the next highest integer.

    This differs from `trunc()` when using positive numbers, `trunc(1.6)` is 1 but `ceil(1.6)` is 2.

    :param Union[float, int] value: The value to round up.
    :rtype: int
    """
    pass    


def clear_depth_buffer() -> None:
    """
    Clears the depth buffer of all objects.

    This will clear the buffer even if depth clearing has been turned off with `enable_clear_depth()`.

    :rtype: None
    """
    pass    


def clear_screen() -> None:
    """
    Clears the back buffer and depth buffer of all drawing and fills it with the chosen clear color set by
    `set_clear_color()`.

    This does not effect what is seen on screen unless `swap()` is called to display the back buffer to screen. This
    allows you to draw some things to the backbuffer, use `get_image()` to store the result and then `clear_screen()` to
    draw something else.

    :rtype: None
    """
    pass    


def clear_url_scheme_text() -> None:
    """
    Clears the currently stored URL scheme text so you can signal that you have acted upon it.

    This is not necessary but can make your code easier by not having to remember that you have dealt with a URL scheme
    event.

    :rtype: None
    """
    pass    


def compare_string(text1: str, text2: str, ignore_case: Union[bool, int] = True,
                   max_chars: int = -1) -> bool:
    """
    Returns True if the two strings are equal to each other, otherwise returns False.

    By default this is case insensitive, use the `ignore_case` parameter to set case sensitivity. Use the `max_chars`
    parameter to specify the maximum number of characters to check, if the strings match after that many characters have
    been checked then they are considered equal. Use a value of -1 to check all characters regardless of length.

    :param str text1: The first string to check.
    :param str text2: The second string to check.
    :param Union[bool, int] ignore_case: True to ignore case when comparing, False to match case.
    :param int max_chars: The number of characters to check, -1 for all.
    :rtype: bool
    """
    pass    


def cos(a: Union[float, int]) -> float:
    """
    Returns the cosine of a value in degrees.

    :param Union[float, int] a: The value to pass into the cosine function.
    :rtype: float
    """
    pass    


def cos_rad(a: Union[float, int]) -> float:
    """
    Returns the cosine of a value in radians.

    :param Union[float, int] a: The value to pass into the cosine function.
    :rtype: float
    """
    pass    


def count_string_tokens(text: str, delimiters: str) -> int:
    """
    Counts the number of tokens separated by a specified set of delimiters, for example a string containing
    "first:second:third" has three tokens delimited by ":" and "first:second;third" has three tokens separated by the
    delimiters ":;".

    You can have multiple delimiters between each token, for example "first:;second:third" is valid, and has three
    tokens. This command is useful for separating words in a sentence, which can be delimited by both white space and
    punctuation.

    :param str text: The string to check.
    :param str delimiters: The set of characters that delimit the string.
    :rtype: int
    """
    pass    


def count_string_tokens2(text: str, delimiter: str) -> int:
    """
    Counts the number of tokens separated by a specified delimiter, for example a string containing "first:second:third"
    has three tokens delimited by ":".

    Similar to `count_string_tokens()` except that this command accepts only a single character as the delimiter and
    recognises empty fields. For example "first:second::fourth" has four tokens with the third being an empty string.

    :param str text: The string to check.
    :param str delimiter: The character that delimits the string.
    :rtype: int
    """
    pass    


def download_expansion_file() -> None:
    """
    Starts the download of any expansion file that this platform and app needs, currently only applicable to Android.

    If the download has already started this has no effect. You can use `get_expansion_file_progress()` to check on the
    progress of the download and `get_expansion_file_state()` to check when it has completed. After calling this command
    you should wait for `get_expansion_file_state()` to return -1 (error) or 3 (complete) whilst displaying a progress
    bar.

    :rtype: None
    """
    pass    


def draw_box(x1: Union[float, int], y1: Union[float, int], x2: Union[float, int], y2: Union[float,
             int], color1: int, color2: int, color3: int, color4: int, filled: Union[bool,
             int]) -> None:
    """
    Draws a 2D box from one point on the screen to another with a chosen color using lines.

    Lines appear above all other drawing except the `print_value()` command and can be used with the `get_image()`
    function or `set_render_to_image()` to create new images. The XY coordinates are in screen coordinates so are not
    affected by the `set_view_offset()` command. Colors can be created using the `make_color()` command or by using the
    bitwise operators like so, mycolor = (blue << 16) || (green << 8) || red.

    :param Union[float, int] x1: The X component of the top left corner of the box.
    :param Union[float, int] y1: The Y component of the top left corner of the box.
    :param Union[float, int] x2: The X component of the bottom right corner of the box.
    :param Union[float, int] y2: The Y component of the bottom right corner of the box.
    :param int color1: The color to use in the top left corner.
    :param int color2: The color to use in the top right corner.
    :param int color3: The color to use in the bottom left corner.
    :param int color4: The color to use in the bottom right corner.
    :param Union[bool, int] filled: True to draw a filled box, False to draw an empty box.
    :rtype: None
    """
    pass    


def draw_ellipse(x: Union[float, int], y: Union[float, int], radius_x: Union[float, int],
                 radius_y: Union[float, int], color1: int, color2: int, filled: Union[bool,
                 int]) -> None:
    """
    Draws a 2D ellipse centered on the coordinates given with a chosen color or gradient.

    2D shapes appear above all other drawing except the `print_value()` command and can be used with the `get_image()`
    function to create new images. The XY coordinates are in screen coordinates so are not affected by the
    `set_view_offset()` command.

    :param Union[float, int] x: The X component of the center of the ellipse.
    :param Union[float, int] y: The Y component of the center of the ellipse.
    :param Union[float, int] radius_x: The radius of the ellipse in the X direction.
    :param Union[float, int] radius_y: The radius of the ellipse in the Y direction.
    :param int color1: The color at the top of the ellipse.
    :param int color2: The color at the bottom of the ellipse.
    :param Union[bool, int] filled: True for filled, False for empty.
    :rtype: None
    """
    pass    


def draw_line(x1: Union[float, int], y1: Union[float, int], x2: Union[float, int], y2: Union[float,
              int], color1: int, color2: int) -> None:
    """
    Draws a 2D line from one point on the screen to another with a chosen color.

    Lines appear above all other drawing except the `print_value()` command and can be used with the `get_image()`
    function to create new images. The XY coordinates are in screen coordinates so are not affected by the
    `set_view_offset()` command.

    :param Union[float, int] x1: The X component of the start position of the line.
    :param Union[float, int] y1: The Y component of the start position of the line.
    :param Union[float, int] x2: The X component of the end position of the line.
    :param Union[float, int] y2: The Y component of the end position of the line.
    :param int color1: The color to use at the start of the line. (Hex: 0xBBGGRR)
    :param int color2: The color to use at the end of the line. (Hex: 0xBBGGRR)
    :rtype: None
    """
    pass    


def draw_line_rgb(x1: Union[float, int], y1: Union[float, int], x2: Union[float, int],
                  y2: Union[float, int], red: int, green: int, blue: int) -> None:
    """
    Draws a 2D line from one point on the screen to another with a chosen color.

    Lines appear above all other drawing except the `print_value()` command and can be used with the `get_image()`
    function to create new images. The XY coordinates are in screen coordinates so are not affected by the
    `set_view_offset()` command.

    :param Union[float, int] x1: The X component of the start position of the line.
    :param Union[float, int] y1: The Y component of the start position of the line.
    :param Union[float, int] x2: The X component of the end position of the line.
    :param Union[float, int] y2: The Y component of the end position of the line.
    :param int red: The red component of the line color.
    :param int green: The green component of the line color.
    :param int blue: The blue component of the line color.
    :rtype: None
    """
    pass    


def enable_clear_color(enabled: Union[bool, int]) -> None:
    """
    Sets whether the frame buffer should be cleared when `sync()` or `swap()` are called.

    By default this is set to true. The only reason to call this command is if you have a background sprite, or set of
    sprites, that completely cover the screen so the background color will never be visible. In these cases some GPUs
    can benefit from turning the clear color off. Please note that in many cases the last drawn frame will remain on
    screen, however, this is not guaranteed, and you should not create effects that rely on it as they may not work in
    future, and won't work on mobile devices. To create effects that maintain the contents of the previous frame it is
    recommended that you use `set_render_to_image()` to capture the output of one frame and then draw it into the next
    frame, i.e. you render everything to image 1, then in the next frame you paste image 1 into the background of a new
    render target and then draw the new frame. For example draw everything in frame 1 to image 1, then in frame 2 you
    draw image 1 with a full screen Quad object to image 2, and then draw everything in frame 2 to image 2. You can then
    swap the render targets so in frame 3 you draw image 2 with a full screen quad back into image 1, then draw the
    objects in frame 3 to image 1. Continue to alternate between image 1 and 2, so frame 4 would first have image 1
    drawn with a full screen quad to image 2, then draw everything in frame 4 to image 2. It is important to not
    continue drawing everything to the same image, i.e. draw frame 1 to image 1, then frame 2 to image 1, and so on
    because mobile devices use an internal deferred renderer that will keep an ever increasing list of things to draw to
    image 1. If the image is never cleared then performance will degrade.

    :param Union[bool, int] enabled: True to clear the frame buffer, False to not clear it.
    :rtype: None
    """
    pass    


def enable_clear_depth(enabled: Union[bool, int]) -> None:
    """
    Sets whether the depth buffer should be cleared when `sync()` or `swap()` are called.

    By default this is set to true. Disabling this is not recommended as anything that uses the depth buffer will only
    appear for one frame and then seeming disappear. This function may not have any effect on mobile devices.

    :param Union[bool, int] enabled: True to clear the depth buffer, False to not clear it.
    :rtype: None
    """
    pass    


def find_string(text: str, find_text: str, ignore_case: Union[bool, int] = True,
                start: int = 1) -> int:
    """
    Returns the index of the first occurrence of `find_text` in the given string. Index 1 is the first character in the
    string, returns 0 if not found. By default this is case insensitive, use the `ignore_case` parameter to set case
    sensitivity.

    :param str text: The string to check.
    :param str find_text: The string to find.
    :param Union[bool, int] ignore_case: True to ignore case when searching, False to match case.
    :param int start: The index to start from, the first character is at index 1.
    :rtype: int
    """
    pass    


def find_string_count(text: str, find_text: str, ignore_case: Union[bool, int] = True,
                      start: int = 1) -> int:
    """
    Returns the number of times `find_text` appears in the given string. By default this is case insensitive, use the
    `ignore_case` parameter to set case sensitivity.

    :param str text: The string to check.
    :param str find_text: The string to find.
    :param Union[bool, int] ignore_case: True to ignore case when searching, False to match case.
    :param int start: The index to start from, the first character is at index 1.
    :rtype: int
    """
    pass    


def find_string_reverse(text: str, find_text: str, ignore_case: Union[bool, int] = True,
                        start: int = -1) -> int:
    """
    Returns the index of the first occurrence of `find_text` in the given string, starting from the end of the string
    and moving backwards. Use a start value of -1 to start at the very end of the string regardless of length. Index 1
    is the first character in the string, returns 0 if not found. By default this is case insensitive, use the
    `ignore_case` parameter to set case sensitivity.

    :param str text: The string to check.
    :param str find_text: The string to find.
    :param Union[bool, int] ignore_case: True to ignore case when searching, False to match case.
    :param int start: The index to start from, the first character is at index 1, use -1 to start at the very end.
    :rtype: int
    """
    pass    


def floor(value: Union[float, int]) -> int:
    """
    Rounds a float to the next lowest integer.

    This differs from `trunc()` when using negative numbers, `trunc(-1.6)` is -1 but `floor(-1.6)` is -2.

    :param Union[float, int] value: The value to floor.
    :rtype: int
    """
    pass    


def fmod(a: Union[float, int], b: Union[float, int]) -> float:
    """
    Returns the remainder of the float division a/b.

    :param Union[float, int] a: The numerator.
    :param Union[float, int] b: The denominator.
    :rtype: float
    """
    pass    


def get_app_installed(package_name: str) -> int:
    """
    Returns 1 if the specified app is installed and enabled on the device. For Android this should be the package name
    of the app, e.g. com.faceboook.katana for the Facebook App. Currently this only works on Android

    :param str package_name: The package name of the app to check
    :rtype: int
    """
    pass    


def get_app_name() -> str:
    """
    Returns the name of the exe.

    :rtype: str
    """
    pass    


def get_app_package_name() -> str:
    """
    On Android this returns the package name used when exporting the app, for example for the AGK Player this would be
    com.thegamecreators.agk_player2.

    On iOS it returns the Bundle ID used for the app, for example for the AGK Player this would be
    com.thegamecreators.agk2player. On all other platforms this currently returns an empty string.

    :rtype: str
    """
    pass    


def get_app_running(app_id: int) -> bool:
    """
    Returns True if the specified app ID is still running, False if it is not.

    :param int app_id: The app ID to check, returned from `run_app()`.
    :rtype: bool
    """
    pass    


def get_color_blue(color: int) -> int:
    """
    Returns the blue component of a compound color value created with `make_color()`.

    :param int color: The color value to decompose.
    :rtype: int
    """
    pass    


def get_color_green(color: int) -> int:
    """
    Returns the green component of a compound color value created with `make_color()`.

    :param int color: The color value to decompose.
    :rtype: int
    """
    pass    


def get_color_red(color: int) -> int:
    """
    Returns the red component of a compound color value created with `make_color()`.

    :param int color: The color value to decompose.
    :rtype: int
    """
    pass    


def get_device_base_name() -> str:
    """
    Returns a string containing the name of the current platform.

    This will only refer to the base platform, i.e. "windows", "ios", "android", "mac", "linux", or "html5". Use
    `get_device_type()` to get more information about the specific device. This string will always be lower case.

    :rtype: str
    """
    pass    


def get_device_dpi() -> int:
    """
    Gets the Dots Per Inch (also called Pixels Per Inch) of the device screen.

    This only works on iOS and Android, other platforms will return 0. On iOS this value is hardcoded by device, so if a
    new device is released then an AGK update will be required to get an accurate value. In the meantime an estimated
    value will be generated.

    :rtype: int
    """
    pass    


def get_device_height() -> int:
    """
    Returns the height in pixels of the current device's backbuffer.

    This value will change if the device orientation changes from portrait to landscape, but only if orientation changes
    are allowed.

    :rtype: int
    """
    pass    


def get_device_id() -> str:
    """
    Returns a string that can be used to identify this device.

    :rtype: str
    """
    pass    


def get_device_language() -> str:
    """
    Returns a string containing the language of the current device in the form "en", "fr", "de", etc.

    :rtype: str
    """
    pass    


def get_device_network_type() -> int:
    """
    Returns the type of network connection the device has to the internet.

    Returns 0 if a mobile connection is being used, 1 if a Wifi or Ethernet connection is being used, or -1 if the
    network type could not be determined. Currently only implemented on iOS and Android, other platforms will return -1.

    :rtype: int
    """
    pass    


def get_device_platform() -> int:
    """
    On Android this returns 0 if this app is running on a Google device, or 1 if it is running on an Amazon device.

    On all other platforms this returns 0.

    :rtype: int
    """
    pass    


def get_device_type() -> str:
    """
    Returns a string containing a device specific string, this will be different for each platform, for example on
    Windows it will return the OS version "vista, "7", "xp", etc.

    On iOS it will return the iOS device name "ipad1,1", "ipod2,1", "iphone1,2", etc. For Android it will return the
    device model "nexus 7", etc. For Mac it will return the OS version "10.7", "10.8", etc. This string will always be
    lower case.

    :rtype: str
    """
    pass    


def get_device_width() -> int:
    """
    Returns the width in pixels of the current device's backbuffer.

    This value will change if the device orientation changes from portrait to landscape, but only if orientation changes
    are allowed.

    :rtype: int
    """
    pass    


def get_display_aspect() -> float:
    """
    Returns the current aspect ratio for the screen.

    This is not the aspect ratio of the coordinate system being used, instead this value stretches the coordinate system
    into the desired shape. For an explanation of the coordinate system see `set_virtual_resolution()`.

    :rtype: float
    """
    pass    


def get_display_cutout_bottom(index: int) -> float:
    """
    Returns the bottom of the specified display cutout. The Top/Bottom/Left/Right display cutout commands return the
    bounding box that covers the cutout in virtual resolution coordinates. Anthing placed within those coordinates can
    be assumed to be covered by the cutout.

    The index must be between 0 and `get_display_num_cutouts()` - 1.

    :param int index: The index of the display cutout to return, starting at 0.
    :rtype: float
    """
    pass    


def get_display_cutout_left(index: int) -> float:
    """
    Returns the left of the specified display cutout. The Top/Bottom/Left/Right display cutout commands return the
    bounding box that covers the cutout in virtual resolution coordinates. Anthing placed within those coordinates can
    be assumed to be covered by the cutout.

    The index must be between 0 and `get_display_num_cutouts()` - 1.

    :param int index: The index of the display cutout to return, starting at 0.
    :rtype: float
    """
    pass    


def get_display_cutout_right(index: int) -> float:
    """
    Returns the right of the specified display cutout. The Top/Bottom/Left/Right display cutout commands return the
    bounding box that covers the cutout in virtual resolution coordinates. Anthing placed within those coordinates can
    be assumed to be covered by the cutout.

    The index must be between 0 and `get_display_num_cutouts()` - 1.

    :param int index: The index of the display cutout to return, starting at 0.
    :rtype: float
    """
    pass    


def get_display_cutout_top(index: int) -> float:
    """
    Returns the top of the specified display cutout. The Top/Bottom/Left/Right display cutout commands return the
    bounding box that covers the cutout in virtual resolution coordinates. Anthing placed within those coordinates can
    be assumed to be covered by the cutout.

    The index must be between 0 and `get_display_num_cutouts()` - 1.

    :param int index: The index of the display cutout to return, starting at 0.
    :rtype: float
    """
    pass    


def get_display_num_cutouts() -> int:
    """
    Returns the number of cutouts on the current device screen. Always returns 0 on Android 8 and below, and iOS 10 and
    below. You can retrieve details about each cutout by using the `get_display_cutout_top()` commands.

    :rtype: int
    """
    pass    


def get_expansion_file_error() -> int:
    """
    Returns the error code of the most recent error that occurred when downloading the expansion file.

    Possible errors include:

    15 = Unlicensed

    16 = Failed fetching URL

    17 = SDcard full

    18 = Cancelled

    19 = Unknown error

    :rtype: int
    """
    pass    


def get_expansion_file_progress() -> float:
    """
    Checks the progress of a download started by `download_expansion_file()`, returns a float value between 0 and 100
    Use `get_expansion_file_state()` to check if the download has completed.

    :rtype: float
    """
    pass    


def get_expansion_file_state() -> int:
    """
    Returns the state of any expansion file used by this platform, currently only applicable to Android.

    Returns:
     * -1 if an error occurred during download,
     * 0 if the expansion file is not used on this platform,
     * 1 if it should exist but doesn't (you call `download_expansion_file()` in this case),
     * 2 if it is currently being downloaded, or
     * 3 if everything has completed and the file exists.

    :rtype: int
    """
    pass    


def get_fractal_x(octaves: int, x: Union[float, int]) -> float:
    """
    Returns Fractal/Fractional Brownian Motion.

    :param int octaves: number of fraction of noise to sum.
    :param Union[float, int] x: x float coordinate.
    :rtype: float
    """
    pass    


def get_fractal_xy(octaves: int, x: Union[float, int], y: Union[float, int]) -> float:
    """
    Returns Fractal/Fractional Brownian Motion.

    :param int octaves: number of fraction of noise to sum.
    :param Union[float, int] x: x float coordinate.
    :param Union[float, int] y: y float coordinate.
    :rtype: float
    """
    pass    


def get_fractal_xyz(octaves: int, x: Union[float, int], y: Union[float, int], z: Union[float,
                    int]) -> float:
    """
    Returns Fractal/Fractional Brownian Motion.

    :param int octaves: number of fraction of noise to sum.
    :param Union[float, int] x: x float coordinate.
    :param Union[float, int] y: y float coordinate.
    :param Union[float, int] z: z float coordinate.
    :rtype: float
    """
    pass    


def get_frame_time() -> float:
    """
    Get the time in seconds spent processing and rendering the last frame.

    Only updated when `sync()` or `swap()` are called. This is limited to a max value of 0.2 seconds to prevent internal
    timer based code from interpolating large time gaps. To find the true frame time you can use the `timer()` command.

    :rtype: float
    """
    pass    


def get_max_device_height() -> int:
    """
    Gets the maximum height that your app window can be.

    For platforms that support windowed mode such as Windows and Mac your app can only achieve this size in full screen
    mode as windowed mode has a border around your app. For HTML5 apps this will return the size of the current HTML
    document, and is not guaranteed to work if the HTML5 app is running in full screen mode.

    A better name for this command would be GetMaxWindowHeight, but it is now set in stone.

    :rtype: int
    """
    pass    


def get_max_device_width() -> int:
    """
    Gets the maximum width that your app window can be.

    For platforms that support windowed mode such as Windows and Mac your app can only achieve this size in full screen
    mode as windowed mode has a border around your app. For HTML5 apps this will return the size of the current HTML
    document, and is not guaranteed to work if the HTML5 app is running in full screen mode.

    A better name for this command would be GetMaxWindowWidth, but it is now set in stone.

    :rtype: int
    """
    pass    


def get_milliseconds() -> int:
    """
    Get the number of milliseconds since the app was started.

    Calling this command will internally make a system call to get the amount of time passed, so it may change each time
    you call it.

    :rtype: int
    """
    pass    


def get_noise_x(x: Union[float, int]) -> float:
    """
    Returns 1D Perlin simplex noise.

    :param Union[float, int] x: x float coordinate.
    :rtype: float
    """
    pass    


def get_noise_xy(x: Union[float, int], y: Union[float, int]) -> float:
    """
    Returns 2D Perlin simplex noise.

    :param Union[float, int] x: x float coordinate.
    :param Union[float, int] y: y float coordinate.
    :rtype: float
    """
    pass    


def get_noise_xyz(x: Union[float, int], y: Union[float, int], z: Union[float, int]) -> float:
    """
    Returns 3D Perlin simplex noise.

    :param Union[float, int] x: x float coordinate.
    :param Union[float, int] y: y float coordinate.
    :param Union[float, int] z: z float coordinate.
    :rtype: float
    """
    pass    


def get_num_processors() -> int:
    """
    Returns the number of logical processor cores on the device.

    :rtype: int
    """
    pass    


def get_orientation() -> int:
    """
    Returns the current orientation of the device.

    The values returned are:
     * 1 (ORIENTATION_PORTRAIT)= portrait mode,
     * 2 (ORIENTATION_PORTRAIT_180)= portrait mode - 180 degrees rotation,
     * 3 (ORIENTATION_LANDSCAPE_CCW)= landscape mode - 90 degrees counterclockwise,
     * 4 (ORIENTATION_LANDSCAPE_CW)= landscape mode - 90 degrees clockwise.

    :rtype: int
    """
    pass    


def get_paused() -> bool:
    """
    Returns True if your desktop app loses focus.

    You can choose to activate a pause screen when this happens or let the app continue as normal. This only applies to
    desktop platforms, on mobile platforms you should use `get_resumed()` instead.

    :rtype: bool
    """
    pass    


def get_polygons_drawn() -> int:
    """
    Returns the number of polygons drawn by the GPU last frame.

    :rtype: int
    """
    pass    


def get_renderer_name() -> str:
    """
    Returns the name of the current renderer, e.g. "OpenGL" or "OpenGLES"

    :rtype: str
    """
    pass    


def get_resumed() -> bool:
    """
    Returns True if your app has been passed to the background and has just been reactivated.

    You should activate a pause screen when this happens. On mobile platforms apps will not run whilst they are in the
    background so that first chance you app will get to receive this notification is when it returns from the background
    and continues running. Since the user may not yet be ready to continue playing you should check this value and show
    a pause screen until they are ready.

    :rtype: bool
    """
    pass    


def get_screen_bounds_bottom() -> float:
    """
    Returns the bottom edge of the visible screen.

    This includes any black border area so if there are black borders on the top and bottom of the display then this
    value will be greater than `get_virtual_height()`. This represents the fact that the virtual height is the end of
    the visible area and the start of the black border, and the bottom bound is the end of the black border and the edge
    of the screen. If there is no black border on the bottom then the bottom bound will always be equal to
    `get_virtual_height()`.

    :rtype: float
    """
    pass    


def get_screen_bounds_left() -> float:
    """
    Returns the left edge of the visible screen.

    This includes any black border area so if there are black borders on the left and right of the display then this
    value will be negative. This represents the fact that 0 is the end of the visible area and the start of the black
    border, and the left bound is the end of the black border and the edge of the screen. If there is no black border to
    the left then the left bound will always be 0.

    :rtype: float
    """
    pass    


def get_screen_bounds_right() -> float:
    """
    Returns the right edge of the visible screen.

    This includes any black border area so if there are black borders on the left and right of the display then this
    value will be greater than `get_virtual_width()`. This represents the fact that the virtual width is the end of the
    visible area and the start of the black border, and the right bound is the end of the black border and the edge of
    the screen. If there is no black border to the right then the right bound will always be equal to
    `get_virtual_width()`.

    :rtype: float
    """
    pass    


def get_screen_bounds_safe_bottom() -> float:
    """
    Returns the bottom of the screen in virtual coordinates, avoiding any display cutouts. This is similar to
    `get_screen_bounds_top()` except that it avoids display cutouts.

    :rtype: float
    """
    pass    


def get_screen_bounds_safe_left() -> float:
    """
    Returns the left of the screen in virtual coordinates, avoiding any display cutouts. This is similar to
    `get_screen_bounds_top()` except that it avoids display cutouts.

    :rtype: float
    """
    pass    


def get_screen_bounds_safe_right() -> float:
    """
    Returns the right of the screen in virtual coordinates, avoiding any display cutouts. This is similar to
    `get_screen_bounds_top()` except that it avoids display cutouts.

    :rtype: float
    """
    pass    


def get_screen_bounds_safe_top() -> float:
    """
    Returns the top of the screen in virtual coordinates, avoiding any display cutouts. This is similar to
    `get_screen_bounds_top()` except that it avoids display cutouts.

    :rtype: float
    """
    pass    


def get_screen_bounds_top() -> float:
    """
    Returns the top edge of the visible screen.

    This includes any black border area so if there are black borders on the top and bottom of the display then this
    value will be negative. This represents the fact that 0 is the end of the visible area and the start of the black
    border, and the top bound is the end of the black border and the edge of the screen. If there is no black border to
    the top then the top bound will always be 0.

    :rtype: float
    """
    pass    


def get_seconds() -> int:
    """
    Get the number of whole seconds since the app was started.

    Accurate to 1 second.

    Calling this command will internally make a system call to get the amount of time passed, so it may change each time
    you call it.

    :rtype: int
    """
    pass    


def get_shadow_polygons_drawn() -> int:
    """
    Returns the number of polygons drawn by the GPU last frame when constructing shadow maps.

    :rtype: int
    """
    pass    


def get_storage_remaining(path: str) -> int:
    """
    Returns the number of MB available to the app for data storage at the specified path.

    For example using a path that points to a location on the sdcard on Android will return how many MBs can be stored
    there, whereas using a path that points to the AGK write folder will return the number of MB the app can store in
    its internal storage. In some cases these may be the same. This command returns -1 if the space available could not
    be determined. Currently only implemented on iOS and Android, other platforms will return -1.

    :param str path: The path to check.
    :rtype: int
    """
    pass    


def get_storage_total(path: str) -> int:
    """
    Returns the total number of MB of data storage at the specified path, used and unused.

    For example using a path that points to a location on the sdcard on Android will return the size of the sdcard,
    whereas using a path that points to the AGK write folder will return the number of MB in the internal storage. In
    some cases these may be the same. This command returns -1 if the storage size could not be determined. Currently
    only implemented on iOS and Android, other platforms will return -1.

    :param str path: The path to check.
    :rtype: int
    """
    pass    


def get_string_token(text: str, delimiters: str, token: int) -> str:
    """
    Returns a specific token from a string separated by the given delimiters, for example a string containing
    "first:second:third" has three tokens delimited by ":" and "first:second;third" has three tokens separated by the
    delimiters ":;".

    You can have multiple delimiters between each token, for example "first:;second:third" is valid, and has three
    tokens.  You can use `count_string_tokens()` to count the number of tokens in the string. This command is useful for
    separating words in a sentence, which can be delimited by both white space and punctuation.

    :param str text: The string to check.
    :param str delimiters: The set of characters that delimit the string.
    :param int token: The index of the token to return, starting at 1 for the first token.
    :rtype: str
    """
    pass    


def get_string_token2(text: str, delimiter: str, token: int) -> str:
    """
    Returns a specific token from a string separated by the given delimiter, for example a string containing
    "first:second:third" has three tokens delimited by ":".

    Similar to `get_string_token()` except that this command accepts only a single character as the delimiter and
    recognises empty fields. For example "first:second::fourth" has four tokens with the third being an empty string.
    You can use `count_string_tokens2()` to count the number of tokens in the string.

    :param str text: The string to check.
    :param str delimiter: The character that delimits the string.
    :param int token: The index of the token to return, starting at 1 for the first token.
    :rtype: str
    """
    pass    


def get_url_scheme_text() -> str:
    """
    On Android and iOS this returns the full URL that was used to open this app if a URL scheme was used.

    For example if you have set the URL scheme "myapp" for this app and the user clicks on a link such as "myapp:
    sometext", then the OS will open your app and `get_url_scheme_text()` will return "myapp: sometext" until the app is
    next opened. If a URL was not used to open the app, or the platform doesn't support URL schemes, then an empty
    string will be returned.

    When choosing a URL scheme you must make sure it is unique to your app, as iOS will not allow two apps to have the
    same scheme.

    :rtype: str
    """
    pass    


def get_vertices_processed() -> int:
    """
    Returns the number of vertices processed by the GPU last frame.

    :rtype: int
    """
    pass    


def get_view_offset_x() -> float:
    """
    Gets the current view offset in the X direction, set using `set_view_offset()`.

    :rtype: float
    """
    pass    


def get_view_offset_y() -> float:
    """
    Gets the current view offset in the Y direction, set using `set_view_offset()`.

    :rtype: float
    """
    pass    


def get_view_zoom() -> float:
    """
    Gets the current scroll zoom level, set using `set_view_zoom()`.

    :rtype: float
    """
    pass    


def get_virtual_height() -> int:
    """
    Returns the coordinate for the bottom of the screen.

    In the default percentage based coordinate system this is 100. If you have set up a virtual resolution using
    `set_virtual_resolution()` then the height specified here will be returned.

    :rtype: int
    """
    pass    


def get_virtual_width() -> int:
    """
    Returns the coordinate for the far right side of the screen.

    In the default percentage based coordinate system this is 100. If you have set up a virtual resolution using
    `set_virtual_resolution()` then the width specified here will be returned.

    :rtype: int
    """
    pass    


def get_window_height() -> int:
    """
    Returns the height of the current device's window.

    This value may differ from the `get_device_height()` if the window size does not match the pixel size of the
    backbuffer that is being used to draw the window. For example on a Mac with a retina display the window size will be
    half of the pixel size.

    :rtype: int
    """
    pass    


def get_window_width() -> int:
    """
    Returns the width of the current device's window.

    This value may differ from the `get_device_width()` if the window size does not match the pixel size of the
    backbuffer that is being used to draw the window. For example on a Mac with a retina display the window size will be
    half of the pixel size.

    :rtype: int
    """
    pass    


def hex_to_base64(text: str) -> str:
    """
    Converts a hex string to a Base64 string.

    A hex string is a string containing only the characters 0-9 and A-F.

    :param str text: The string to convert.
    :rtype: str
    """
    pass    


def is_dark_theme() -> int:
    """
    On Android and iOS this returns 1 if the operating system is set to use a dark theme, you can use this to switch to
    a dark theme in your app. On other platforms this will always return 0.

    :rtype: int
    """
    pass    


def is_pin_app_available() -> int:
    """
    On Android this will return 1 if the command `pin_app()` is available on this device. Otherwise it will return 0,
    which means that `pin_app()` will have no effect.

    :rtype: int
    """
    pass    


def is_supported_depth_texture() -> bool:
    """
    This command returns True if the current device supports using depth images with `set_render_to_image()`.

    If this returns False then the only valid depth image IDs to `set_render_to_image()` are 0 for no depth, or -1 for a
    normal depth buffer.

    :rtype: bool
    """
    pass    


def make_color(red: int, green: int, blue: int) -> int:
    """
    Creates a compound color value from color components that can then be used with 2D drawing commands.

    :param int red: The red component of the color.
    :param int green: The green component of the color.
    :param int blue: The blue component of the color.
    :rtype: int
    """
    pass    


def maximize_window() -> None:
    """
    Maximizes the window so that it is the largest possible size in the current visible space without going full screen.

    Does nothing on mobile devices.

    :rtype: None
    """
    pass    


def message(value: object) -> None:
    """
    Displays a message box containing the string representation of the given object.

    Your app is not guaranteed to pause whilst the message is displayed.

    :param object value: The value to display.
    :rtype: None
    """
    pass    


def minimize_app() -> None:
    """
    Sends the app to the background.

    On desktop platforms like Windows the app will continue to run when minimized. On Android the app will pause. On iOS
    it will do nothing as a user must minimize the app by pressing the home button. On desktop platforms the window can
    be restored with `restore_app()`.

    :rtype: None
    """
    pass    


def pin_app(enable: int) -> None:
    """
    On Android this will pin the app to the screen to prevent the user accidentally leaving the app. Optionally the
    device can be locked whilst the app is pinned so it must be unlocked to open any other apps, this is defined in the
    device settings. The user will be asked if they want to allow this before it actually takes effect.

    :param int enable: 1 to pin this app, 0 to unpin it.
    :rtype: None
    """
    pass    


def random(minimum: Optional[int] = None, maximum: Optional[int] = None) -> int:
    """
    Generates a random number based on the current seed value.

    The random number generator is built into AGK so a particular seed value will produce the same sequence of numbers
    on every platform. Produces a random number between 0 and 65535.

    :param Optional[int] minimum: The lowest value to return.
    :param Optional[int] maximum: The highest value to return.
    :rtype: int
    """
    pass    


def random2(minimum: Optional[int] = None, maximum: Optional[int] = None) -> int:
    """
    Generates a random number based on the current seed value.

    The random number generator is built into AGK so a particular seed value will produce the same sequence of numbers
    on every platform. Produces a random number between -2,147,483,648 and 2,147,483,647. This generator is slower than
    `random()` but produces better quality randomness over a larger range of values.

    :param Optional[int] minimum: The lowest value to return.
    :param Optional[int] maximum: The highest value to return.
    :rtype: int
    """
    pass    


def random_sign(value: int) -> int:
    """
    Will randomly negate the value given and return it.

    Has a 50-50 chance of negating the value. The initial value can be negative, in which case it will randomly become
    positive.

    :param int value: The value to change.
    :rtype: int
    """
    pass    


def render() -> None:
    """
    Draws all 2D and 3D created using an ID number to the current frame buffer.

    It does not swap the backbuffer to the screen. It does not draw sprites or objects you have created using pointers,
    you will either have to draw them individually or assign them to a sprite manager to batch draw them. In this case
    `render()` should still be called as it also draws the print text. Called automatically by `sync()`, you may either
    use `sync()` or `update()`, `render()`, `swap()` to manually sync. If you wish to have more control you can break
    this down further and replace `render()` with `render_2d_back()`, `clear_depth_buffer()`, `render_3d()`,
    `clear_depth_buffer()`, `render_2d_front()`.

    :rtype: None
    """
    pass    


def render_2d_back() -> None:
    """
    Called automatically.

    This is an advanced command to take control of the render pipeline. Normally `render()` calls `render_2d_back()`,
    `clear_depth_buffer()`, `render_3d()`, `clear_depth_buffer()`, `render_2d_front()` to draw everything in the world.
    This command only draws the 2D sprites and text that are behind the 3D.

    :rtype: None
    """
    pass    


def render_2d_front() -> None:
    """
    Called automatically.

    This is an advanced command to take control of the render pipeline. Normally `render()` calls `render_2d_back()`,
    `clear_depth_buffer()`, `render_3d()`, `clear_depth_buffer()`, `render_2d_front()` to draw everything in the world.
    This command only draws the 2D sprites and text that are in front the 3D.

    :rtype: None
    """
    pass    


def render_3d() -> None:
    """
    Called automatically.

    This is an advanced command to take control of the render pipeline. Normally `render()` calls `render_2d_back()`,
    `render_shadow_map()`, `render_3d()`, `render_2d_front()` to draw everything in the world. This command only draws
    the 3D objects.

    :rtype: None
    """
    pass    


def render_shadow_map() -> None:
    """
    Called automatically.

    This is an advanced command to take control of the render pipeline. Normally `render()` calls `render_2d_back()`,
    `render_shadow_map()`, `render_3d()`, `render_2d_front()` to draw everything in the world. This command only
    calculates the shadow map.

    :rtype: None
    """
    pass    


def replace_string(text: str, find: str, replace: str, qty: int) -> str:
    """
    Returns a string with all instances of "find" replaced with "replace".

    You can use the qty parameter to limit the number of replacements made, or use -1 for no limit. The original string
    is unmodified and a new string is returned with the replacements in it.

    :param str text: The string to modify.
    :param str find: The string to find.
    :param str replace: The string to replace it with.
    :param int qty: The maximum number of replacements to make, use -1 for no limit.
    :rtype: str
    """
    pass    


def reset_timer() -> None:
    """
    Resets the time returned from `timer()` to 0.

    This allows the full accuracy to be regained after your app has been running for some time.

    This also resets the values returned by `get_seconds()` and `get_milliseconds()` to 0.

    :rtype: None
    """
    pass    


def restore_app() -> None:
    """
    Restores the app from a minimized state to a normal window.

    :rtype: None
    """
    pass    


def run_app(filename: str, parameters: Optional[str] = None) -> int:
    """
    Runs an external executable that is independent of this app.

    It will return an ID that you can use to check if the app is still running or in extreme cases to terminate the app.
    If this fails it will return 0. Currently only works on Windows, Mac, Linux, and Raspberry Pi.

    :param str filename: The filename of the new app, this is accessed just like any other file in AGK.
    :param Optional[str] parameters: Optional command line parameters to pass to the app, or an empty string.
    :rtype: int
    """
    pass    


def screen_fps() -> float:
    """
    Returns an average frames per second based on the rendering time of the last few frames.

    To get the exact time spent on the last frame you can call `get_frame_time()`.

    :rtype: float
    """
    pass    


def screen_to_world_x(x: Union[float, int]) -> float:
    """
    Converts a screen X coordinate into a world X coordinate based on the current view offset and zoom.

    When the `set_view_offset()` is 0,0 and the `set_view_zoom()` is 1.0 world and screen coordinates are the same. For
    example when the view is offset by 20 pixels to the right, input at 0,0 on the screen will appear 20,0 in the world.

    :param Union[float, int] x: The screen X coordinate to convert.
    :rtype: float
    """
    pass    


def screen_to_world_y(y: Union[float, int]) -> float:
    """
    Converts a screen Y coordinate into a world Y coordinate based on the current view offset and zoom.

    When the `set_view_offset()` is 0,0 and the `set_view_zoom()` is 1.0 world and screen coordinates are the same. For
    example when the view is offset by 20 pixels down, input at 0,0 on the screen will appear 0,20 in the world.

    :param Union[float, int] y: The screen Y coordinate to convert.
    :rtype: float
    """
    pass    


def set_antialias_mode(mode: int) -> None:
    """
    Sets whether the device should use anti-aliasing when rendering to the back buffer.

    Currently this only applies to Windows, Mac, and Linux, and only 4x multi-sampling is available. This does not apply
    to any objects drawn to an image with `set_render_to_image()`, only the back buffer is anti-aliased.

    :param int mode: 0 (AA_NONE)=off, 1 (AA_4XMSAA)=4x multisample anti-aliasing.
    :rtype: None
    """
    pass    


def set_border_color(red: int, green: int, blue: int) -> None:
    """
    Sets the color or any borders used when the display does not fit the aspect ratio exactly.

    If this color is different from the clear color than an additional clear operation is performed and may affect
    performance if fill rate is an issue.

    :param int red: The red component of the border color.
    :param int green: The green component of the border color.
    :param int blue: The blue component of the border color.
    :rtype: None
    """
    pass    


def set_clear_color(red: int, green: int, blue: int) -> None:
    """
    Sets the clear color to use when clearing the back buffer.

    :param int red: The red component of the clear color.
    :param int green: The green component of the clear color.
    :param int blue: The blue component of the clear color.
    :rtype: None
    """
    pass    


def set_default_mag_filter(mode: int) -> None:
    """
    Sets the default magnification filter for textures when the texture is larger than the screen space it is displayed
    in.

    You can use a mode of 0 (FILTER_NEAREST) to use the nearest pixel, which will appear blocky, or 1 (FILTER_LINEAR) to
    use a linear filter which will look blurry. When the image matches the screen space exactly then both filters will
    look the same when there is a slight difference, nearest tends to be sharper, but may flicker as it changes pixel
    choice. You can set this value per image using `set_image_mag_filter()`.

    :param int mode: The filter mode to use 0 (FILTER_NEAREST)=nearest, 1 (FILTER_LINEAR)=linear.
    :rtype: None
    """
    pass    


def set_default_min_filter(mode: int) -> None:
    """
    Sets the default minification filter for textures when the texture is smaller than the screen space it is displayed
    in.

    You can use a mode of 0 (FILTER_NEAREST) to use the nearest pixel, which will appear blocky, or 1 (FILTER_LINEAR) to
    use a linear filter which will look blurry. When the image matches the screen space exactly then both filters will
    look the same when there is a slight difference, nearest tends to be sharper, but may flicker as it changes pixel
    choice. You can set this value per image using `set_image_min_filter()`.

    :param int mode: The filter mode to use 0 (FILTER_NEAREST)=nearest, 1 (FILTER_LINEAR)=linear.
    :rtype: None
    """
    pass    


def set_default_wrap_u(mode: int) -> None:
    """
    Sets the default texture wrapping for images where the UV coordinates go beyond the range 0 to 1 in the U direction.

    :param int mode: The wrapping mode to use 0 (WRAP_CLAMP)=clamp, 1 (WRAP_REPEAT)=repeat.
    :rtype: None
    """
    pass    


def set_default_wrap_v(mode: int) -> None:
    """
    Sets the default texture wrapping for images where the UV coordinates go beyond the range 0 to 1 in the V direction.

    :param int mode: The wrapping mode to use 0 (WRAP_CLAMP)=clamp, 1 (WRAP_REPEAT)=repeat.
    :rtype: None
    """
    pass    


def set_display_aspect(aspect: Union[float, int]) -> None:
    """
    This command is used in conjunction with the default percentage based positioning system in AGK.

    If using this approach you will need to specify a display aspect, so that AGK knows how to correctly display
    entities on screen. If your artwork was originally designed for a resolution of 1024 x 768, this would result in an
    aspect ratio of 4:3, which is also the same as saying 1024 / 768 = 1.33, therefore you would call
    `set_display_aspect()` and pass in a 1.33 as your aspect ratio. On platforms where the resolution was different AGK
    will take care of things internally so that your application still maintains this aspect ratio and looks correct.

    The alternative approach is to call `set_virtual_resolution()` to control the coordinate system and place sprites
    using screen coordinates instead of using percentages, in which case you should not call this command.

    If sprites already exist when this is called they will become distorted. If the aspect ratio given does not fit
    exactly on the current device, black borders will be drawn around the rendering area to center it on screen.

    Use an aspect ratio of 0 to use the current coordinate system as the aspect ratio.

    Use an aspect ratio of -1 to use the device aspect ratio (fills the whole screen without black borders, but will
    cause stretching and look different on every device) An alternative method of filling the screen which avoids this
    problem is to use `set_scissor()` with the values 0,0,0,0.

    :param Union[float, int] aspect: The aspect ratio to use from now on, in the form of width/height.
    :rtype: None
    """
    pass    


def set_expansion_file_key(key: str) -> None:
    """
    Sets the public key to use in the other expansion file commands.

    Currently only applicable to Android. The public key can be found in the Google Play Developer Console and is
    different for each app. Click on the app and then click on the Services and APIs section, it is the long string that
    starts MIIB.

    :param str key: The public key to use when checking for and downloading an expansion file.
    :rtype: None
    """
    pass    


def set_expansion_file_version(version: int) -> None:
    """
    Sets the version number to use in the other expansion file commands.

    Currently only applicable to Android. The version number of the expansion file is determined by the version number
    of the APK that was uploaded with it. For example the APK may be updated to a new version number but the expansion
    file could still be the original version number.

    :param int version: The version number to use when checking for and downloading an expansion file.
    :rtype: None
    """
    pass    


def set_generate_mipmaps(enabled: Union[bool, int]) -> None:
    """
    Sets whether loaded images having mipmaps generated and used.

    Should be called before any images are loaded. May be changed before another image is loaded to make some use
    mipmaps and others not.

    :param Union[bool, int] enabled: True to generate mipmaps (default is False).
    :rtype: None
    """
    pass    


def set_immersive_mode(active: Union[bool, int]) -> None:
    """
    Removes any on screen controls that may have been placed on screen by the OS, for example the home and back buttons,
    allowing your app to use the entire screen.

    Your app may be resized after calling this command so if you have used `get_device_width()` or `get_device_height()`
    you should wait a few frames then call them again to get the new values. The values may not change immediately after
    calling this command as it takes some time for the navigation bar to change. Sometimes the OS will turn off
    immersive mode without warning, for example if the volume buttons are pressed. When this happens your app will
    return to its non-immersive mode size to prevent any part of the app being hidden by the nav bar, which could make
    some parts of the app inaccessible to touch events. You can detect this change by checking `get_device_width()` and
    `get_device_height()` at regular intervals, and use `set_immersive_mode()` again to request a return to immersive
    mode.

    Currently this only applies to Android devices running 4.4 (API 19) or higher. On other platforms this command does
    nothing.

    :param Union[bool, int] active: True to turn on immersive mode, False to turn it off.
    :rtype: None
    """
    pass    


def set_orientation_allowed(portrait1: Union[bool, int], portrait2: Union[bool, int],
                            landscape1: Union[bool, int], landscape2: Union[bool, int]) -> None:
    """
    Sets which orientations the AGK will allow the app to rotate to.

    There are two portrait and two landscape orientations, one for the right way up and the other for upside down. On
    platforms that can't rotate, like Windows or Mac, this command has no effect and the app will always be drawn right
    way up.

    A value of 1 for each orientation will determine if the app will rotate when the device is held in that orientation.
    A value of 0 will keep the app at its last valid orientation.

    Note that if the device is currently in a disallowed orientation then AGK will attempt to rotate the device into an
    allowed orientation, however this is not guaranteed to happen immediately. So, for example, if you need the device
    to be in landscape and you call this command with only landscape allowed, you should then wait for
    `get_device_width()` to return greater than `get_device_height()` which will signal that the device is now in
    landscape.

    :param Union[bool, int] portrait1: The default device orientation.
    :param Union[bool, int] portrait2: The upside down portrait orientation.
    :param Union[bool, int] landscape1: The landscape orientation when the device is rotated left from its default
        position.
    :param Union[bool, int] landscape2: The landscape orientation when the device is rotated right from its default
        position.
    :rtype: None
    """
    pass    


def set_random_seed(seed: int) -> None:
    """
    Sets the seed for the random number generator.

    Two AGK applications using the same seed value will generate the same sequence of random numbers. By default the
    seed is set to the current time on startup so that each run of the application will generate a different sequence of
    numbers.

    :param int seed: The seed value, between 1 and 2^32.
    :rtype: None
    """
    pass    


def set_random_seed2(seed: int) -> None:
    """
    Sets the seed for the random number generator.

    Two AGK applications using the same seed value will generate the same sequence of random numbers. By default the
    seed is set to the current time on startup so that each run of the application will generate a different sequence of
    numbers.

    :param int seed: The seed value, between 1 and 2^32.
    :rtype: None
    """
    pass    


def set_render_to_image(color_image: int, depth_image: int) -> None:
    """
    Redirects all future draw calls to an image instead of to the screen.

    The specified image could then be applied to an object or sprite. Be careful not to apply to an object or sprite at
    the same time as it is being drawn to as this could result in an error. You can also choose to render the depth
    information to an image that you can use later, or render without a depth buffer if your scene does not need one.
    You can also use a depth image ID of -1 to render a depth buffer without capturing it in an image. Note that some
    devices (particularly Android) do not support rendering depth to an image, in these cases the only valid values for
    the depth ID are 0 and -1. You can check if the current device supports depth textures by using
    `is_supported_depth_texture()`. Render images can be any size, and do not need to be a power of 2 in width or
    height.

    For a more detailed explanation, when you render to an image it will draw to the image exactly what it would have
    drawn to the screen. For example if your virtual resolution is 1024x768 and requires borders then it will draw
    borders onto the render image. This means if you were to look at the resulting render image in its native form, e.g.
    1024x1024, it will look like you've taken a 1024x768 window and stretched it vertically into a square. The result is
    that if you take this square image and stretch it back into 1024x768, by texturing a sprite or quad that happens to
    be 1024x768 in size, then it will look normal again. This means you can render a 1024x768 window to an image of any
    size, say 64x512, and stretch it to 1024x768 and it should look correct aspect ratio wise, it will of course be
    missing some detail. You can then get more advanced by changing the virtual resolution after setting a render image
    and changing it back when rendering to the screen, or using `set_camera_aspect()` to change the 3D aspect ratio if
    the render image is going to be used for something other than a 1:1 representation of the screen.

    When rendering to an image it is very important that the image be cleared with `clear_screen()` before drawing a new
    scene to it. This is so the GPU knows it can discard the previous contents. If the image is not cleared and things
    keep getting drawn to it then performance on some GPUs will degrade over time.

    :param int color_image: The ID of the image to use as the color buffer, 0 to not render color.
    :param int depth_image: The ID of the image to use as the depth buffer, 0 to not render depth, -1 to use a depth
        buffer without an image.
    :rtype: None
    """
    pass    


def set_render_to_screen() -> None:
    """
    This command sets the render pipeline to output any future draw calls to the screen.

    This is the default mode so you only need to call this if you have previously redirected drawing to an image with
    `set_render_to_image()`.

    :rtype: None
    """
    pass    


def set_resolution_mode(mode: int) -> None:
    """
    Some platforms have high resolution screens such as the iPad, this function determines how those platforms display
    their content.

    You have the choice of mode=1 (RESOLUTION_MODE_HIGH) which will use a full resolution frame buffer that will look
    better, or mode=0 (RESOLUTION_MODE_LOW) that will use a smaller resolution frame buffer (usually half sized) which
    is then scaled to fit the screen, and will run faster. This does not affect low resolution devices that will always
    use a low resolution frame buffer.

    :param int mode: 1 (RESOLUTION_MODE_HIGH) to use a high (native) resolution, 0 (RESOLUTION_MODE_LOW) to use a low
        (scaled) resolution.
    :rtype: None
    """
    pass    


def set_scissor(x1: Union[float, int], y1: Union[float, int], x2: Union[float, int],
                y2: Union[float, int]) -> None:
    """
    The function sets the area of the screen that will be drawn to in subsequent `sync()` or `render()` commands.

    The area is defined by two points representing the top left and bottom right corners of a rectangle which will be
    the new drawing area. By default this is set to your virtual resolution so anything placed outside this resolution
    is not be visible. Using `set_scissor(0, 0, 0, 0)` is a special case that will turn off all clipping and make the
    full screen usable for displaying things. This can be useful when making an app that works across varying aspect
    ratios. For example using a virtual resolution of 1024x768 on a device with a 1280x800 screen would fit the 1024x768
    area as closely as possible in the center of the screen, with black borders either side. `set_scissor(0, 0, 0, 0)`
    places the 1024x768 area in the same place, but there are no black borders, so placing something at a negative X
    position would still be visible for as long as the screen can still fit it in. Whereas placing something at a
    negative position on a device with a 1024x768 screen (which fits your virtual resolution perfectly), would make that
    item disappear off the edge of the screen. You can use this with the commands `get_screen_bounds_left()`,
    `get_screen_bounds_right()`, `get_screen_bounds_top()`, and `get_screen_bounds_bottom()` to find the actual edge of
    the screen in your chosen resolution. This allows you to place items at the edge of the screen on all devices
    regardless of its aspect ratio.

    :param Union[float, int] x1: The x component of the first coordinate.
    :param Union[float, int] y1: The y component of the first coordinate.
    :param Union[float, int] x2: The x component of the second coordinate.
    :param Union[float, int] y2: The y component of the second coordinate.
    :rtype: None
    """
    pass    


def set_screen_resolution(width: int, height: int) -> None:
    """
    Sets the resolution of the backbuffer where possible.

    If your chosen resolution is greater than the device can display than the device will use its highest possible
    resolution, you can use `get_device_width()` and `get_device_height()` to find out what was used. On mobile devices
    using a screen resolution with a different aspect ratio than the device will result in stretching. You can check the
    aspect ratio of the device with `get_max_device_width()` and `get_max_device_height()`. It is not recommended that
    you allow both portrait and landscape orientations when using this command as AGK cannot prevent stretching without
    undoing your desired screen resolution so it will not do so. If you want all orientations without stretching you
    will need to monitor `get_max_device_width()` and `get_max_device_height()` for changes and set an appropriate
    replacement resolution with `set_screen_resolution()` to match the new aspect ratio. Using a resolution of 0 in
    either direction will reset the screen resolution to the maximum resolution supported on the device. Note that on
    Windows and Mac the backbuffer size is changed by modifying the size of the window, so it will overwrite any
    settings from `set_window_size()`. This may not be the case in the future and AGK may be able to have separate
    window sizes and backbuffer sizes in a future version.

    :param int width: The desired width of the screen in pixels.
    :param int height: The desired height of the screen in pixels.
    :rtype: None
    """
    pass    


def set_sleep_mode(enabled: Union[bool, int]) -> None:
    """
    Sets whether the device should sleep when your app is idle.

    By default this is turned off, but if activated it will use the device settings to determine how long it should idle
    before sleeping.

    :param Union[bool, int] enabled: True to enable sleep mode, False to turn it off (default).
    :rtype: None
    """
    pass    


def set_sort_created(enabled: Union[bool, int]) -> None:
    """
    If two sprites occupy the same depth then the order they are drawn is undefined unless this function is set to 1, in
    which case sprites at the same depth will be drawn in the order they were created.

    For maximum performance it is recommended that every sprite has its own depth value with this command set to 0. If
    the order they are drawn is not important, for example physics sprites that won't normally overlap, then you can use
    sprites at the same depth without setting this command to 1.

    :param Union[bool, int] enabled: Set to True to sort sprites that have the same depth by the order they were
        created, False to turn it off.
    :rtype: None
    """
    pass    


def set_sync_rate(fps: Union[float, int], mode: int) -> None:
    """
    Sets the desired rate that frames will be drawn to the screen, in frames per second (fps).

    Additionally there are two modes to choose from that can limit the CPU, the first (mode=0) sleeps the application
    between frames to save CPU and battery life where possible. The second (mode=1) uses a continuous loop to check the
    time before the next frame, which can be more accurate but hogs the CPU.

    The preferred method of limiting frame rate is `set_vsync()` which set the refresh rate to the monitor refresh rate,
    and will prevent any screen tearing or stuttering. Using `set_sync_rate()` will automatically turn VSync off since
    the two commands would fight each other for control of the frame rate.

    Use an fps of 0 to remove all limits and draw frames as quickly as possible. This may be up to thousands of frames
    per second on the most powerful graphics cards.

    Note that on HTML5 the use of `set_sync_rate()` is highly discouraged as it uses the Javascript SetTimeout function
    for timing, which can cause inaccurate frame rates and stuttering. On HTML5 the preferred method of frame rate
    control is `set_vsync()`.

    :param Union[float, int] fps: The desired frame rate in frames per second, 0 for unlimited.
    :param int mode: 1 to use a possibly more accurate but CPU intensive method, 0 (default) to save CPU and battery.
    :rtype: None
    """
    pass    


def setup_noise(frequency: Union[float, int], amplitude: Union[float, int], lacunarity: Union[float,
                int], persistence: Union[float, int]) -> None:
    """
    Initialises Open Simplex noise generation.

    :param Union[float, int] frequency: Frequency (width) of the first octave of noise e.g. 1.0.
    :param Union[float, int] amplitude: Amplitude (height) of the first octave of noise e.g. 1.0.
    :param Union[float, int] lacunarity: Lacunarity specifies the frequency multiplier between successive octaves e.g.
        2.0.
    :param Union[float, int] persistence: Persistence is the loss of amplitude between successive octaves (usually
        1/lacunarity).
    :rtype: None
    """
    pass    


def set_view_offset(x: Union[float, int], y: Union[float, int]) -> None:
    """
    Offset the screen viewport relative to the world, for example a view offset of 0,20 will move the screen down by 20
    pixels showing any sprite that was previously positioned just off the bottom of the screen.

    This can be useful for scrolling games where you want to move the view across a level.

    Using this command will automatically disable the four physics walls surrounding the screen.

    You can also fix sprites to the screen so that they move along with it by using `fix_sprite_to_screen()`.

    The view offset values position the top left corner of the view in the world, while `set_view_zoom()` determines how
    much of the world the view can see.

    :param Union[float, int] x: The x offset for the view.
    :param Union[float, int] y: The y offset for the view.
    :rtype: None
    """
    pass    


def set_view_zoom(zoom: Union[float, int]) -> None:
    """
    Zooms the screen viewport relative to the world, for example a view zoom of 2.0 will double the size of anything
    currently in view.

    A value of 1.0 returns everything to normal size.

    Using this command will automatically disable the four physics walls surrounding the screen.

    You can also fix sprites to the screen so that they do not change size by using `fix_sprite_to_screen()`.

    This command can either zoom towards the view's top left corner or towards the view's center, see
    `set_view_zoom_mode()` for details.

    :param Union[float, int] zoom: The zoom level for scrolling sprites.
    :rtype: None
    """
    pass    


def set_view_zoom_mode(mode: int) -> None:
    """
    Sets the zoom mode from top left corner or centered.

    By default the view zooms from its top left corner, maintaining the views offset in world coordinates. For example a
    view with an offset of 20,20 will maintain its top left corner at 20,20 in world coordinates no matter what zoom
    value is given. However, centered zoom keeps the center of the view stationary whilst scaling everything else around
    it, making the offset value more difficult to judge. In this mode the top left corner will only be at 20,20 when the
    zoom value is 1.0, for other zoom values the top left corner will be scaled away from the offset point. For example,
    assume a world size of 100,100 units, a zoom level of 1.0, and a view offset of 0,0. The view will be displaying
    world coordinates 0,0 (its top left corner) to 100,100 (at its bottom right corner), with a zoom value of 2.0 and
    top left zooming the view will now show world coordinates 0,0 to 50,50 in the same space making everything look
    bigger. In centered zooming the view would instead show 25,25 to 75,75 maintaining the center of the view over the
    point 50,50 in world coordinates.

    :param int mode: 0 (ZOOM_TOP_LEFT)=top left, 1 (ZOOM_CENTER)=centered.
    :rtype: None
    """
    pass    


def set_virtual_resolution(width: int, height: int) -> None:
    """
    The default approach for the coordinate system in AGK is to use a percentage based system where 0,0 represents the
    top left corner and 100,100 the bottom right.

    The alternative approach is to treat the platform with a fixed resolution e.g. 320 x 480. Any platforms that don't
    match this resolution will be scaled to fit as much as possible with black borders where necessary.

    :param int width: The number of units to use across the width of the rendering area.
    :param int height: The number of units to use across the height of the rendering area.
    :rtype: None
    """
    pass    


def set_vsync(mode: int) -> None:
    """
    Sets whether vertical sync should be turned on or off.

    This is the preferred method of limiting the frame rate as it will link the frame rate to the monitor refresh rate
    and avoid tearing or stuttering. Using this command with mode 1 will override any currently set refresh rate from
    `set_sync_rate()`, otherwise these two commands would fight each other for control of the frame rate, instead AGK
    will use the VSync refresh rate which is typically 60 frames per second, but depends on the monitor.

    On Linux, Mac, and HTML5 you can use a value greater than 1 to skip refreshes, for example if the monitor refresh
    rate is 60Hz then a mode value of 1 would limit the app to 60fps, but a mode value of 2 would skip every other
    refresh which would limit the app to 30fps.

    :param int mode: 1 to turn vsync on, 0 to turn it off, > 1 to skip refreshes (Linux, Mac, and HTML5 only).
    :rtype: None
    """
    pass    


def set_window_allow_resize(enabled: Union[bool, int]) -> None:
    """
    This sets the window sets whether the user is allowed to resize the window, by default this is set to 0.

    :param Union[bool, int] enabled: False to disable resizing, True to allow resizing.
    :rtype: None
    """
    pass    


def set_window_position(x: int, y: int) -> None:
    """
    This sets the window position for platforms that support it, such as Windows and Mac.

    If the window is currently full screen then this will have no affect. This will not affect mobile devices.

    :param int x: The desired X position of the window in pixels.
    :param int y: The desired Y position of the window in pixels.
    :rtype: None
    """
    pass    


def set_window_size(width: int, height: int, fullscreen: Union[bool, int],
                    allow_oversized: Optional[Union[bool, int]] = False) -> None:
    """
    This sets the window size for platforms that support it, such as Windows and Mac.

    This will not affect mobile devices. In fullscreen mode the width and height will be ignored and the desktop
    resolution will be used.

    By default the window size will be adjusted so it always fits on screen, including making room for the taskbar on
    Windows. This means that your final window size may be slightly smaller than your chosen size. You can override this
    by setting the `allow_oversized` parameter to True, which will remove all bounds checks and allow you to create
    windows larger than the current screen. When the fullscreen parameter is set to True then the `allow_oversized`
    parameter has no effect.

    :param int width: The desired width of the window in pixels.
    :param int height: The desired height of the window in pixels.
    :param Union[bool, int] fullscreen: True to use a full screen mode, False for a normal window.
    :param Optional[Union[bool, int]] allow_oversized: True to allow the window size to exceed the visible screen, False
        to shrink it to fit where necessary.
    :rtype: None
    """
    pass    


def set_window_title(title: str) -> None:
    """
    Sets the window title for those platforms that run in a window (e.g. Windows, Mac).

    :param str title: The text to use for the window title.
    :rtype: None
    """
    pass    


def sha1(text: str) -> str:
    """
    Hashes a string using the SHA1 algorithm to produce a 40 character hexadecimal string.

    This is a one way hash function that can be used with salting (appending a secret string) for passwords or tamper
    detection in parameters passed to a server.

    :param str text: The string to hash.
    :rtype: str
    """
    pass    


def sha256(text: str) -> str:
    """
    Hashes a string using the SHA256 algorithm to produce a 32 character hexadecimal string.

    This is a one way hash function that can be used with salting (appending a secret string) for passwords or tamper
    detection in parameters passed to a server.

    :param str text: The string to hash.
    :rtype: str
    """
    pass    


def sha512(text: str) -> str:
    """
    Hashes a string using the SHA512 algorithm to produce a 64 character hexadecimal string.

    This is a one way hash function that can be used with salting (appending a secret string) for passwords or tamper
    detection in parameters passed to a server.

    :param str text: The string to hash.
    :rtype: str
    """
    pass    


def share_file(filename: str) -> None:
    """
    Sends the given file to the operating system which will then ask the user how they want to share it, e.g.

    through email, NFC, etc. The file can be in your read or write folder, or you can use a "raw:" path to load from
    anywhere, you should provide the filename as if you were loading the file. This only works on iOS and Android.

    :param str filename: The path to the file to share
    :rtype: None
    """
    pass    


def share_image(filename: str) -> None:
    """
    Sends the given image to the operating system which will then ask the user how they want to share the image, e.g.
    through Facebook, Twitter, etc.

    The file should be in your read or write folder, or you can use a "raw:" path to load from anywhere, you should
    provide the filename as if you were loading the file. This only works on iOS and Android.

    :param str filename: The filename of the image to share.
    :rtype: None
    """
    pass    


def share_image_and_text(filename: str, text: str) -> None:
    """
    Sends the given image and text to the operating system which will then ask the user how they want to share the text,
    e.g. through Facebook, Twitter, etc.

    The image file should be in your read or write folder, or you can use a "raw:" path to load from anywhere, you
    should provide the filename as if you were loading the file. This only works on iOS and Android.

    :param str filename: The filename of the image to share.
    :param str text: The text to share.
    :rtype: None
    """
    pass    


def share_text(text: str) -> None:
    """
    Sends the given text to the operating system which will then ask the user how they want to share the text, e.g.
    through Facebook, Twitter, etc.

    This only works on iOS and Android.

    :param str text: The text to share.
    :rtype: None
    """
    pass    


def sin(a: Union[float, int]) -> float:
    """
    Returns the sine of a value in degrees.

    :param Union[float, int] a: The value to pass into the sine function.
    :rtype: float
    """
    pass    


def sin_rad(a: Union[float, int]) -> float:
    """
    Returns the sine of a value in radians.

    :param Union[float, int] a: The value to pass into the sine function.
    :rtype: float
    """
    pass    


def sleep(milliseconds: int) -> None:
    """
    Suspend the app for a specified number of milliseconds.

    It is not recommended that you use this command to suspend an app for more than the time of one frame (roughly 17
    milliseconds).

    :param int milliseconds: The number of milliseconds to sleep.
    :rtype: None
    """
    pass    


def sqrt(value: Union[float, int]) -> float:
    """
    Returns the square root of a float value.

    :param Union[float, int] value: The value to square root.
    :rtype: float
    """
    pass    


def step_physics(time: Union[float, int]) -> None:
    """
    Steps the physics simulation by a defined amount of time.

    This time value is in seconds and may include fractions of seconds. Stepping the physics simulation by a large time
    value (greater than say 0.1) may result in undefined behaviour and physics objects moving through each other. It is
    not required that you call this command in your game loop, if you do not call it, `sync()` or `update()` will call
    it for you with the last frame time to allow the physics simulation to catch up in real time. If you do call
    `step_physics()` then it will not be called for you by `sync()` or `update()` for that frame, this allows you to do
    your own physics timing if you prefer.

    By using a fixed time step every frame your physics will perform exactly the same across all devices and all frame
    rates, but a reduction in fps will result in the physics appearing to go slower, as it will always step the same
    amount of time whether the frame was quick or slow to draw. Using a variable step for each frame will keep physics
    moving at the same speed regardless of frame rate, but it will no longer be deterministic across devices and
    different frame rates. For example if your game depends on a physics entity falling and bouncing to the same height
    each time it is run then you should use a fixed time step. If the position of physics objects is not important to
    you game logic then a variable time step may be best.

    :param Union[float, int] time: The step time in seconds.
    :rtype: None
    """
    pass    


def string_to_base64(text: str) -> str:
    """
    Converts a UTF-8 string to a Base64 string.

    :param str text: The string to convert.
    :rtype: str
    """
    pass    


def strip_string(text: str, chars: str) -> str:
    """
    Returns a string with all characters in "chars" removed from it.

    The original string is unmodified and a new string is returned with the characters removed. For example
    `strip_string("my string", "yn")` would return "m strig".

    :param str text: The string to modify.
    :param str chars: The characters to remove.
    :rtype: str
    """
    pass    


def swap() -> None:
    """
    Displays the back buffer to the screen and clears the backbuffer for the next frame, updates global time variables.

    Called automatically by `sync()`, you may either use `sync()` or `update()`, `render()`, `swap()` one after the
    other to manually sync.

    :rtype: None
    """
    pass    


def sync() -> None:
    """
    Updates the scene with the latest information, draws all sprites, updates global objects, and swaps the backbuffer
    into view.

    :rtype: None
    """
    pass    


def tan(a: Union[float, int]) -> float:
    """
    Returns the tangent of a value in degrees.

    :param Union[float, int] a: The value to pass into the tangent function.
    :rtype: float
    """
    pass    


def tan_rad(a: Union[float, int]) -> float:
    """
    Returns the tangent of a value in radians.

    :param Union[float, int] a: The value to pass into the tangent function.
    :rtype: float
    """
    pass    


def terminate_app(app_id: int) -> None:
    """
    Immediately terminates the specified app.

    This should only be used in extreme cases as the app is not given a chance to clean up or finish what it is doing.

    :param int app_id: The app ID to terminate, returned from `run_app()`.
    :rtype: None
    """
    pass    


def timer() -> float:
    """
    Get the number of seconds and fractions of seconds since the app was started.

    Accurate to milliseconds, but due to floating point inaccuracies the longer the app is running the less accurate
    this becomes. More specifically the time value has about 7 significant figures of accuracy, so as the number of
    seconds gets higher the number of decimal places decreases. If you only need the time to the nearest second then
    this value will be fine up to about 16,000,000 seconds.

    Calling this command will internally make a system call to get the amount of time passed, so it will change every
    time you call it.

    :rtype: float
    """
    pass    


def trim_string(text: str, chars: str) -> str:
    """
    Returns a string with all characters in "chars" removed from the ends of the string.

    The original string is unmodified and a new string is returned with the characters removed. This can be used to
    remove extra whitespace from the ends of an input string.

    :param str text: The string to modify.
    :param str chars: The characters to remove.
    :rtype: str
    """
    pass    


def trunc(value: Union[float, int]) -> int:
    """
    Returns the integer part of a float value with no rounding either way.

    :param Union[float, int] value: The value to truncate.
    :rtype: int
    """
    pass    


def truncate_string(text: str, character: str) -> str:
    """
    Returns a string with all characters removed after a given character.

    The original string is unmodified and a new string is returned with the characters removed. This searches backwards
    from the end of the string to the beginning and at the first occurrence of the character removes it and everything
    after it.

    :param str text: The string to modify.
    :param str character: The character to look for, must be a single character.
    :rtype: str
    """
    pass    


def update(time: Union[float, int]) -> None:
    """
    Updates all 2D and 3D objects based on the given time, animation, physics, etc.

    If time is 0 it uses the last frame time to step the simulation. If you have already called `step_physics()` this
    frame it will not be called again for this frame.

    Called automatically by `sync()`, you may either use `sync()` or `update()`, `render()`, `swap()` to manually sync.
    If you wish to have more control you can break this down further by replacing `update()` with `update_2d()`,
    `update_3d()`.

    :param Union[float, int] time: The time in seconds to move everything along. Can be fractions of seconds.
    :rtype: None
    """
    pass    


def update_2d(time: Union[float, int]) -> None:
    """
    Called automatically.

    This is an advanced command to take control of the update process. Normally `update()` calls this and `update_3d()`
    to update everything in the world. This command only updates the 2D objects such as sprites and text.

    :param Union[float, int] time: The time in seconds to move everything along. Can be fractions of seconds.
    :rtype: None
    """
    pass    


def update_3d(time: Union[float, int]) -> None:
    """
    Called automatically.

    This is an advanced command to take control of the update process. Normally `update()` calls this and `update_2d()`
    to update everything in the world. This command only updates the 3D objects such as 3D models.

    :param Union[float, int] time: The time in seconds to move everything along. Can be fractions of seconds.
    :rtype: None
    """
    pass    


def update_device_size(width: int, height: int) -> None:
    """
    If for any reason the device dimensions may have changed (e.g. a change in orientation rotates the viewspace to a
    new size) call this function to update the internal values.

    :param int width: The new width.
    :param int height: The new height.
    :rtype: None
    """
    pass    


def view_file(filename: str) -> None:
    """
    Opens the given file in an the external application suitable for its file type.

    Typically this is a default app chosen by the user. The file should be in your read or write folder, you should
    provide the filename as if you were loading the file. Currently this only works on Windows, iOS, and Android.

    :param str filename: The path to the file to open.
    :rtype: None
    """
    pass    


def world_to_screen_x(x: Union[float, int]) -> float:
    """
    Converts a world X coordinate into a screen X coordinate based on the current view offset and zoom.

    When the `set_view_offset()` is 0,0 and the `set_view_zoom()` is 1.0 world and screen coordinates are the same. For
    example when the view is offset by 20 pixels to the right, an object at 0,0 in the world will appear at -20 (off
    screen) to the left.

    :param Union[float, int] x: The world X coordinate to convert.
    :rtype: float
    """
    pass    


def world_to_screen_y(y: Union[float, int]) -> float:
    """
    Converts a world Y coordinate into a screen Y coordinate based on the current view offset and zoom.

    When the `set_view_offset()` is 0,0 and the `set_view_zoom()` is 1.0 world and screen coordinates are the same. For
    example when the view is offset by 20 pixels down, an object at 0,0 in the world will appear at -20 (off screen)
    above the screen.

    :param Union[float, int] y: The world Y coordinate to convert.
    :rtype: float
    """
    pass    


def get_error_mode() -> int:
    """
    Returns the current error mode for AGK. 0=ignore, 1=report, 2=stop.

    :rtype: int
    """
    pass    


def get_error_occurred() -> bool:
    """
    Returns True if an error occurred since the last call to this command, False if not.

    This does not include warnings.

    :rtype: bool
    """
    pass    


def get_last_error() -> str:
    """
    Returns a string describing the last error that occurred.

    This function will continue to return the same string until another error occurs. This does not include warnings.

    :rtype: str
    """
    pass    


def log(value: object) -> None:
    """
    Displays the specified text to the appropriate device log or output window.

    Call enable_debug_log first to allow this command to output.

    :param object value: The value to send to the log/output area.
    :rtype: None
    """
    pass    


def set_error_mode(mode: int) -> None:
    """
    Sets the error mode for the AGK from ignore, report, or stop from AGK commands, e.g. sprite ID doesn't exist in a
    command that accepts a sprite ID.

    Ignoring will make the AGK attempt to carry on, ignoring the entire command if necessary. Reporting will make the
    AGK report the error to an appropriate debug console and carry on. Stop will force the AGK to report the error as
    before and then stop by throwing an exception, which must be caught or the app will terminate.

    :param int mode: 0 (ERROR_MODE_IGNORE)=ignore, 1 (ERROR_MODE_REPORT)=report, 2 (ERROR_MODE_STOP)=stop.
    :rtype: None
    """
    pass    


def activate_smart_watch(reserved: Optional[str] = None) -> None:
    """
    Attempts to connect to the smart watch connected to the current device.

    It will attempt to maintain that connection for the life of the app, for example if the watch is unpaired and then
    repaired then your app will reconnect to the watch automatically. So you only need to call this command once at the
    beginning of your app.

    Currently only works on iOS. To create a watch app you will need to use the Tier 2 project interpreter_ios and add a
    watch app to it.

    :param Optional[str] reserved: Reserved for future use, must be an empty string.
    :rtype: None
    """
    pass    


def ar_control_camera() -> None:
    """
    This is an optional command that will reset the camera to the AR assigned values.

    This could be useful if you change the camera position or rotation but then want to know the AR values for these
    settings. You do not need to call this command as the values will be reset to the AR values by `render()` or
    `sync()` anyway.

    :rtype: None
    """
    pass    


def ar_create_anchor_from_hit_test(index: int) -> int:
    """
    Creates an anchor from the given hit test result which can be used to track a spot in the real world over time.

    Anchors automatically adjust their position to attempt to stay fixed to a point detected in the real world, this
    allows you to place an object there without it drifting too much. Returns an ID you can use to reference this anchor
    later. The hit test result does not need to exist after creating an anchor from it, you can safely clean up the hit
    test results afterwards. The anchor will persist and use some tracking resources until you specifically delete it
    with `ar_delete_anchor()` or you destroy the AR session.

    :param int index: The index of the hit test result to use, starting with index 1
    :rtype: int
    """
    pass    


def ar_create_anchor_from_plane(index: int) -> int:
    """
    Creates an anchor from the given plane's center which can be used to track a spot in the real world over time.

    Anchors automatically adjust their position to attempt to stay fixed to a point detected in the real world, this
    allows you to place an object there without it drifting too much. Returns an ID you can use to reference this anchor
    later. The plane result does not need to exist after creating an anchor from it, you can safely call
    `ar_get_planes_finish()` afterwards. The anchor will persist and use some tracking resources until you specifically
    delete it with `ar_delete_anchor()` or you destroy the AR session.

    :param int index: The index of the plane to use, starting with index 1
    :rtype: int
    """
    pass    


def ar_delete_anchor(anchor_id: int) -> None:
    """
    Deletes the specified anchor and frees up any resources that were being used by it.

    If any objects were attached to the anchor when it is deleted then they will return to an unattached state and be
    placed at world coordinates

    :param int anchor_id: The ID of the anchor to delete
    :rtype: None
    """
    pass    


def ar_destroy() -> None:
    """
    Destroys the AR session and any resources allocated during setup.

    After you can not call any AR commands, except `ar_get_status()` and `ar_setup()`. You may call `ar_setup()` to
    recreate an AR session. There is no limit on the number of times you can create and destroy the AR session.

    Currently on Android this command may take up to 5 seconds, apparently this will be improved ina future version of
    Google's ARCore.

    :rtype: None
    """
    pass    


def ar_draw_background() -> None:
    """
    You must call this command if you want the AR camera feed to be drawn to the screen.

    If you do not then the camera will still track as if it were moving around the real world but the camera feed will
    not be seen inside the app. This may be useful if you want to render a purely virtual reality but still use the AR
    camera tracking functionality. The best time to call this command is just before calling `render()` or `sync()`.

    :rtype: None
    """
    pass    


def ar_fix_object_to_anchor(object_id: int, anchor_id: int) -> None:
    """
    Attaches an object to an anchor in the same way that `fix_object_to_object()` works.

    The object's position and rotation will be added to the anchor's position and rotation. So for example an object at
    position 0,0,0 would be directly on top of the anchor's position, whereas if the object had a position of 0,2,0 then
    the object would be placed 2 meters above the anchor's position. There is no limit on the number of objects that can
    be attached to an anchor, and objects can still be attached to the object attached to the anchor. For example object
    1 could be fixed to the anchor, and object 2 could be fixed to object 1. To remove an object from an anchor call
    this command with an anchor ID of 0. The object will then be placed in the world at its given position, for example
    a position of 0,0,0 would place it at the origin of the world.

    :param int object_id: The ID of the object to fix to the anchor
    :param int anchor_id: The ID of the anchor to use
    :rtype: None
    """
    pass    


def ar_get_anchor_status(anchor_id: int) -> int:
    """
    Returns the current tracking status of the given anchor.

    0=stopped, 1=paused, 2=tracking, -1=don't know. Anchors can stop tracking if the camera loses tracking with the
    world, this can happen if the camera can't see enough features to work out how the scene is moving. For example by
    looking at a blank wall. When an anchor stops or pauses tracking it maintains its current position and rotation, but
    this no longer correlates to the world position it was tracking, so the anchor may appear to be drifting relative to
    the world. When the anchor resumes tracking it should return to its correct world position.

    :param int anchor_id: The ID of the anchor to check
    :rtype: int
    """
    pass    


def ar_get_hit_test_normal_x(index: int) -> float:
    """
    Returns the X component of the normal of the given hit test result in 3D space.

    Hit test results are ordered with the closest first, starting at index 1. For planes on the ground the normal will
    point straight up in 3D space, for points detected on walls or other objects the normal will point away from the
    detected surface.

    :param int index: The index of the hit test result to check, starting with index 1.
    :rtype: float
    """
    pass    


def ar_get_hit_test_normal_y(index: int) -> float:
    """
    Returns the Y component of the normal of the given hit test result in 3D space.

    Hit test results are ordered with the closest first, starting at index 1. For planes on the ground the normal will
    point straight up in 3D space, for points detected on walls or other objects the normal will point away from the
    detected surface.

    :param int index: The index of the hit test result to check, starting with index 1.
    :rtype: float
    """
    pass    


def ar_get_hit_test_normal_z(index: int) -> float:
    """
    Returns the Z component of the normal of the given hit test result in 3D space.

    Hit test results are ordered with the closest first, starting at index 1. For planes on the ground the normal will
    point straight up in 3D space, for points detected on walls or other objects the normal will point away from the
    detected surface.

    :param int index: The index of the hit test result to check, starting with index 1.
    :rtype: float
    """
    pass    


def ar_get_hit_test_type(index: int) -> int:
    """
    Returns the type of surface detected, 1=plane, usually horizontal, 0=point, usually a wall or other object,
    -1=unknown.

    :param int index: The index of the hit test result to check, starting with index 1.
    :rtype: int
    """
    pass    


def ar_get_hit_test_x(index: int) -> float:
    """
    Returns the X component of the given hit test result in 3D space.

    Hit test results are ordered with the closest first, starting at index 1. This point should only be used for a short
    time, for example to display a particle effect, as it will drift relative to the real world. If you plan to use this
    3D point to position a long lived object in the world then you should create an anchor from this hit test result
    instead so that it doesn't drift.

    :param int index: The index of the hit test result to check, starting with index 1.
    :rtype: float
    """
    pass    


def ar_get_hit_test_y(index: int) -> float:
    """
    Returns the Y component of the given hit test result in 3D space.

    Hit test results are ordered with the closest first, starting at index 1. This point should only be used for a short
    time, for example to display a particle effect, as it will drift relative to the real world. If you plan to use this
    3D point to position a long lived object in the world then you should create an anchor from this hit test result
    instead so that it doesn't drift.

    :param int index: The index of the hit test result to check, starting with index 1.
    :rtype: float
    """
    pass    


def ar_get_hit_test_z(index: int) -> float:
    """
    Returns the Z component of the given hit test result in 3D space.

    Hit test results are ordered with the closest first, starting at index 1. This point should only be used for a short
    time, for example to display a particle effect, as it will drift relative to the real world. If you plan to use this
    3D point to position a long lived object in the world then you should create an anchor from this hit test result
    instead so that it doesn't drift.

    :param int index: The index of the hit test result to check, starting with index 1.
    :rtype: float
    """
    pass    


def ar_get_light_estimate() -> float:
    """
    Returns the estimated light value for the current frame, this will be a value between 0.0 and 1.0.

    The best use of this value is to set the ambient light color with `set_ambient_color()` with a value of 1.0
    corresponding to a color value of 255,255,255.

    :rtype: float
    """
    pass    


def ar_get_plane_angle_x(index: int) -> float:
    """
    Returns the X component of the rotation of the given plane.

    This can be used to rotate a 3D object to match a visual representation of the detected plane.

    :param int index: The index of the plane to check, starting with index 1
    :rtype: float
    """
    pass    


def ar_get_plane_angle_y(index: int) -> float:
    """
    Returns the Y component of the rotation of the given plane.

    This can be used to rotate a 3D object to match a visual representation of the detected plane.

    :param int index: The index of the plane to check, starting with index 1
    :rtype: float
    """
    pass    


def ar_get_plane_angle_z(index: int) -> float:
    """
    Returns the Z component of the rotation of the given plane.

    This can be used to rotate a 3D object to match a visual representation of the detected plane.

    :param int index: The index of the plane to check, starting with index 1
    :rtype: float
    """
    pass    


def ar_get_planes(reserved: Optional[int] = 0) -> int:
    """
    Queries the AR session for all the planes currently being tracked in the world, these are detected over time if
    `ar_set_plane_detection_mode()` is turned on.

    Returns the number of planes found. This can be used to show the detected planes to the user by creating some plane
    objects with `create_object_plane()` and placing them at the given position, with the given rotation, and size. When
    you are done checking the results you should call `ar_get_planes_finish()` to clean up any resources used in the
    check.

    :param Optional[int] reserved: reserved for future use, must be 0
    :rtype: int
    """
    pass    


def ar_get_planes_finish() -> None:
    """
    Cleans up any resources used in the call to `ar_get_planes()`, you should call this when you are done checking the
    results.

    If not then it will be called automatically when you next call `ar_get_planes()` or destroy the AR session.

    :rtype: None
    """
    pass    


def ar_get_plane_size_x(index: int) -> float:
    """
    Returns the X component of the size of the given plane.

    This can be used to scale a 3D object to match a visual representation of the detected plane.

    :param int index: The index of the plane to check, starting with index 1
    :rtype: float
    """
    pass    


def ar_get_plane_size_z(index: int) -> float:
    """
    Returns the Z component of the size of the given plane.

    This can be used to scale a 3D object to match a visual representation of the detected plane.

    :param int index: The index of the plane to check, starting with index 1
    :rtype: float
    """
    pass    


def ar_get_plane_x(index: int) -> float:
    """
    Returns the X component of the center of the given plane.

    This point may drift over time relative to the real world scene, so it should be checked and updated regularly if
    you are using it to show a visible representation of the plane.

    :param int index: The index of the plane to check, starting with index 1
    :rtype: float
    """
    pass    


def ar_get_plane_y(index: int) -> float:
    """
    Returns the Y component of the center of the given plane.

    This point may drift over time relative to the real world scene, so it should be checked and updated regularly if
    you are using it to show a visible representation of the plane.

    :param int index: The index of the plane to check, starting with index 1
    :rtype: float
    """
    pass    


def ar_get_plane_z(index: int) -> float:
    """
    Returns the Z component of the center of the given plane.

    This point may drift over time relative to the real world scene, so it should be checked and updated regularly if
    you are using it to show a visible representation of the plane.

    :param int index: The index of the plane to check, starting with index 1
    :rtype: float
    """
    pass    


def ar_get_status() -> int:
    """
    Returns the current state of the AR setup process.

    0=`ar_setup()` not yet called, -1=AR not available on this device, or setup failed, -2=User rejected ARCore install,
    1=ARCore install in progress, 2=AR setup successful.

    :rtype: int
    """
    pass    


def ar_hit_test(x: Union[float, int], y: Union[float, int]) -> int:
    """
    Casts a ray into the real world scene and detects any hits with planes or tracking points detected in the world.

    Returns the number of hits detected, the hits will be ordered with the closest first. The coordinates should be in
    screen space, for example the values returned from `get_pointer_x()` and `get_pointer_y()`. When you are finished
    checking the results of this hit test you should call `ar_hit_test_finish()` to release any used resources. If not
    then this will be done automatically when you next call `ar_hit_test()`.

    :param Union[float, int] x: The X component of the screen coordinate
    :param Union[float, int] y: The Y component of the screen coordinate
    :rtype: int
    """
    pass    


def ar_hit_test_finish() -> None:
    """
    Cleans up the resources used during hit testing, this should be called when you are done checking the hit test
    results.

    If you do not call it then it will be called automatically when you perform another hit test or destroy the AR
    session.

    :rtype: None
    """
    pass    


def ar_set_light_estimation_mode(enabled: Union[bool, int]) -> None:
    """
    Sets the light estimation mode for AR, by default this is turned on.

    This attempts to work out the ambient light in the real world so you can light your virtual objects correctly.

    :param Union[bool, int] enabled: True=Turn light estimation on, False=Turn light estimation off
    :rtype: None
    """
    pass    


def ar_set_plane_detection_mode(enabled: Union[bool, int]) -> None:
    """
    Sets the plane detection mode for AR, by default this is turned on.

    Detected planes can be discovered with the `ar_get_planes()` command.

    :param Union[bool, int] enabled: True=Turn plane detection on, False=Turn plane detection off
    :rtype: None
    """
    pass    


def ar_setup() -> None:
    """
    Only available on iOS and Android.

    This command sets up the AR features of the device, if available. Use the `ar_get_status()` command to check if this
    was successful. This command must be called before any other AR commands, if the setup fails you may call this
    command again to attempt setup again.

    Setting up AR will take control of the 3D camera, including the projection matrix, so any changes you make to the
    camera position, rotation, FOV, will be overwritten by the AR system when `render()` or `sync()` are called. However
    you can still control the camera near and far values with `set_camera_range()` which will persist through the AR
    system.

    When using AR and placing or sizing 3D objects then the coordinate system is 1 AGK unit equals 1 meter.

    :rtype: None
    """
    pass    


def cancel_local_notification(notification_id: int) -> None:
    """
    Cancels a notification that was scheduled by this application.

    :param int notification_id: The ID of the notification to cancel.
    :rtype: None
    """
    pass    


def check_permission(permission: str) -> int:
    """
    Only for Android, all other platforms will return 1 and do nothing.

    Checks if the user has granted your app the specified permission to use certain Android commands. The permissions
    are as follows

    "WriteExternal" - used by the `save_shared_variable()` commands and any "raw:" paths that access the sdcard.

    "Location" - used by the GPS commands

    "Camera" - used by the `set_device_camera_to_image()` command

    "RecordAudio" - used by the `start_screen_recording()` command and for the AR camera feed

    This command will return 0 if you don't have permission and the user hasn't been asked yet, you should call
    `request_permission()` if you need it. This command returns 1 if the user is in the process of being asked for
    permission, you should wait for a reply by continuing to call this command. It will return -1 if the user rejected
    permission, or 2 if the user granted permission. If the user rejects your request then you can ask again but you
    should explain why your app needs it first so they can make an informed choice. If they still reject it you should
    not normally ask a third time. After the first attempt Android will give the user the option to never allow the
    permission. In this case this command will always return -1 and `request_permission()` will do nothing. The user
    will have to go into the device app settings to reverse this decision.

    Any permission not listed here does not require you to prompt the user for permission, it will be auto granted on
    install if your app requires it. All permissions that your app uses, even those that require prompting, must be
    specified in the APK export dialog by ticking the appropriate check boxes.

    :param str permission: The permission to check
    :rtype: int
    """
    pass    


def delete_cloud_data_variable(name: str) -> None:
    """
    Deletes the variable with the specified name and removes any data stored in the cloud for that variable.

    If the variable doesn't exist then this does nothing.

    :param str name: The name of the variable to delete, must be less than 64 bytes
    :rtype: None
    """
    pass    


def delete_shared_variable(name: str) -> None:
    """
    Deletes a shared variable by name.

    If the variable doesn't exist then this will do nothing. Once the variable is deleted then `load_shared_variable()`
    will return the default value for any requests to load it.

    :param str name: The name of the variable to delete.
    :rtype: None
    """
    pass    


def firebase_log_event(name: str) -> None:
    """
    Tells Firebase to record an event that happened in your app, for example unlocking an achievement.

    These will appear in your Firebase project analytics page. Note that event names must not contain dashes or spaces,
    otherwise they will fail to register.

    :param str name: The name of the event to pass to Firebase, some of these are reserved for automated events e.g.
        "first_open".
    :rtype: None
    """
    pass    


def firebase_setup() -> None:
    """
    Starts the Firebase analytics system and the tracking of some automated events.

    Additional events can be tracked by using `firebase_log_event()`.

    You must include the google services config file that was created when you setup your Firebase project, this can be
    added during export for Android or iOS. If you do not specify your own google services config file during export
    then all your tracking data will go to our AGK Firebase project and be ignored. Similarly if you use these commands
    during broadcasting then the tracking data will go to the AGK project and be ignored.

    :rtype: None
    """
    pass    


def game_center_achievements_show() -> None:
    """
    Shows the user their achievements and progress.

    :rtype: None
    """
    pass    


def game_center_login() -> None:
    """
    Call this once to log the user in to Game Center (iOS) or Google Play Games (Android), if they have logged in before
    this happens in the background and does not interrupt the user, otherwise a popup will appear asking them to log in
    and grant permission to continue.

    :rtype: None
    """
    pass    


def game_center_logout() -> None:
    """
    Call this to log the user out of Google Play Games.

    After this you may call `game_center_login()` again. On Game Center (iOS) this has no affect, the user must logout
    from the Game Center app.

    :rtype: None
    """
    pass    


def game_center_setup() -> None:
    """
    Call this once to setup your app for further Game Center commands.

    :rtype: None
    """
    pass    


def game_center_show_leader_board(board_id: str) -> None:
    """
    Shows the user the named leaderboard, the name must match the Leaderboard ID given to your board in iTunes connect,
    Google Game Services, or GameCircle.

    :param str board_id: The name of the leader board.
    :rtype: None
    """
    pass    


def game_center_submit_achievement(achievement_id: str, percentage_complete: int) -> None:
    """
    Change the users progress on reaching a named achievement, the name must match the Achievement ID given to the
    achievement in iTunes connect, Google Game Services, or GameCircle.

    The `percentage_complete` values should be between 0 and 100. However, for incremental achievements this value is
    actually the number of steps completed and may be outside of this range. The value will overwrite the current
    percentage or steps completed of the achievement.

    :param str achievement_id: The name of the achievement.
    :param int percentage_complete: The users progress towards getting this achievement, or the number of steps
        completed.
    :rtype: None
    """
    pass    


def game_center_submit_score(score: int, board_id: str) -> None:
    """
    Submits a score to a named leader board, this must match the Leaderboard ID given to your board in iTunes connect,
    Google Game Services, or GameCircle.

    :param int score: The score to submit.
    :param str board_id: The name of the leader board.
    :rtype: None
    """
    pass    


def get_app_receipt() -> str:
    """
    Returns the app receipt that contains a list of all purchases as a base64 encoded string. This can be sent to a
    server you control to validate the purchases, including the purchase of the app itself. Only available on iOS, other
    platforms will return an empty string.

    :rtype: str
    """
    pass    


def get_clipboard_text() -> str:
    """
    Gets any text currently held in the device clipboard, the text remains in the clipboard so it can still be used by
    other apps.

    The clipboard is the same as that used by the copy/paste functionality of the device.

    :rtype: str
    """
    pass    


def get_cloud_data_allowed() -> int:
    """
    Returns 1 if the cloud data commands are available to use.

    Returns 0 if the user hasn't decided whether to allow or block access yet, this will be prompted in
    `setup_cloud_data()` if applicable.

    Returns -1 if the user has specifically denied access.

    Returns -2 if the user is not logged in or the device does not have iCloud or Google Drive. You can prompt the user
    to login and enable these when your app first starts, or when they choose to enable cloud backup in your own app
    settings.

    If this command returns -3 on Android then the Google cloud data has become corrupted and must be cleared in the
    Drive settings.

    :rtype: int
    """
    pass    


def get_cloud_data_changed() -> bool:
    """
    Returns True if the cloud data has changed due to another device changing a value, this will remain True until you
    call `get_cloud_data_variable()`.

    Otherwise returns False. This will not become True when you change the value locally.

    :rtype: bool
    """
    pass    


def get_cloud_data_variable(name: str, default: str) -> str:
    """
    Returns the value of a cloud data variable by name.

    If the variable does not exist then the default value passed in will be returned instead.

    :param str name: The name of the variable to check, must be less than 64 bytes
    :param str default: The value to return if the variable doesn't exist
    :rtype: str
    """
    pass    


def get_game_center_exists() -> bool:
    """
    Returns True if the current platform supports Game Center or Google Play Games.

    :rtype: bool
    """
    pass    


def get_game_center_logged_in() -> int:
    """
    Will return 1 if the user is logged in to Game Center or Google Play Games, 0 if not.

    The login process is asynchronous so after calling `game_center_login()` it may take a few seconds for this command
    to return 1.

    If the user fails to login or GameCenter is not available then this will return -1.

    :rtype: int
    """
    pass    


def get_game_center_player_display_name() -> str:
    """
    Returns the display name for the currently logged in player.

    If no one is logged in, or the platform does not support GameCenter commands then this will return an empty string.

    :rtype: str
    """
    pass    


def get_game_center_player_id() -> str:
    """
    Returns the unique ID for the currently logged in player.

    If no one is logged in, or the platform does not support GameCenter commands then this will return an empty string.

    :rtype: str
    """
    pass    


def get_in_app_purchase_available(product_id: int) -> bool:
    """
    Returns True if the extra content has been purchased and is therefore available.

    Returns False if the content is not available. It is recommended that you use the newer
    `get_in_app_purchase_available2()` to get a more detailed response. Currently this command is only supported on iOS
    and Android.

    :param int product_id: This ID corresponds to the product IDs that have been added e.g. your first product.
    :rtype: bool
    """
    pass    


def get_in_app_purchase_available2(product_id: int) -> int:
    """
    A more detailed version of `get_in_app_purchase_available()` that gives the purchase state

    Returns 0 if the product is not purchased

    Returns 1 if the product is queued for purchased

    Returns 2 if the product purchase is in progress

    Returns 3 if the product purchase is pending (subject to payment clearance)

    Returns 4 if the product is purchased

    You should only reward the user once the product reaches state 4 (purchased). Currently this command is only
    supported on iOS and Android.

    :param int product_id: this ID corresponds to the product IDs that have been added e.g. your first product.
    :rtype: int
    """
    pass    


def get_in_app_purchase_description(product_id: int) -> str:
    """
    Returns the description for the specified product, as defined by the current platform store.

    It may take a few seconds after calling `in_app_purchase_setup()` for this data to become available, so if you get
    an empty string try again later.

    :param int product_id: This ID corresponds to the product IDs that have been added e.g. your first product.
    :rtype: str
    """
    pass    


def get_in_app_purchase_local_price(product_id: int) -> str:
    """
    Returns the current price of the specified in app purchase product in the local currency, this will be a string with
    the currency symbol included where possible.

    It may take a few seconds after calling `in_app_purchase_setup()` for this data to become available, so if you get
    an empty string try again later.

    :param int product_id: This ID corresponds to the product IDs that have been added e.g. your first product.
    :rtype: str
    """
    pass    


def get_in_app_purchase_signature(product_id: int) -> str:
    """
    Returns the signature for the last purchase of the given item, this can be checked against your public key to
    confirm the purchase was valid.

    It is recommended that you pass this signature to a server to do the check so that the check cannot be bypassed.

    This has been deprecated on iOS, you should use the `get_app_receipt()` command instead that will return a list of
    all purchases related to the app.

    :param int product_id: The ID of the product to check. e.g. your first product ID is 0, your second is 1 etc.
    :rtype: str
    """
    pass    


def get_in_app_purchase_sub_num_plans(id: int) -> int:
    """


    :param int id: this ID corresponds to the product IDs that have been added e.g. your first product.
    :rtype: int
    """
    pass    


def get_in_app_purchase_sub_plan_duration(id: int, plan_index: int, period_index: int) -> int:
    """


    :param int id: this ID corresponds to the product IDs that have been added e.g. your first product.
    :param int plan_index: The plan index.
    :param int period_index: The period index.
    :rtype: int
    """
    pass    


def get_in_app_purchase_sub_plan_duration_unit(id: int, plan_index: int, period_index: int) -> str:
    """


    :param int id: this ID corresponds to the product IDs that have been added e.g. your first product.
    :param int plan_index: The plan index.
    :param int period_index: The period index.
    :rtype: str
    """
    pass    


def get_in_app_purchase_sub_plan_num_periods(id: int, plan_index: int) -> int:
    """


    :param int id: this ID corresponds to the product IDs that have been added e.g. your first product.
    :param int plan_index: The plan index.
    :rtype: int
    """
    pass    


def get_in_app_purchase_sub_plan_payment_type(id: int, plan_index: int, period_index: int) -> int:
    """


    :param int id: this ID corresponds to the product IDs that have been added e.g. your first product.
    :param int plan_index: The plan index.
    :param int period_index: The period index.
    :rtype: int
    """
    pass    


def get_in_app_purchase_sub_plan_price(id: int, plan_index: int, period_index: int) -> str:
    """


    :param int id: this ID corresponds to the product IDs that have been added e.g. your first product.
    :param int plan_index: The plan index.
    :param int period_index: The period index.
    :rtype: str
    """
    pass    


def get_in_app_purchase_sub_plan_tags(id: int, plan_index: int) -> str:
    """


    :param int id: this ID corresponds to the product IDs that have been added e.g. your first product.
    :param int plan_index: The plan index.
    :rtype: str
    """
    pass    


def get_in_app_purchase_sub_plan_token(id: int, plan_index: int) -> str:
    """


    :param int id: this ID corresponds to the product IDs that have been added e.g. your first product.
    :param int plan_index: The plan index.
    :rtype: str
    """
    pass    


def get_in_app_purchase_token(product_id: int) -> str:
    """
    On Android this returns a unique token for the last purchase of the given item, this can be sent to your server to
    check the validity of the purchase with Google, and to distinguish between different instances of a consumable
    purchase. You should only reward the user once per token for consumable purchases, it is recommended that you store
    a list of past tokens on a server so you can detect any token reuse, which could be used to cheat your system. Once
    you have rewarded the user for a consumable purchase you must call `in_app_purchase_reset_purchase()` with the most
    recent token to allow it to be purchased again.

    On iOS this returns a transaction ID that changes with every purchase the user makes. It can't be used to check with
    Apple if a transaction was genuine but it can be used to distinguish between multiple purchases of a consumable
    item. You can pass this token to `in_app_purchase_reset_purchase()` to reset the purchase state to 0 but on iOS this
    is not required.

    This only works on Android and iOS, other platforms will return an empty string.

    :param int product_id: The ID of the product to check. e.g. your first product ID is 0, your second is 1 etc.
    :rtype: str
    """
    pass    


def get_local_notification_exists(notification_id: int) -> bool:
    """
    Returns True if a notification with this ID is waiting to be displayed, otherwise False.

    Notifications are refreshed every 5 seconds, so this may continue to return True shortly after a notification has
    fired.

    :param int notification_id: The ID of the notification to check.
    :rtype: bool
    """
    pass    


def get_local_notification_message(notification_id: int) -> str:
    """
    Returns the message that the specified notification will display.

    If no notification exists at the specified ID then an empty string will be returned.

    :param int notification_id: The ID of the notification to check.
    :rtype: str
    """
    pass    


def get_local_notification_time(notification_id: int) -> int:
    """
    Returns the date and time that the specified notification is due to display.

    The returned time will be in unix timestamp format, which is measured by the number of seconds since 1st Jan 1970.
    If no notification exists at the specified ID then 0 is returned.

    :param int notification_id: The ID of the notification to check.
    :rtype: int
    """
    pass    


def get_push_notification_token() -> str:
    """
    Returns the push notification token for this device, this must be sent to your server that sends out the
    notifications so that it can send notifications to this device.

    If `push_notification_setup()` returned True then you should keep calling this command until it returns a non-empty
    string. If `push_notification_setup()` returned False then this command will always return an empty string.

    Please see the guide on Android Push Notifications for more details on how to use the device token to send push
    notifications to this device.

    :rtype: str
    """
    pass    


def get_smart_watch_state() -> int:
    """
    Returns the current state of the smart watch connection:
     * 0 = initial state, `activate_smart_watch()` has not been called.
     * 1 = connecting, will transition to a more detailed state in a moment.
     * 2 = connection successful, you may send and receive data.
     * -1 = watch commands not supported on this device.
     * -2 = connection failed or no watch found.
     * -3 = watch found but it is not currently paired with the device,
     * -4 = watch found but our watch app is not currently installed.

    Currently only works on iOS.

    :rtype: int
    """
    pass    


def in_app_purchase_activate(product_id: int) -> None:
    """
    Call this when you want to start the process of purchasing a product. Currently this command is only supported on
    iOS and Android.

    :param int product_id: This ID corresponds to the product IDs that have been added e.g. your first product.
    :rtype: None
    """
    pass    


def in_app_purchase_activate_with_plan(id: int, plan_token: str) -> None:
    """
    Call this when you want to start the process of purchasing a product with a specific plan. Subscriptions can have
    multiple purchase plans which you can enumerate with `get_in_app_purchase_sub_num_plans()`. To start a purchase with
    a specific plan get the plan token with `get_in_app_purchase_sub_plan_token()` and then pass it to this command.
    Currently this command is only supported on iOS and Android.

    :param int id: this ID corresponds to the product IDs that have been added e.g. your first product.
    :param str plan_token: The plan token.
    :rtype: None
    """
    pass    


def in_app_purchase_add_product_id(product_id: str, product_type: int) -> None:
    """
    Use this command to add any product IDs into the list e.g. com.yourcompany.yourproduct.iap.

    The first product ID you add becomes 0, the second is 1 etc. You must also specify the `product_type` of product
    this is, non-consumable(0), consumable(0), or subscription(2). Previously consumable products were added as
    `product_type`=1 but they are now added as `product_type`=0 and `in_app_purchase_reset_purchase()` is used to reset
    a consumable to a purchasable state. Consumable products are like coins that can be bought again and again, whereas
    non-consumable products are one off purchases like unlocking the full version of an app. In Google Play consumable
    and non-consumable products are added the same way. Currently this command is only supported on iOS, Google Play,
    and Amazon. This must be called before `in_app_purchase_setup()`, after that no further products can be added.

    :param str product_id: The product ID as specified in iTunes Connect or the Google Play developer console.
    :param int product_type: The type of product this is, non consumable(0), consumable(0), or subscription(2).
    :rtype: None
    """
    pass    


def in_app_purchase_redeem_offer() -> None:
    """
    Call this command to show the redeem offer dialog provided by the device (if any). This currently only applies to
    iOS, and will only work on iOS 14 or above, otherwise it will do nothing.

    Android displays this option automatically when a user starts a purchase.

    :rtype: None
    """
    pass    


def in_app_purchase_reset_purchase(token: str) -> None:
    """
    Call this command to reset the purchase state of an individual product. On Android this must be called for
    consumable products after you have dealt with a purchase to allow it to be purchased again. If you call this command
    on a non-consumable purchase then that purchase will be reset to an unpurchased state and the user will have to pay
    for it again, this should only be used during testing.

    Subscriptions cannot be reset and must be cancelled by the user through their Google Play account

    On iOS this command is not necessary as it automatically allows consumable items to be purchased multiple times,
    however this command could still be useful to reset the `get_in_app_purchase_available2()` state to 0 so you know it
    has been dealt with. Reseting a non-consumable purchase on iOS will reset the state to 0 but iOS will still remember
    the purchase and not charge the user again.

    Use `get_in_app_purchase_token()` to get the token required to reset a purchase. Currently this command is only
    supported on Android and iOS.

    :param str token: The most recent token from `get_in_app_purchase_token()` for this product.
    :rtype: None
    """
    pass    


def in_app_purchase_restore() -> None:
    """
    Restores any managed purchases made on this platform.

    For example if a user purchased at item then reinstalled the app the app would return 0 for
    `get_in_app_purchase_available()` unless it was purchased again or restored using this command.

    Even though purchasing again wouldn't charge the user again for non-consumable items, using this restore command is
    a better user experience. Apple require you to have a button that calls this function somewhere in your app.

    After calling this command you can call `get_in_app_purchase_available2()` to check for purchases, it may take some
    time for the purchase state to update, so check `get_in_app_purchase_available2()` regularly. This command is
    supported by both iOS and Android.

    :rtype: None
    """
    pass    


def in_app_purchase_set_keys(data1: str, data2: str) -> None:
    """
    This command is only used by Ouya where you need to provide your public key in base64. This must be called before
    `in_app_purchase_setup()`.

    :param str data1: Public Key.
    :param str data2: Developer UUID (Ouya only).
    :rtype: None
    """
    pass    


def in_app_purchase_set_title(title: str) -> None:
    """
    Sets the name of your application so that it can be displayed on any dialogs that get displayed when using the in
    app purchase commands.

    Currently this command is only supported on iOS and Android.

    :param str title: Name of your application.
    :rtype: None
    """
    pass    


def in_app_purchase_setup() -> None:
    """
    After setting the in app purchase title and adding product IDs call `in_app_purchase_setup()` to finalise the
    process.

    After this point you can attempt to purchase unlockable content. Currently this command is only supported on iOS and
    Android.

    :rtype: None
    """
    pass    


def load_shared_variable(name: str, default_value: str) -> str:
    """
    Loads a variable that was saved by this app, or another app.

    This only works on iOS, Android 9 and below, and HTML5 platforms. Apps can only share a variable if they meet
    certain requirements based on the platform.

    On iOS the apps must have the same Bundle Seed ID (also called App ID Prefix) and have the same explicit App ID up
    to the last dot. For example com.mycompany.mygroup.myapp1 and com.mycompany.mygroup.myapp2 would be able to share
    variables.

    On Android 9 and below the apps must have the WRITE_EXTERNAL_STORAGE permission and have the same package name up to
    the last dot. For example com.mycompany.mygroup.myapp1 and com.mycompany.mygroup.myapp2 would be able to share
    variables.

    On Android shared variables are written to a user accessible location, so be aware that users may be able to read
    and/or edit the variables that you save.

    On Android 10 or higher this command will not work as apps are restricted from writing to shared locations.

    On HTML the apps must be hosted on the same domain, the values are stored as cookies.

    Variables are identified by name, so using `save_shared_variable("username", "Alice")` will set the variable called
    "username" to the value "Alice". This can then be read by other apps by using `load_shared_variable("username",
    "")`. If a variable with the given name doesn't exist then the specified default value is returned instead.

    :param str name: The name of the variable to retrieve.
    :param str default_value: The value to return if the variable doesn't exist.
    :rtype: str
    """
    pass    


def push_notification_setup() -> bool:
    """
    Returns True if setup was successful, False if it failed or the device does not support push notifications.

    :rtype: bool
    """
    pass    


def rate_app(app_id: str, title: Optional[str] = None, message: Optional[str] = None) -> None:
    """
    Displays a dialog box asking the user to rate the app on the App Store.

    Currently this command is only supported on iOS.

    :param str app_id: This is the ID of your app. You can obtain this from iTunes Connect.
    :param Optional[str] title: The string to use as the title of the dialog box, normally this is "Rate AppName".
    :param Optional[str] message: The string to use as the message of the dialog box.
    :rtype: None
    """
    pass    


def receive_smart_watch_data() -> str:
    """
    Receives a queued message from the watch app.

    This will be in the form of a JSON string.

    Currently only works on iOS.

    :rtype: str
    """
    pass    


def request_app_review() -> None:
    """
    iOS 10.3 has a special feature that will allow the user to review your app from within the app itself, this command
    will tell iOS to start this process.

    Note that iOS is not guaranteed to display anything when you call this command, and it should not be called in
    response to a button press or other user interaction. You should call it when there is a lull in the app such as the
    end of a level. If you want to start the review process in response to a user action, such as a button press, then
    you should use the `open_browser()` command to open the AppStore.

    :rtype: None
    """
    pass    


def request_permission(permission: str) -> None:
    """
    Only for Android, all other platforms will do nothing.

    Generates a system dialog asking the user for the specified device permission, used by certain Android commands. The
    permissions are as follows

    "WriteExternal" - used by the `save_shared_variable()` commands and any "raw:" paths that access the sdcard.

    "Location" - used by the GPS commands

    "Camera" - used by the `set_device_camera_to_image()` command and for the AR camera feed

    "RecordAudio" - used by the `start_screen_recording()` command

    You can check the result of the request by calling `check_permission()`. After the first request Android will give
    the user the option to stop displaying the request dialog. In this case this command will no longer generate a
    request dialog and instead do nothing. The user will have to go into the device app settings to reverse this
    decision.

    Any permission not listed here does not require you to prompt the user for permission, it will be auto granted on
    install if your app requires it. All permissions that your app uses, even those that require prompting, must be
    specified in the APK export dialog by ticking the appropriate check boxes.

    :param str permission: The permission to request
    :rtype: None
    """
    pass    


def save_shared_variable(name: str, value: str) -> None:
    """
    Saves a variable so it can be accessed from other apps.

    This only works on iOS, Android 9 and below, and HTML5 platforms. Apps can only share a variable if they meet
    certain requirements based on the platform.

    On iOS the apps must be created by the same Apple developer account, and have the same App Group added to their App
    IDs on the Apple developer portal. You will need to regenerate the provisioning profile after doing this. On iOS you
    must tell AGK what the App Group is by using `set_shared_variable_app_group()`.

    On Android 9 and below the apps must have the WRITE_EXTERNAL_STORAGE permission and have the same package name up to
    the last dot. For example com.mycompany.mygroup.myapp1 and com.mycompany.mygroup.myapp2 would be able to share
    variables. On Android shared variables are written to a user accessible location, so be aware that users may be able
    to read and/or edit the variables that you save.

    On Android 10 or higher this command will not work as apps are restricted from writing to shared locations.

    On HTML the apps must be hosted on the same domain, the values are stored as cookies.

    Variables are identified by name, so using `save_shared_variable("username", "Alice")` will set the variable called
    "username" to the value "Alice". This can then be read by other apps by using `load_shared_variable("username", "")`
    If two apps save different values to the same variable name then the value will be overwritten and only the most
    recent value will be accessible. Variable values will persist even if the app is deleted and re-installed. You
    should not use this command to store any sensitive information such as passwords in plain text. On iOS the length of
    the variable name plus the length of your App ID up to the last dot (e.g. com.mycompany.mygroup) must be less than
    58.

    :param str name: The name to use to identify this variable.
    :param str value: The value to save in this variable.
    :rtype: None
    """
    pass    


def send_smart_watch_data(json: str) -> None:
    """
    Send data to the smart watch in the background, if watch app is not currently open the message will be queued and
    received by the watch app when it is next opened.

    The message must be in the form of a JSON string, for example "{"label":"my message"}". You can also use a type with
    the .toJSON() function to create a JSON string. The watch app will receive it as an NSDictionary with the labels as
    keys.

    Currently only works on iOS.

    :param str json: A JSON string containing the message to send to the watch app.
    :rtype: None
    """
    pass    


def set_clipboard_text(text: str) -> None:
    """
    Sets the device clipboard to the specified text, this overwrites anything that was previously in the device
    clipboard.

    The clipboard is the same as that used by the copy/paste functionality of the device.

    :param str text: The text to copy
    :rtype: None
    """
    pass    


def set_cloud_data_variable(name: str, value: str) -> None:
    """
    Sets a cloud data variable to the specified value.

    If multiple devices write a value at the same time then the cloud provider chooses one and sends it to all devices.
    The variable name must be less than 64 bytes, a single UTF8 character may be multiple bytes but typically 1
    character equals 1 byte. It is recommended that variable names incorporate the app name, for example
    "myapp.myvariablename", since when broadcasting your apps they will all share a single data store in the AGK PLayer
    app. Varaible data is stored locally so `get_cloud_data_variable()` will immediately return the new value, however
    syncing with the cloud is done in the background and may take several minutes. If the device has no internet
    connection then the data will be synced at the next available opportunity. On iOS you are limited to 1024 variables
    with 1MB total storage. On Android any data you store counts against the user's Google Drive storage limit, the user
    can clear your app data to free up space, but they cannot read the data you store.

    You should not store sensitive information like passwords in plain text using these commands.

    :param str name: The name of the variable to change, must be less than 64 bytes
    :param str value: The value to set the variable
    :rtype: None
    """
    pass    


def set_local_notification(notification_id: int, datetime: int, message: str,
                           deep_link: Optional[str] = None) -> None:
    """
    Creates a local notification that will appear at some point in the future.

    Notifications are referenced by ID and can be overwritten by creating a new notification with the same ID as the
    notification you want to overwrite. If a notification triggers whilst the app is open then the notification will not
    appear and it will silently disappear from the list of scheduled notifications. If the app is not open then a
    notification will display to the user and tapping on it will open up your app. If you set the deeplink parameter
    then that URL will be sent to the app when the notification is tapped. The URL can be retrieved by using the
    `get_url_scheme_text()` command. The datetime parameter should be specified in unix time, which is measured in
    seconds since 1st Jan 1970, you can use the command `get_unix_time()` to return the current date and time then
    modify it as needed. If the date and time is in the past then the notification will be ignored, it will not
    overwrite any existing notification. The ID must be in the range 1 to 100 inclusive.

    :param int notification_id: The ID to use to reference this notification in future.
    :param int datetime: The date and time to show this notification in unix time.
    :param str message: The message to display in the notification.
    :param Optional[str] deep_link: The URL to send to the app if the notification is tapped
    :rtype: None
    """
    pass    


def set_push_notification_keys(name: str, value: str) -> None:
    """
    This command is used on Android to set the SenderID used by the Firebase project. Currently `name` must be set to
    "SenderID" (case sensitive), and the `value` must be set to the SenderID value that can be found in your Firebase
    project settings, in the Cloud Messaging tab.

    :param str name: The key to set
    :param str value: The key value
    :rtype: None
    """
    pass    


def set_shared_variable_app_group(group: str) -> None:
    """
    For iOS only.

    Tells AGK what App Group you are using to share data between apps. For example
    group.com.mycompany.mygroup.myvariables, this is created on the Apple developer portal and must be added to every
    App ID you want to access these variables. You will need to regenerate the provisioning profile for each app after
    adding an App Group to its App ID.

    :param str group: The name to use to identify this variable.
    :rtype: None
    """
    pass    


def set_snap_chat_sticker_settings(x: Union[float, int], y: Union[float, int], width: int,
                                   height: int, angle: Union[float, int]) -> None:
    """
    Sets the properties for any sticker images that are added to future calls to `share_snap_chat_image()`. The X and Y
    parameters should be in the range 0.0 to 1.0 for example in the X direction 1.0 is the far right of the image and
    0.0 is the far left of the image.

    :param Union[float, int] x: The X position of the sticker, default 0.5
    :param Union[float, int] y: The Y position of the sticker, default 0.5
    :param int width: The width of the sticker, default 250
    :param int height: The height of the sticker, default 250
    :param Union[float, int] angle: The angle of the sticker, default 0
    :rtype: None
    """
    pass    


def setup_cloud_data(reserved: Optional[str] = None) -> None:
    """
    Sets up the device to use cloud data on compatible platforms, currently only Android and iOS support this feature.

    Cloud data can be used to share settings across multiple devices running the same app. For example saving some app
    settings or progress on one device using the cloud data commands will make them available (after a short period of
    time) on all other devices on the same platform. Note that data does not cross platforms, so data saved on iOS is
    not available on Android, and data saved on Android is not available on iOS.

    On iOS this uses iCloud Drive to store the data, so the user must be logged in to iCloud and have iCloud Drive
    turned on, you can detect if these have been done with `get_cloud_data_allowed()`. You must also add iCloud to your
    provisioning profile, but you do not need to create any containers. You must use this provisioning profile when
    exporting your app. On iOS you are limited to 1MB of storage.

    On Android this uses Android Drive AppData so the user must be logged in with a Google account on the device. You
    must also add a Google API project for your app here  https: console.developers.google.com and create an OAuth
    client ID in the credentials section. Tell it that the request is coming from Android, give it a name of your
    choice, and tell it your app package name. You will need give it the SHA-1 fignerprint of the keystore file that you
    will use to sign your APK, this is so it can check that only APKs signed by you can use the generated OAuth client
    ID. The "keytool" program is part of the Java Development Kit (JDK). Once created you do not need to do anything
    with the OAuth token, it will be used automatically when you call the Cloud Data commands. On Android any data you
    store will count against a user's Google Drive storage limit, they cannot access the files stored by your app but
    they can clear the app data in their Drive settings.

    Broadcast apps will use the AGK Player data store and will share variables across all your broadcast apps, so be
    aware of overwriting values if two of your apps share the same variable name. Data you store in the AGK Player data
    store will only be visible to you and your devices.

    This command must be called before any other cloud data commands, except `get_cloud_data_allowed()` which can be
    called at any time. On Android you should ask the user if they want to store data in their Drive before calling
    setup, as this command may ask the user to login to their Google Account.

    :param Optional[str] reserved: Reserved, must be an empty string
    :rtype: None
    """
    pass    


def share_snap_chat_image(image_file: str, sticker_file: str, caption: str, url: str) -> None:
    """
    Sends the specified image to the SnapChat app on the current device, along with an optional sticker file, caption,
    and URL. The user can then modify the image using the SnapChat app and decide whether to share it with friends. If
    the user does not have the SnapChat app installed then the app store will be opened instead on the SnapChat app
    page. This command will only work on Android and iOS 10 or above

    :param str image_file: The path to the image you want to share
    :param str sticker_file: The path to a sticker image to add to the image, can be an empty string
    :param str caption: The caption to add to the image, can be an empty string
    :param str url: The URL to add to the image, can be an empty string
    :rtype: None
    """
    pass    


def add_zip_entry(zip_id: int, filename: str, zip_path: str) -> None:
    """
    Adds a local file into the zip file.

    The `filename` variable is the path to the local file, the `zip_path` variable is the path that will be used inside
    the zip file, this is the only way to add folders to the zip file (by adding a file with a `zip_path` such as
    "folder1/myfile.txt").

    The local file path is relative to the current directory set using `set_folder()` unless you start the path with a
    forward slash, in which case the path will be relative to the root of the write directory on the current platform.

    :param int zip_id: The ID of the zip file to add to.
    :param str filename: The path of the file to add.
    :param str zip_path: The path for the file inside the zip.
    :rtype: None
    """
    pass    


def cancel_zip_extract() -> None:
    """
    Stops any asynchronous zip extraction that is currently in progress, it may take a moment to finish the current file
    and then it will stop.

    Once it finishes `get_zip_extract_complete()` will return 1 and `get_zip_extract_progress()` will remain at whatever
    value it was currently at.

    :rtype: None
    """
    pass    


def choose_raw_file(extension: Optional[str] = None, return_full_path: Optional[Union[bool,
                    int]] = False) -> str:
    """
    Presents the user with an option to choose a file stored on their current platform (Windows/Mac only), for example a
    photo or sound file.

    If the user cancels the operation an empty string will be returned, otherwise the file will be copied to the apps
    current directory and the filename returned so that it can be used by your app.

    You may specify an optional extension filter to limit the types of files the user will see when browsing. For
    example using an extension filter of "*.wav" would limit the user to choosing .wav files. For multiple extensions
    separate them with a semicolon like so "*.wav;*.mp3;*.png".

    If you set `return_full_path` to True then the file will not be copied to the write folder, instead the full path
    will be returned to you and you can load it using the "raw:" prefix with the normal file commands.

    :param Optional[str] extension: The extensions to allow.
    :param Optional[Union[bool, int]] return_full_path: True to return the full path, False to copy it to the write
        folder and return the write folder path.
    :rtype: str
    """
    pass    


def close_file(file_id: int) -> None:
    """
    Closes a file and clears the ID used to create it, no further file commands can be called with this ID.

    :param int file_id: The ID of the file to close.
    :rtype: None
    """
    pass    


def close_raw_folder(folder_id: int) -> None:
    """
    Closes a previously open folder and frees the file list that was generated for it.

    No actual file system changes are made, i.e. the folder is not held open on the file system. The folder is read in
    its entirety during `open_raw_folder()` so it does not need to exist on the file system after calling that command.

    :param int folder_id: The ID of the folder to close.
    :rtype: None
    """
    pass    


def close_zip(zip_id: int) -> None:
    """
    Closes a zip file opened with `create_zip()`.

    This finalizes the zip and allows it to be opened for extraction.

    :param int zip_id: The ID of the zip file to close.
    :rtype: None
    """
    pass    


def count_windows_drives() -> int:
    """
    Returns the number of drives currently available on this devices, only applies to Windows.

    Other platforms will return 0.

    :rtype: int
    """
    pass    


def create_zip(filename: str) -> int:
    """
    Creates a zip file at the specified location and opens it ready for files to be added.

    Files cannot be read or extracted from a zip file using this command. Use `extract_zip()` to retrieve files from it.

    The file path is relative to the current directory set using `set_folder()` unless you start the path with a forward
    slash, in which case the path will be relative to the root of the write directory on the current platform.

    :param str filename: The file name and path for this new zip file.
    :rtype: int
    """
    pass    


def create_zip_id(zip_id: int, filename: str) -> None:
    """
    Creates a zip file at the specified location and opens it ready for files to be added.

    Files cannot be read or extracted from a zip file using this command. Use `extract_zip()` to retrieve files from it.

    The file path is relative to the current directory set using `set_folder()` unless you start the path with a forward
    slash, in which case the path will be relative to the root of the write directory on the current platform.

    :param int zip_id: The ID used to reference this zip file.
    :param str filename: The file name and path for this new zip file.
    :rtype: None
    """
    pass    


def delete_file(filename: str) -> None:
    """
    Deletes a given file from the write folder.

    File paths must be relative, not absolute, you cannot delete files from the application folder or from elsewhere on
    the disk.

    :param str filename: The filename to delete.
    :rtype: None
    """
    pass    


def delete_folder(name: str) -> None:
    r"""
    Deletes a folder at the current path.

    By default this is determined by the command `set_folder()`. You can also use a filename beginning with "raw:" to
    delete a folder anywhere on the file system, for example `delete_folder("raw:C:\\Temp\\MyFolder")`. The folder must
    be empty for this command to succeed.

    :param str name: The name of the folder create.
    :rtype: None
    """
    pass    


def extract_zip(filename: str, path: str, password: Optional[str] = None) -> None:
    """
    Extracts a zip file to a specified directory.

    Any folders created inside the zip file will be created in the extraction process.

    If the zip file is password protected specify the password to extract it. If you specify a wrong password, the
    extracted files from the zip archive will be empty.

    The local file path is relative to the current directory set using `set_folder()` unless you start the path with a
    forward slash, in which case the path will be relative to the root of the write directory on the current platform.

    :param str filename: The path to the zip file to extract.
    :param str path: The path to place the newly extracted zip files.
    :param Optional[str] password: The password that was used to create the zip file.
    :rtype: None
    """
    pass    


def extract_zip_async(filename: str, path: str, password: Optional[str] = None) -> None:
    """
    This command does the same as `extract_zip()` except it returns immediately and the zip extraction is done on a
    thread in the background.

    You can use `get_zip_extract_progress()` and `get_zip_extract_complete()` to check on its progress. If you call this
    command whilst a zip extraction is already in progress then nothing will happen. If the specified zip has no
    password then use an empty string.

    :param str filename: The path to the zip file to extract.
    :param str path: The path to place the newly extracted zip files.
    :param Optional[str] password: The password that was used to create the zip file.
    :rtype: None
    """
    pass    


def file_eof(file_id: int) -> bool:
    """
    Returns True if the given file has reached the end of its data stream, False otherwise.

    Only used when reading.

    :param int file_id: The ID of the file to check.
    :rtype: bool
    """
    pass    


def file_is_open(file_id: int) -> bool:
    """
    Returns True if the given file was opened successfully, False if not.

    You can use `get_error_occurred()` to check if it was the result of an error and `get_last_error()` to get said
    error.

    :param int file_id: The ID of the file to check.
    :rtype: bool
    """
    pass    


def get_documents_path() -> str:
    r"""
    Returns the directory that contains the current users documents.

    On Windows this will be something like "C:\\Users\\Me\\My Documents". This is different from the usual write path
    which is a system specified app write folder, for example "C:\\Users\\Me\\AppData" on Windows.

    The documents folder path can be used to write files that are easily accessible by the user. On Android 9 and below
    the documents path will be the internal storage root folder, on Android 10 and above it will be a folder in the
    Andorid/data folder that is separate for each app but still accessible to the user.

    iOS does not have a user accessible folder so `get_documents_path()` will just return the normal write path where
    files will be inaccessible to the user.

    :rtype: str
    """
    pass    


def get_file_count(mode: int = 2) -> int:
    """
    Returns the number of files in the current folder.

    :param int mode: 0 (FOLDER_MODE_READ_ONLY) to count only files in the read folder, 1 (FOLDER_MODE_WRITE_ONLY) to
        only count the write folder, 2 (FOLDER_MODE_BOTH) to count both.
    :rtype: int
    """
    pass    


def get_file_exists(filename: str) -> bool:
    """
    Returns True if the given file is located in either the resource directory or the write directory assigned to the
    app.

    :param str filename: The filename to check.
    :rtype: bool
    """
    pass    


def get_file_pos(file_id: int) -> int:
    """
    Returns the current read position in the file.

    :param int file_id: The ID of the file to check.
    :rtype: int
    """
    pass    


def get_file_size(file_id: int) -> int:
    """
    Returns the size in bytes of the opened file.

    :param int file_id: The ID of the file to check.
    :rtype: int
    """
    pass    


def get_first_file(mode: int = 2) -> str:
    """
    Returns the name of the first file found in the current folder, which is set using `set_folder()`. You can call
    `get_next_file()` to continue down the list of files in the current folder. Returns an empty string if there are no
    files in the current folder.

    By default this command will combine the file lists from the read and write folders into a single list (mode=2) this
    can be changed to only return files in the read folder (mode=0) or only return files from the write folder (mode=1)

    :param int mode: 0 (FOLDER_MODE_READ_ONLY) to only return files from the read folder, 1 (FOLDER_MODE_WRITE_ONLY) to
        only return files from the write folder, 2 (FOLDER_MODE_BOTH) for both (default).
    :rtype: str
    """
    pass    


def get_first_folder(mode: int = 2) -> str:
    """
    Returns the name of the first folder found in the current folder, which is set using `set_folder()`. You can call
    `get_next_folder()` to continue down the list of folders in the current folder. Returns an empty string if there are
    no folders in the current folder. Does not include . or .. Note that there is a known limitation on Android that any
    folders within the "assets" folder cannot be found using this command. You may be able to work around this by using
    `make_folder()` to create the same folder structure in the write folder which AGK can then use to find files in the
    assets folder with `get_first_file()`.

    By default this command will combine the folder lists from the read and write folders into a single list (mode=2)
    this can be changed to only return folders in the read folder (mode=0) or only return folders from the write folder
    (mode=1)

    :param int mode: 0 (FOLDER_MODE_READ_ONLY) to only return folders from the read folder, 1 (FOLDER_MODE_WRITE_ONLY)
        to only return folders from the write folder, 2 (FOLDER_MODE_BOTH) for both (default).
    :rtype: str
    """
    pass    


def get_folder() -> str:
    """
    Returns the current folder previously set with `set_folder()`.

    The returned path will always have a slash as the final character except when in the root folder in which case an
    empty string will be returned.

    :rtype: str
    """
    pass    


def get_folder_count(mode: int = 2) -> int:
    """
    Returns the number of folders in the current folder. Does not include . or ..

    :param int mode: 0 (FOLDER_MODE_READ_ONLY) to count only folders in the read folder, 1 (FOLDER_MODE_WRITE_ONLY) to
        only count the write folder, 2 (FOLDER_MODE_BOTH) to count both.
    :rtype: int
    """
    pass    


def get_next_file() -> str:
    """
    Returns the name of the next file found in the current folder, which is set using `set_folder()`. `get_first_file()`
    must have been called first for this to work, any call to `set_folder()` or `open_to_write()` will require starting
    again with `get_first_file()`.

    Returns an empty string if there are no more files in the current folder.

    :rtype: str
    """
    pass    


def get_next_folder() -> str:
    """
    Returns the name of the next folder found in the current folder, which is set using `set_folder()`.
    `get_first_folder()` must have been called first for this to work, any call to `set_folder()` or `open_to_write()`
    will require starting again with `get_first_folder()`.

    Returns an empty string if there are no more folders in the current folder. Does not include . or ..

    :rtype: str
    """
    pass    


def get_raw_folder_file_name(folder_id: int, index: int) -> str:
    """
    Return a particular filename from the file list, the index must be in the range 0 to `get_raw_folder_num_files()` -
    1.

    :param int folder_id: The ID of the folder to check.
    :param int index: The index of the file to return, indices start at 0.
    :rtype: str
    """
    pass    


def get_raw_folder_folder_name(folder_id: int, index: int) -> str:
    """
    Return a particular folder name from the file list, the index must be in the range 0 to
    `get_raw_folder_num_folders()` minus one.

    :param int folder_id: The ID of the folder to check.
    :param int index: The index of the folder to return, indices start at 0.
    :rtype: str
    """
    pass    


def get_raw_folder_num_files(folder_id: int) -> int:
    """
    Returns the number of files that were found when the `open_raw_folder()` was called.

    :param int folder_id: The ID of the folder to check.
    :rtype: int
    """
    pass    


def get_raw_folder_num_folders(folder_id: int) -> int:
    """
    Returns the number of folders that were found when the `open_raw_folder()` was called.

    :param int folder_id: The ID of the folder to check.
    :rtype: int
    """
    pass    


def get_read_path() -> str:
    """
    Returns the directory that contains the application executable on the current platform that the app is running on.

    Note that on Android this path is inaccessible in normal use and will return an empty string.

    :rtype: str
    """
    pass    


def get_windows_drive(index: int) -> str:
    """
    Returns the drive letter of the specified drive, between 0 and `count_windows_drives()` minus one.

    Values outside this range will return an empty string. The returned string will include the drive letter and a
    colon, nothing else.

    This only applies to Windows, other platforms will return an empty string.

    :param int index: The index of the drive to return.
    :rtype: str
    """
    pass    


def get_write_path() -> str:
    """
    Returns the directory that new files will be written to on the current platform that the app is running on.

    :rtype: str
    """
    pass    


def get_zip_extract_complete() -> bool:
    """
    Returns 0 if a zip extraction started with `extract_zip_async()` is in progress, or 1 if it has finished.

    It does not give an indication of if the extraction was successful, only that it has finished.

    :rtype: bool
    """
    pass    


def get_zip_extract_progress() -> float:
    """
    Returns a value between 0 and 100 to represent the progress of the zip extraction started with
    `extract_zip_async()`.

    :rtype: float
    """
    pass    


def is_absolute_path(path: str) -> bool:
    """
    Returns True if the given path is absolute, False if it is relative.

    This varies by platform, so a path beginning "C:/" is consider absolute on Windows but not on Linux, whilst a path
    beginning with a forward slash is considered absolute on Linux but not on Windows. The path may begin with the
    prefix "raw:" or not, both are accepted.

    :param str path: The path to check.
    :rtype: bool
    """
    pass    


def join_paths(path: str, path2: str) -> str:
    """
    Joins two paths together and simplifies them, for example joining a path with ../ will remove the last folder from
    the path.

    A forward slash will be added between them if necessary, if the first path ends in a forward slash and the second
    path starts with a forward slash then one will be removed to make a valid path. Any back slashes will be converted
    to forward slashes. The first path can be relative or absolute, the second path must be relative. This will not be
    checked.

    :param str path: The first part of the path.
    :param str path2: The second part of the path.
    :rtype: str
    """
    pass    


def make_folder(name: str) -> bool:
    r"""
    Creates a folder at the current path.

    By default this is determined by the command `set_folder()`. You can also use a filename beginning with "raw:" to
    create a folder anywhere on the file system, for example `make_folder("raw:C:\\Temp\\MyFolder")`.

    :param str name: The name of the folder create.
    :rtype: bool
    """
    pass    


def open_raw_folder(path: str) -> int:
    """
    Opens a folder any where on the file system and reads the list of files and folders it contains.

    This is done immediately so any changes that occur to the folder after this command will not be noticed, you would
    need to call this command again to get the updated contents. The file path must be absolute for the current device,
    i.e. it must begin with a drive letter and colon on Windows, and a forward slash on all other platforms. The path
    must exist and be accessible to the current app or this command will generate an error. The path may begin with the
    text "raw:" or not, both forms are accepted. This command will return an ID that you can use to access the file list
    that was found, it will remain accessible until you close it with `close_raw_folder()`. Multiple folders can be open
    at the same time, they will each be given a different ID.

    :param str path: The path to the folder to open.
    :rtype: int
    """
    pass    


def open_id_to_read(file_id: int, filename: str) -> None:
    r"""
    Opens a file stored on the local filesystem for reading into the specified ID.

    All platforms are restricted to a single folder for reading and writing so file paths must be relative, not
    absolute. This command will check the special write folder first, and if it cannot locate the file it will check the
    media folder, so you may load images, sounds, and other bundled media files using this command.

    To read a file outside the normal read or write folders you can use "raw:" followed by an absolute path for the
    current platform, for example "raw:C:\\MyFolder\\MyFile.txt" on Windows or "raw:/sdcard/Documents/MyFile.txt" on
    Android.

    On Raspberry Pi you can use this command to open a GPIO pin for reading by using the filename "gpio:" followed by
    the GPIO pin number, for example `open_id_to_read(1, "gpio:4")`, this is case sensitive. You can then use
    `read_byte()` to read from the pin and `close_file()` to close the pin.

    :param int file_id: The ID to use for referencing this file later.
    :param str filename: The filename to open for reading.
    :rtype: None
    """
    pass    


def open_to_read(filename: str) -> int:
    r"""
    Opens a file stored on the local filesystem for reading into the specified ID.

    All platforms are restricted to a single folder for reading and writing so file paths must be relative, not
    absolute. This command will check the special write folder first, and if it cannot locate the file it will check the
    media folder, so you may load images, sounds, and other bundled media files using this command.

    To read a file outside the normal read or write folders you can use "raw:" followed by an absolute path for the
    current platform, for example "raw:C:\\MyFolder\\MyFile.txt" on Windows or "raw:/sdcard/Documents/MyFile.txt" on
    Android.

    On Raspberry Pi you can use this command to open a GPIO pin for reading by using the filename "gpio:" followed by
    the GPIO pin number, for example `open_id_to_read(1, "gpio:4")`, this is case sensitive. You can then use
    `read_byte()` to read from the pin and `close_file()` to close the pin.

    :param str filename: The filename to open for reading.
    :rtype: int
    """
    pass    


def open_id_to_write(file_id: int, filename: str, append: Optional[Union[bool,
                     int]] = False) -> None:
    r"""
    Opens a file stored on the local filesystem for writing into the specified ID.

    All platforms are restricted to a single folder for writing so file paths must be relative, not absolute. This write
    folder is not the same folder as the application itself, so images, sounds, and the application itself cannot be
    overwritten. Files written to this folder can be read using `open_to_read()`. If the file does not exist it will be
    created, if the file does exist it will be overwritten if append is 0. or appended to if append is 1. If a directory
    is given in the filename and does not exist it will be created.

    To write a file outside the normal write folder you can use "raw:" followed by an absolute path for the current
    platform, for example "raw:C:\\MyFolder\\MyFile.txt" on Windows or "raw:/sdcard/Documents/MyFile.txt" on Android. If
    any folders in your chosen path do not exist they will be created.

    On Raspberry Pi you can use this command to open a GPIO pin for writing by using the filename "gpio:" followed by
    the GPIO pin number, for example `open_id_to_write(1, "gpio:4")`, this is case sensitive. You can then use
    `write_byte()` to write 0 or 1 to the pin and `close_file()` to close the pin.

    :param int file_id: The ID to use to reference this file later.
    :param str filename: The filename to open for writing.
    :param Optional[Union[bool, int]] append: Set to True to append to the file, False to overwrite all data (optional,
        default False).
    :rtype: None
    """
    pass    


def open_to_write(filename: str, append: Optional[Union[bool, int]] = False) -> int:
    r"""
    Opens a file stored on the local filesystem for writing into the specified ID.

    All platforms are restricted to a single folder for writing so file paths must be relative, not absolute. This write
    folder is not the same folder as the application itself, so images, sounds, and the application itself cannot be
    overwritten. Files written to this folder can be read using `open_to_read()`. If the file does not exist it will be
    created, if the file does exist it will be overwritten if append is 0. or appended to if append is 1. If a directory
    is given in the filename and does not exist it will be created.

    To write a file outside the normal write folder you can use "raw:" followed by an absolute path for the current
    platform, for example "raw:C:\\MyFolder\\MyFile.txt" on Windows or "raw:/sdcard/Documents/MyFile.txt" on Android. If
    any folders in your chosen path do not exist they will be created.

    On Raspberry Pi you can use this command to open a GPIO pin for writing by using the filename "gpio:" followed by
    the GPIO pin number, for example `open_id_to_write(1, "gpio:4")`, this is case sensitive. You can then use
    `write_byte()` to write 0 or 1 to the pin and `close_file()` to close the pin.

    :param str filename: The filename to open for writing.
    :param Optional[Union[bool, int]] append: Set to True to append to the file, False to overwrite all data (optional,
        default False).
    :rtype: int
    """
    pass    


def read_byte(file_id: int) -> int:
    """
    Reads a 1 byte unsigned integer (0-255) from the given file, which must have been opened for reading.

    :param int file_id: The ID of the file to read.
    :rtype: int
    """
    pass    


def read_float(file_id: int) -> float:
    """
    Reads a 4 byte float from the given file, which must have been opened for reading.

    :param int file_id: The ID of the file to read.
    :rtype: float
    """
    pass    


def read_integer(file_id: int) -> int:
    """
    Reads a 4 byte integer from the given file, which must have been opened for reading.

    :param int file_id: The ID of the file to read.
    :rtype: int
    """
    pass    


def read_line(file_id: int) -> str:
    """
    Reads a new line terminated string from the given file, which must have been opened for reading.

    :param int file_id: The ID of the file to read.
    :rtype: str
    """
    pass    


def read_string(file_id: int) -> str:
    """
    Reads a null terminated string from the given file, which must have been opened for reading.

    Note that this can only read strings in binary form such as those written using `write_string()`, if you are trying
    to read strings separated by new lines then use `read_line()` instead.

    :param int file_id: The ID of the file to read.
    :rtype: str
    """
    pass    


def read_string2(file_id: int) -> str:
    """
    Reads a string from the given file, which must have been opened for reading.

    Note that this can only read strings in binary form such as those written using `write_string2()`, if you are trying
    to read strings separated by new lines then use `read_line()` instead.

    This uses a different method from `read_string()` that is slightly faster but this command can only read strings
    written with `write_string2()`.

    :param int file_id: The ID of the file to read.
    :rtype: str
    """
    pass    


def set_file_pos(file_id: int, position: int) -> None:
    """
    Sets the current read position in the file.

    :param int file_id: The ID of the file to check.
    :param int position: The new position to continue reading from.
    :rtype: None
    """
    pass    


def set_folder(path: str) -> bool:
    r"""
    In normal use only two folders are accessible to your AGK app; the read folder and the write folder.

    The read folder is the location of your executable and includes the media folder. The write folder (which also has
    read permission), is located in a platform safe location and is different depending on the device. On Windows, for
    example, the default write location is C:\\Users\\username\\AppData\\AGKApps\\appName (By default this is a hidden
    folder on Windows and you may have to show hidden files to see it). These are your root folders. Any files
    created/written using `open_to_write()` will be saved into the write folder.

    For simplicity, AGK merges these two read and write folders into a single command set. What this means is that when
    you attempt to open or load a file, AGK will first look in the write folder before looking in the read folder.

    When using `set_folder()`, its behavior is what you'd expect from the CD command in the Windows or Linux console; It
    works from the current directory. For instance, if the current read folder is C:\\games\\myApp\\ then
    `set_folder("images")` will put you in C:\\games\\myApp\\images. Calling the command a second time with
    `set_folder("backgrounds")` will place you at C:\\games\\myApp\\images\\backgrounds\\.

    There are two ways to return to the base path. The first is to call `set_folder("")` using an empty string. The
    other is to precede your path with a forward slash, `set_folder("/stuff")`. This also applies to loading your files
    with other commands as well. Assume you're still located in the images\\backgrounds folders and you want to load
    bk.png located in the base of the read folder. You can simply say `load_image("/bk.png")` which will load
    C:\\games\\myApp\\bk.png.

    Setting the path to a folder that does not exist and using `open_to_write()` will create that folder in the write
    path. `set_folder()` does not check that the folder exists, it just sets an internal path that will be used in the
    next file command. By default, AGK calls `set_folder("media")` as the first thing it does.

    This command returns True on success or False if you use an invalid path such as `set_folder("C:\\")`.

    Note: It is important to remember when setting paths to always use forward slashes instead of backslash. AGK will
    convert them into the appropriate file separator for the given platform.

    If you want to access files outside of the read and write folders you can use the normal file commands such as
    `open_to_read()` with a "raw:" file path, see that command for more details. To access folders outside the read and
    write folders you can use the `open_raw_folder()` commands.

    :param str path: The path of the folder to set.
    :rtype: bool
    """
    pass    


def simplify_path(path: str) -> str:
    r"""
    Removes any occurrences of ../ or ..\\ and shortens the path appropriately by removing folders.

    Also replaces all back slashes with forward slashes, as forward slashes will work on any platform. This works with
    both relative and absolute paths, if the path is absolute then all occurrences of ../ will be removed even if there
    are too many. If the path is relative then any occurrences of ../ that start the path will not be removed. For
    example the relative path "../../MyFile.txt" cannot be simplified further, whereas "C:/../../MyFile.txt" will be
    converted to "C:/MyFile.txt". The path may begin with the prefix "raw:" or not, both are accepted.

    :param str path: The path to simplify.
    :rtype: str
    """
    pass    


def write_byte(file_id: int, value: int) -> None:
    """
    Writes a 1 byte unsigned integer (0-255) to the given file, which must have been opened for writing.

    Note that this command is not meant for human readable files and should only be used for files that will later be
    read with `read_byte()`. To create human readable files use `write_line()`.

    :param int file_id: The ID of the file to modify.
    :param int value: The byte to write.
    :rtype: None
    """
    pass    


def write_float(file_id: int, value: Union[float, int]) -> None:
    """
    Writes a 4 byte float to the given file, which must have been opened for writing.

    Note that this command is not meant for human readable files and should only be used for files that will later be
    read with `read_float()`. To create human readable files use `write_line()`.

    :param int file_id: The ID of the file to modify.
    :param Union[float, int] value: The float to write.
    :rtype: None
    """
    pass    


def write_integer(file_id: int, value: int) -> None:
    """
    Writes a 4 byte integer to the given file, which must have been opened for writing.

    Note that this command is not meant for human readable files and should only be used for files that will later be
    read with `read_integer()`. To create human readable files use `write_line()`.

    :param int file_id: The ID of the file to modify.
    :param int value: The integer to write.
    :rtype: None
    """
    pass    


def write_line(file_id: int, text: str) -> None:
    r"""
    Writes a CR(\\n) terminated string to the given file, which must have been opened for writing.

    :param int file_id: The ID of the file to modify.
    :param str text: The string to write.
    :rtype: None
    """
    pass    


def write_string(file_id: int, text: str) -> None:
    """
    Writes a null terminated string to the given file, which must have been opened for writing.

    Note that this command is not meant for human readable files and should only be used for files that will later be
    read with `read_string()`. To create human readable files use `write_line()`.

    :param int file_id: The ID of the file to modify.
    :param str text: The string to write.
    :rtype: None
    """
    pass    


def write_string2(file_id: int, text: str) -> None:
    """
    Writes a string to the given file, which must have been opened for writing.

    Note that this command is not meant for human readable files and should only be used for files that will later be
    read with `read_string2()`. To create human readable files use `write_line()` This uses a different method from
    `write_string()` that will be faster for AGK to read later, but it is not compatible with `read_string()`, you must
    use `read_string2()` to read strings written with `write_string2()`.

    :param int file_id: The ID of the file to modify.
    :param str text: The string to write.
    :rtype: None
    """
    pass    


def delete_font(font_id: int) -> None:
    """
    Deletes the font at the given ID.

    The font must not currently be in use by any text objects.

    :param int font_id: The ID of the font to delete.
    :rtype: None
    """
    pass    


def get_font_exists(font_id: int) -> bool:
    """
    Returns True if a font has been loaded successfully at the given ID.

    :param int font_id: The ID of the font to check.
    :rtype: bool
    """
    pass    


def get_system_font_exists(name: str) -> bool:
    """
    Returns True if the system contains a font with the given name, False otherwise.

    If True is returned then passing the same filename to `load_font()` will succeed. On iOS this will always return
    False as the system font files are not accessible, however AGK comes with a built in font you can use by using font
    ID 0 with text objects.

    :param str name: The name of the font to check.
    :rtype: bool
    """
    pass    


def load_font(name: str) -> int:
    """
    Loads a font file into AGK, typically in the TrueType format, but anything supported by FreeType should work.

    The `name` parameter can either be a font file located in your media folder or the name of a system font, this
    command will check your media folder first before checking for system fonts. If loading a system font then the file
    extension is optional, for example "Arial.ttf" and "Arial" would both load the system font "Arial" if it exists.
    When loading a system font the filename must not have any folder paths in the filename, i.e. no forward or backward
    slashes.

    To improve performance you should only load a font once. For example if you wanted to use the "Arial" font in
    multiple places then you should load it into an ID then use that ID for all uses, rather than loading multiple
    copies of the Arial font file into separate IDs.

    :param str name: The filename of the font to load.
    :rtype: int
    """
    pass    


def load_font_id(font_id: int, name: str) -> None:
    """
    Loads a font file into AGK, typically in the TrueType format, but anything supported by FreeType should work.

    The `name` parameter can either be a font file located in your media folder or the name of a system font, this
    command will check your media folder first before checking for system fonts. If loading a system font then the file
    extension is optional, for example "Arial.ttf" and "Arial" would both load the system font "Arial" if it exists.
    When loading a system font the filename must not have any folder paths in the filename, i.e. no forward or backward
    slashes.

    To improve performance you should only load a font once. For example if you wanted to use the "Arial" font in
    multiple places then you should load it into an ID then use that ID for all uses, rather than loading multiple
    copies of the Arial font file into separate IDs.

    :param int font_id: The ID to use to reference this font in future.
    :param str name: The filename of the font to load.
    :rtype: None
    """
    pass    


def add_http_header(http_id: int, name: str, value: str) -> None:
    """
    Adds the specified header to all future requests.

    If the header already exists then its value will be overwritten by the new value. If the header is a standard header
    that is normally present then its value will be overwritten by the value you give. If the header is a standard
    header that is normally present and the value you give is the empty string then the standard header will be removed.
    Do not add the colon to either field, it will be added automatically between them. Note that this command does not
    work in the HTML5 version.

    :param int http_id: The ID of the connection to change.
    :param str name: The name of the header to set, e.g. "Content-Type"
    :param str value: The new value for the header
    :rtype: None
    """
    pass    


def close_http_connection(http_id: int) -> None:
    """
    Closes the connection to the server, further connections can be created if you call `set_http_host()` again.

    :param int http_id: The ID of the connection to close.
    :rtype: None
    """
    pass    


def create_http_connection() -> int:
    """
    Creates an HTTP connection ready for use later.

    Returns the ID used to reference it later.

    :rtype: int
    """
    pass    


def delete_http_connection(http_id: int) -> None:
    """
    Deletes a previously created HTTP connection.

    :param int http_id: The ID of the connection to delete.
    :rtype: None
    """
    pass    


def get_http_file(http_id: int, server_filename: str, local_filename: str,
                  post_data: Optional[str] = None) -> bool:
    """
    Downloads an HTTP file from the server specified in `set_http_host()` and saves it to the location specified.

    Also allows you to send POST data to the server which can include variables or file data, e.g. "myvar=5&var2=test".
    This command returns immediately and continues the file download in the background. You can check on the progress of
    the download with `get_http_file_progress()` and `get_http_file_complete()`. The file will then be at the location
    you specified ready for use with AGK.

    :param int http_id: The ID of the connection to use.
    :param str server_filename: The file to request from the server, include everything after the domain part of the
        URL.
    :param str local_filename: The location to save to file, this will be inside the write folder for the current
        device.
    :param Optional[str] post_data: The raw post data to send to the server, note that & and = are special characters
        that separate variables.
    :rtype: bool
    """
    pass    


def get_http_file_complete(http_id: int) -> bool:
    """
    Returns True if the file download previously started with `get_http_file()` has completed, False otherwise.

    Even if this returns True to say the download is finished it may have failed, check `get_http_response_ready()` for
    negative values before assuming the download was successful.

    :param int http_id: The ID of the connection to check.
    :rtype: bool
    """
    pass    


def get_http_file_progress(http_id: int) -> float:
    """
    Returns the progress of the file download as a float value from 0 to 100.

    This should not be relied upon to work out when the download has finished and on some platforms may not produce an
    accurate representation of the download progress.

    Use `get_http_file_complete()` or `get_http_response_ready()` to work out if the download has completed.

    :param int http_id: The ID of the connection to check.
    :rtype: float
    """
    pass    


def get_http_response(http_id: int) -> str:
    """
    Returns the reply from the server from a previous sent `send_http_request_async()` request.

    You must wait for `get_http_response_ready()` to return 1 before calling this command.

    :param int http_id: The ID of the connection to check.
    :rtype: str
    """
    pass    


def get_http_response_ready(http_id: int) -> int:
    """
    Returns 1 if the request previously sent with `send_http_request_async()` has completed.

    You can get the response with `get_http_response()`.

    Returns 0 if the request is still in progress, or -1 if the request failed.

    :param int http_id: The ID of the connection to check.
    :rtype: int
    """
    pass    


def get_http_status_code(http_id: int) -> int:
    """
    Returns the status code that was returned from the server in the response.

    You must wait for `get_http_response_ready()` to return a non-zero value before checking this command, otherwise it
    will return 0. Usually the status code is equal to 200 when the request was successful

    :param int http_id: The ID of the connection to check.
    :rtype: int
    """
    pass    


def get_internet_state() -> bool:
    """
    Returns True if the device is connected to the internet, False if not.

    :rtype: bool
    """
    pass    


def http_decode(text: str) -> str:
    """
    Decodes a URL encoded string.

    It can decode all alphanumeric characters and most non-alphanumeric characters.

    :param str text: The string to decode.
    :rtype: str
    """
    pass    


def http_encode(text: str) -> str:
    """
    Encodes a string so that it can be sent to a server via HTTP without interfering with the HTTP request.

    For example if you wanted to send a POST variable that contained the characters & or = these would look like
    additional variables inside the string you want to send. Using `http_encode()` on this string would turn these
    characters into POST safe values which are then automatically converted back to their original characters once they
    reach something like a PHP script. This uses standard URL encoding for non-alphanumeric characters leaving
    alphanumeric characters alone.

    :param str text: The string to encode.
    :rtype: str
    """
    pass    


def open_browser(url: str) -> None:
    """
    Opens the default browser of the current platform and points it to the page given.

    :param str url: The URL to open.
    :rtype: None
    """
    pass    


def remove_http_header(http_id: int, name: str) -> None:
    """
    Removes a header that you have previously added, if you have not used `add_http_header()` to add a header with the
    given name then this command does nothing.

    If the header name is a standard header that is normally included then this command does not remove it, use
    `add_http_header()` with an empty string instead to overwrite it. If the header name is a standard header that you
    have overwritten then this command returns it to its normal value. Note that this command does not work in the HTML5
    version.

    :param int http_id: The ID of the connection to change.
    :param str name: The name of the header to remove
    :rtype: None
    """
    pass    


def send_http_file(http_id: int, server_filename: str, post_data: str, local_filename: str) -> bool:
    """
    Send a file to the server specified in `set_http_host()`, for example if requesting http:
    www.thegamecreators.com/index.php `server_filename` should be "index.php".

    Also allows you to send POST data to the server which can include variables or file data, e.g. "myvar=5&var2=test".
    This command returns immediately and waits for the server to reply in the background. You can check the status of
    the reply with `get_http_response_ready()` and when it is ready retrieve the response with `get_http_response()`.
    You can check the progress of the upload with `get_http_file_progress()`.

    Does not work when exported to HTML5.

    :param int http_id: The ID of the connection to use.
    :param str server_filename: The file to request from the server, include everything after the domain part of the
        URL.
    :param str post_data: The raw post data to send to the server, note that & and = are special characters that
        separate variables.
    :param str local_filename: The filename of the file you want to send to the server.
    :rtype: bool
    """
    pass    


def send_http_request(http_id: int, server_filename: str, post_data: Optional[str] = None) -> str:
    """
    Send a request to the server specified in `set_http_host()`, for example if requesting http:
    www.thegamecreators.com/index.php `server_filename` should be "index.php".

    This command waits for the server to respond and returns the server reply.

    Does not work when exported to HTML5.

    :param int http_id: The ID of the connection to use.
    :param str server_filename: The file to request from the server, include everything after the domain part of the
        URL.
    :param Optional[str] post_data: The raw post data to send to the server, note that & and = are special characters
        that separate variables.
    :rtype: str
    """
    pass    


def send_http_request_async(http_id: int, server_filename: str,
                            post_data: Optional[str] = None) -> bool:
    """
    Send a request to the server specified in `set_http_host()`, for example if requesting http:
    www.thegamecreators.com/index.php `server_filename` should be "index.php".

    This command returns immediately and waits for the server to reply in the background.

    You can check the status of the reply with `get_http_response_ready()` and when it is ready retrieve the response
    with `get_http_response()`.

    :param int http_id: The ID of the connection to use.
    :param str server_filename: The file to request from the server, include everything after the domain part of the
        URL.
    :param Optional[str] post_data: The raw post data to send to the server, note that & and = are special characters
        that separate variables.
    :rtype: bool
    """
    pass    


def set_http_host(http_id: int, host: str, secure: Union[bool, int], username: Optional[str] = None,
                  password: Optional[str] = None) -> bool:
    """
    Sets the domain of the host you want to connect to, for example to access www.thegamecreators.com/index.php you
    would use a host value of www.thegamecreators.com, do not include the http: that usually goes before it.

    Note that trying to use a specific port with www.thegamecreators.com:8080 may be ignored on some platforms and port
    80 will be used in these cases.

    When exporting to HTML5 note that web browsers limit which servers you can connect to. By default you are limited to
    files hosted by the same server as your app. However if the server sends an Access-Control-Allow-Origin header in
    its response that allows your app's server, then the browser will let you connect to it.

    :param int http_id: The ID of the connection to set.
    :param str host: The domain to connect to.
    :param Union[bool, int] secure: Set to True to use an HTTPS secure connection, False to use a standard HTTP
        connection.
    :param Optional[str] username: The username to send to the server.
    :param Optional[str] password: The password to send to the server.
    :rtype: bool
    """
    pass    


def set_http_timeout(http_id: int, milliseconds: int) -> None:
    """
    Sets the time in milliseconds that AGK will wait for a connection to be made before giving up.

    :param int http_id: The ID of the connection to set.
    :param int milliseconds: The time in milliseconds to wait.
    :rtype: None
    """
    pass    


def set_http_verify_certificate(http_id: int, enabled: int) -> None:
    """
    Sets whether the device should verify the SSL certificate when making a secure connection.

    If the server you are connecting to is using a self signed certificate you will need to set this to False or the
    connection will fail. In all other cases you must leave this at True to ensure a secure connection to the server.
    Turning off verification will turn off protection against man in the middle attacks on SSL connections.

    :param int http_id: The ID of the connection to set.
    :param int enabled: True to verify, False to not verify.
    :rtype: None
    """
    pass    


def copy_image(copy_image_id: int, x: int, y: int, width: int, height: int) -> int:
    """
    Copies a portion of the given image into a new image.

    The x, y, width, height values are in pixels and represent the portion of the image you would like to copy into a
    new image. The new image with have the same size as the width and height values given. If an image already exists
    with the new ID given it must be deleted before calling this command. This is a slow command and should not be
    called every frame.

    :param int copy_image_id: The ID of the image to copy.
    :param int x: The x coordinate of the top left corner of the box to copy.
    :param int y: The y coordinate of the top left corner of the box to copy.
    :param int width: The width of the box to copy.
    :param int height: The height of the box to copy.
    :rtype: int
    """
    pass    


def copy_image_to(new_image_id: int, copy_image_id: int, x: int, y: int, width: int,
                  height: int) -> None:
    """
    Copies a portion of the given image into a new image.

    The x, y, width, height values are in pixels and represent the portion of the image you would like to copy into a
    new image. The new image with have the same size as the width and height values given. If an image already exists
    with the new ID given it must be deleted before calling this command. This is a slow command and should not be
    called every frame.

    :param int new_image_id: The ID of the new image to create, this image must not exist.
    :param int copy_image_id: The ID of the image to copy.
    :param int x: The x coordinate of the top left corner of the box to copy.
    :param int y: The y coordinate of the top left corner of the box to copy.
    :param int width: The width of the box to copy.
    :param int height: The height of the box to copy.
    :rtype: None
    """
    pass    


def create_image_color(red: int, green: int, blue: int, alpha: int) -> int:
    """
    Creates a 1x1 pixel image of a specified color.

    This can be used to texture any object or sprite with a solid color.

    :param int red: The red component of the image (0 to 255).
    :param int green: The green component of the image (0 to 255).
    :param int blue: The blue component of the image (0 to 255).
    :param int alpha: The alpha component of the image (0 to 255), 0 is completely transparent.
    :rtype: int
    """
    pass    


def create_image_id_color(image_id: int, red: int, green: int, blue: int, alpha: int) -> None:
    """
    Creates a 1x1 pixel image of a specified color.

    This can be used to texture any object or sprite with a solid color.

    :param int image_id: The image ID to use for this image.
    :param int red: The red component of the image (0 to 255).
    :param int green: The green component of the image (0 to 255).
    :param int blue: The blue component of the image (0 to 255).
    :param int alpha: The alpha component of the image (0 to 255), 0 is completely transparent.
    :rtype: None
    """
    pass    


def create_render_image(width: int, height: int, format: int, mipmap: Union[bool, int]) -> int:
    """
    Creates a blank image suitable for rendering and returns an ID to reference it.

    This can be used with `set_render_to_image()` to draw things to images. You can create RGBA images for normal
    rendering or depth images for capturing the depth buffer on devices that support it. You can also choose to use
    mipmapping on this image or not, this overrides the global `set_generate_mipmaps()` command for this image only,
    this is because mipmaps on rendered images can be a performance hit so it should not be used unless necessary.
    Mipmaps should only be necessary if you intend to use this image to texture objects in your scene, if you are only
    using this image for full screen shaders you should not use mipmapping on it.

    :param int width: The width of the image to create.
    :param int height: The height of the image to create.
    :param int format: 0 (IMAGE_RGBA)=RGBA (32bit), 1 (IMAGE_DEPTH)=Depth.
    :param Union[bool, int] mipmap: True to use mipmapping on this image, False to turn it off.
    :rtype: int
    """
    pass    


def create_render_image_id(image_id: int, width: int, height: int, format: int, mipmap: Union[bool,
                           int]) -> None:
    """
    Creates a blank image suitable for rendering and returns an ID to reference it.

    This can be used with `set_render_to_image()` to draw things to images. You can create RGBA images for normal
    rendering or depth images for capturing the depth buffer on devices that support it. You can also choose to use
    mipmapping on this image or not, this overrides the global `set_generate_mipmaps()` command for this image only,
    this is because mipmaps on rendered images can be a performance hit so it should not be used unless necessary.
    Mipmaps should only be necessary if you intend to use this image to texture objects in your scene, if you are only
    using this image for full screen shaders you should not use mipmapping on it.

    :param int image_id: The image ID to use for this image.
    :param int width: The width of the image to create.
    :param int height: The height of the image to create.
    :param int format: 0 (IMAGE_RGBA)=RGBA (32bit), 1 (IMAGE_DEPTH)=Depth.
    :param Union[bool, int] mipmap: True to use mipmapping on this image, False to turn it off.
    :rtype: None
    """
    pass    


def decode_qr_code(image_id: int) -> str:
    """
    Attempts to decode a QR code and return the string encoded within it.

    Returns an empty string if it could not find a QR code in the image or failed to decode it. Multiple QR codes in the
    image are likely to cause the decode to fail.

    :param int image_id: The ID of the image to decode, can be an image captured from the camera.
    :rtype: str
    """
    pass    


def delete_all_images() -> None:
    """
    Deletes all images loaded by `load_image()` or `load_subimage()`.

    This also resets the auto image ID to 10000.

    :rtype: None
    """
    pass    


def delete_image(image_id: int) -> None:
    """
    Delete an image from the global store using its ID.

    :param int image_id: The ID of the image to delete.
    :rtype: None
    """
    pass    


def encode_qr_code(text: str, error_mode: int) -> int:
    """
    Encodes the given text into a QR code and returns a new image ID containing that code.

    You can select the amount of error correction included in the code to allow part of the QR code to become damaged
    but still be readable. The higher the error correction mode the more likely it is that a damaged or obscured QR code
    will be read correctly, but higher error correction modes may produce a larger QR code.

    Level 0 still provides a minimal level of error correction rather than none.

    :param str text: The text to encode.
    :param int error_mode: The level of error correction to include in the code from 0 (lowest) to 3 (highest).
    :rtype: int
    """
    pass    


def get_chosen_image() -> int:
    """
    Returns the ID of a newly chosen image picked using `show_choose_image_screen()`.

    If this returns 0 then the user cancelled the process or you have not yet started it with
    `show_choose_image_screen()`. Once you have called this command to retrieve the image ID it will return 0 until
    `show_choose_image_screen()` is called again.

    :rtype: int
    """
    pass    


def get_device_camera_type(camera_id: int) -> int:
    """
    Returns:
     * 1 (CAMERA_TYPE_BACK_FACING) if the given camera ID is a back facing camera,
     * 2 (CAMERA_TYPE_FRONT_FACING) if it is a front facing camera, or
     * 0 (CAMERA_TYPE_UNKNOWN) if this is unknown.

    :param int camera_id: The ID of the device camera you want to check.
    :rtype: int
    """
    pass    


def get_image(x: Union[float, int], y: Union[float, int], width: Union[float, int],
              height: Union[float, int]) -> int:
    """
    Grabs a portion of the backbuffer and creates a new image from it.

    The position and size values must be in screen coordinates. Returns the ID of the new image, this must be deleted
    when you are done with it. To use this command effectively you must know how AGK draws to the back buffer. When
    `sync()` is called AGK updates the positions of all objects with `update()`, then draws them all to the back buffer
    with `render()`, without clearing it, then displays the back buffer to the screen with `swap()`. It then clears the
    back buffer and returns to your code, so if you were to call `get_image()` immediately after `sync()` you would get
    a blank image filled with the current clear color. Therefore if you want to grab an image of the current scene fully
    drawn you must call `render()` then `get_image()` then `clear_screen()` to clear the back buffer so `sync()` doesn't
    redraw everything over a fully drawn depth buffer. If you are already using `update()`, `render()`, and `swap()`
    yourself instead of `sync()`, then call `get_image()` between `render()` and `swap()`.

    This also allows you to do things such as drawing lines to the back buffer, getting an image of the result and then
    clearing it so it doesn't effect what is displayed to the screen.

    Calling `get_image()` is a slow command and it is not recommended that it be called every frame.

    Note that the image produced by this command is not guaranteed to have the same width and height as those given to
    the command, this is because the image is created from a portion of the screen which has a different size on
    different devices. For example, with a virtual resolution of 480x360, you would get an image of the full screen by
    calling this command with a width of 480 and a height of 360, but on an iPod this would produce an image of 480x360
    pixels, whilst on an iPad it would be around 1024x768 pixels. This should not effect how you use the image as
    applying it to a sprite and setting the sprite size to the same 480x360 will make the sprite fill the screen in both
    cases. It simply means that on the iPad you have a higher quality image to play with.

    This also applies to the line drawing commands, drawing a line from 0,0 to 100,100 and then getting an image from
    0,0 to 100,100 will produce a diagonal line image on all devices, but high resolution screen devices will produce an
    image of higher quality containing more pixels. Use `get_image_width()` and `get_image_height()` if you need to know
    the actual size of the image produced in pixels.

    :param Union[float, int] x: The x coordinate of the top left corner of the box to copy.
    :param Union[float, int] y: The y coordinate of the top left corner of the box to copy.
    :param Union[float, int] width: The width of the box to copy.
    :param Union[float, int] height: The height of the box to copy.
    :rtype: int
    """
    pass    


def get_image_id(image_id: int, x: Union[float, int], y: Union[float, int], width: Union[float,
                 int], height: Union[float, int]) -> None:
    """
    Grabs a portion of the backbuffer and creates a new image from it.

    The position and size values must be in screen coordinates. Returns the ID of the new image, this must be deleted
    when you are done with it. To use this command effectively you must know how AGK draws to the back buffer. When
    `sync()` is called AGK updates the positions of all objects with `update()`, then draws them all to the back buffer
    with `render()`, without clearing it, then displays the back buffer to the screen with `swap()`. It then clears the
    back buffer and returns to your code, so if you were to call `get_image()` immediately after `sync()` you would get
    a blank image filled with the current clear color. Therefore if you want to grab an image of the current scene fully
    drawn you must call `render()` then `get_image()` then `clear_screen()` to clear the back buffer so `sync()` doesn't
    redraw everything over a fully drawn depth buffer. If you are already using `update()`, `render()`, and `swap()`
    yourself instead of `sync()`, then call `get_image()` between `render()` and `swap()`.

    This also allows you to do things such as drawing lines to the back buffer, getting an image of the result and then
    clearing it so it doesn't effect what is displayed to the screen.

    Calling `get_image()` is a slow command and it is not recommended that it be called every frame.

    Note that the image produced by this command is not guaranteed to have the same width and height as those given to
    the command, this is because the image is created from a portion of the screen which has a different size on
    different devices. For example, with a virtual resolution of 480x360, you would get an image of the full screen by
    calling this command with a width of 480 and a height of 360, but on an iPod this would produce an image of 480x360
    pixels, whilst on an iPad it would be around 1024x768 pixels. This should not effect how you use the image as
    applying it to a sprite and setting the sprite size to the same 480x360 will make the sprite fill the screen in both
    cases. It simply means that on the iPad you have a higher quality image to play with.

    This also applies to the line drawing commands, drawing a line from 0,0 to 100,100 and then getting an image from
    0,0 to 100,100 will produce a diagonal line image on all devices, but high resolution screen devices will produce an
    image of higher quality containing more pixels. Use `get_image_width()` and `get_image_height()` if you need to know
    the actual size of the image produced in pixels.

    :param int image_id: The image number that will contain the image captured.
    :param Union[float, int] x: The x coordinate of the top left corner of the box to copy.
    :param Union[float, int] y: The y coordinate of the top left corner of the box to copy.
    :param Union[float, int] width: The width of the box to copy.
    :param Union[float, int] height: The height of the box to copy.
    :rtype: None
    """
    pass    


def get_image_exists(image_id: int) -> bool:
    """
    Returns True if the image exists, False if not.

    :param int image_id: The ID of the image to check.
    :rtype: bool
    """
    pass    


def get_image_filename(image_id: int) -> str:
    """
    Returns the file name used to load this image.

    :param int image_id: The ID of the image to check.
    :rtype: str
    """
    pass    


def get_image_height(image_id: int) -> int:
    """
    Returns the height of the image in pixels.

    :param int image_id: The ID of the image to retrieve.
    :rtype: int
    """
    pass    


def get_image_size_from_file(filename: str) -> int:
    """
    Opens the image file to extract the width and height values and then immediately closes the file. This is much
    faster than loading the entire image. This can be useful when using `load_image_resized()` to know how much to scale
    the image before loading it. Both the width and height will be returned in a single integer value, the top 16 bits
    will be the width and the lower 16 bits will be the height. You can extract these values by doing
    ::
        width = result >> 16
        height = result & 0xffff

    :param str filename: The filename of the image to check
    :rtype: int
    """
    pass    


def get_image_width(image_id: int) -> int:
    """
    Returns the width of the image in pixels.

    :param int image_id: The ID of the image to retrieve.
    :rtype: int
    """
    pass    


def get_num_device_cameras() -> int:
    """
    Returns the number of cameras available for `set_device_camera_to_image()`. Currently only works on Android, iOS,
    and Windows.

    :rtype: int
    """
    pass    


def is_choosing_image() -> bool:
    """
    Returns True if AGK is currently displaying a choose image screen and waiting for the user to pick an image.

    When this returns False the user has either cancelled or chosen an image, check `get_chosen_image()` to see what the
    result was.

    :rtype: bool
    """
    pass    


def load_image(filename: str, black_to_alpha: Optional[Union[bool, int]] = False) -> int:
    """
    Loads an image from a file into a specified image ID, can also be used to load an atlas texture that will be used by
    sub images.

    If loading an atlas texture a subimages.txt file must exist detailing all the images contained on it.

    Image width and height must be between 1 and 2048 pixels, some devices may support larger sizes but this is not
    guaranteed. Images do not need to be a power of 2 in size (2,4,8,16,32,etc).

    If you have lots of small images you could combine them into an atlas texture to improve performance.

    :param str filename: The filename of the image to load.
    :param Optional[Union[bool, int]] black_to_alpha: Set to True to override the image's alpha channel to be
        transparent where there are black pixels and opaque otherwise (default False).
    :rtype: int
    """
    pass    


def load_image_id(image_id: int, filename: str, black_to_alpha: Optional[Union[bool,
                  int]] = False) -> None:
    """
    Loads an image from a file into a specified image ID, can also be used to load an atlas texture that will be used by
    sub images.

    If loading an atlas texture a subimages.txt file must exist detailing all the images contained on it.

    Image width and height must be between 1 and 2048 pixels, some devices may support larger sizes but this is not
    guaranteed. Images do not need to be a power of 2 in size (2,4,8,16,32,etc).

    If you have lots of small images you could combine them into an atlas texture to improve performance.

    :param int image_id: ID number for the image.
    :param str filename: The filename of the image to load.
    :param Optional[Union[bool, int]] black_to_alpha: Set to True to override the image's alpha channel to be
        transparent where there are black pixels and opaque otherwise (default False).
    :rtype: None
    """
    pass    


def load_image_id_resized(image_id: int, filename: str, scale_x: Union[float, int],
                          scale_y: Union[float, int]) -> None:
    """
    Loads an image, resizing it in the process.

    This allows you to have one high quality image and then resize it based on the device resolution at runtime, instead
    of having multiple levels of quality. Reducing the image size is preferred to increasing the image size as
    increasing the image size doesn't improve the quality, but both are supported. A value of 1.0 does not change the
    image size, a value less than 1 will make the image smaller, a value greater than 1 will make the image bigger.
    Scaling values must be greater than 0, but can be any fraction, i.e. a scale of 0.6742 would be valid. A scale of
    0.5 would halve the image size, 2.0 would double to image size, and so on. The image can be resized differently in
    the X and Y directions, although this will cause stretching. If you load an atlas texture using this command then
    the subimages.txt file will also have its values resized so that `load_subimage()` will still work correctly. The
    cache parameter is no longer used as the image scaling is now done by the GPU so has almost no impact on
    performance.

    :param int image_id: The ID to use to reference this image in future.
    :param str filename: The name of the file to load.
    :param Union[float, int] scale_x: The amount to scale in the X direction, 1.0 is the original size.
    :param Union[float, int] scale_y: The amount to scale in the Y direction, 1.0 is the original size.
    :rtype: None
    """
    pass    


def load_image_resized(filename: str, scale_x: Union[float, int], scale_y: Union[float,
                       int]) -> int:
    """
    Loads an image, resizing it in the process.

    This allows you to have one high quality image and then resize it based on the device resolution at runtime, instead
    of having multiple levels of quality. Reducing the image size is preferred to increasing the image size as
    increasing the image size doesn't improve the quality, but both are supported. A value of 1.0 does not change the
    image size, a value less than 1 will make the image smaller, a value greater than 1 will make the image bigger.
    Scaling values must be greater than 0, but can be any fraction, i.e. a scale of 0.6742 would be valid. A scale of
    0.5 would halve the image size, 2.0 would double to image size, and so on. The image can be resized differently in
    the X and Y directions, although this will cause stretching. If you load an atlas texture using this command then
    the subimages.txt file will also have its values resized so that `load_subimage()` will still work correctly. The
    cache parameter is no longer used as the image scaling is now done by the GPU so has almost no impact on
    performance.

    :param str filename: The name of the file to load.
    :param Union[float, int] scale_x: The amount to scale in the X direction, 1.0 is the original size.
    :param Union[float, int] scale_y: The amount to scale in the Y direction, 1.0 is the original size.
    :rtype: int
    """
    pass    


def load_subimage(parent_id: int, name: str) -> int:
    """
    Loads a sub image from an atlas texture for use as a standalone image into a specified image ID.

    The subimages.txt file should start with the same name as the image file, for example an atlas image MyImage.png
    would have a subimages file named "MyImage subimages.txt". The subimages file contains a series of rows each
    describing an image that exists within the atlas image. Each line must have the format Name:X:Y:Width:Height with
    the delimiter : used between the fields. The Name field is the name you want to used to reference the sub image when
    loading, this should match the `name` parameter of this `load_subimage()` command. The X:Y fields are the X and Y
    pixel coordinates that represent the top left corner of the subimage, and the Width:Height fields are the size in
    pixels of the sub image. These values are then used to extract your named image from the atlas and load it into its
    own image ID to be used as if it were a normal image. The atlas image must remain loaded for the entire time you are
    using the loaded sub image. Note that when loading a sub image AGK will modify the UV coordinates slightly so that
    the image does not steal pixels from neighboring images during filtering, by default it shifts the UV inwards by 0.5
    pixels. You can override this by setting `set_sprite_uv_border()` to 0 for sprites where you need pixel perfect
    results, but you will have to watch out for pixel bleeding around the edges, and may need to give your sub images a
    1 pixel border of an appropriate color that it can safely steal from when filtering.

    :param int parent_id: The image ID that holds the atlas texture, loaded previously.
    :param str name: The name of the sub image as stored in subimages.txt. Do not use a path before the name.
    :rtype: int
    """
    pass    


def load_subimage_id(image_id: int, parent_id: int, name: str) -> None:
    """
    Loads a sub image from an atlas texture for use as a standalone image into a specified image ID.

    The subimages.txt file should start with the same name as the image file, for example an atlas image MyImage.png
    would have a subimages file named "MyImage subimages.txt". The subimages file contains a series of rows each
    describing an image that exists within the atlas image. Each line must have the format Name:X:Y:Width:Height with
    the delimiter : used between the fields. The Name field is the name you want to used to reference the sub image when
    loading, this should match the `name` parameter of this `load_subimage()` command. The X:Y fields are the X and Y
    pixel coordinates that represent the top left corner of the subimage, and the Width:Height fields are the size in
    pixels of the sub image. These values are then used to extract your named image from the atlas and load it into its
    own image ID to be used as if it were a normal image. The atlas image must remain loaded for the entire time you are
    using the loaded sub image. Note that when loading a sub image AGK will modify the UV coordinates slightly so that
    the image does not steal pixels from neighboring images during filtering, by default it shifts the UV inwards by 0.5
    pixels. You can override this by setting `set_sprite_uv_border()` to 0 for sprites where you need pixel perfect
    results, but you will have to watch out for pixel bleeding around the edges, and may need to give your sub images a
    1 pixel border of an appropriate color that it can safely steal from when filtering.

    :param int image_id: The image ID to use to reference this image later.
    :param int parent_id: The image ID that holds the atlas texture, loaded previously.
    :param str name: The name of the sub image as stored in subimages.txt. Do not use a path before the name.
    :rtype: None
    """
    pass    


def print_image(image_id: int, size: Union[float, int]) -> None:
    """
    Prints an image to a connected printer.

    This command is not guaranteed to work on all platforms. The size parameter determines how large the image is on the
    page, a value of 100 makes it use as much of the page as possible, 50 makes it use half this amount, 25 a quarter
    and so on.

    :param int image_id: The ID of the image to print.
    :param Union[float, int] size: The amount of space to use on the page, between 0 and 100.
    :rtype: None
    """
    pass    


def resize_image(image_id: int, width: int, height: int) -> None:
    """
    Resizes an image to new width and height.

    If the image is an atlas image then its subimages.txt values will also be resized so that `load_subimage()` will
    still work. Note that if you have previously used `load_subimage()` on this image then resizing it will make those
    sub images display incorrectly. This command will not work on sub images themselves.

    :param int image_id: The ID of the image to resize.
    :param int width: The new width of the image.
    :param int height: The new height of the image.
    :rtype: None
    """
    pass    


def save_image(image_id: int, filename: str) -> None:
    """
    Saves the image at the given ID to the file name specified.

    The file will be placed in the app's write folder at the location currently specified by `set_folder()`.
    Alternatively you can specify a path beginning with a forward slash to choose a location from the root of the write
    folder, ignoring any `set_folder()` folder.

    It is recommended that you use the extension ".png" at the end of the filename to save in PNG format. Some platforms
    may support additional extensions such as ".jpg" but this is not guaranteed to work on all platforms.

    :param int image_id: The ID of the image to change.
    :param str filename: The filename of the saved image.
    :rtype: None
    """
    pass    


def set_device_camera_to_image(camera_id: int, image_id: int) -> bool:
    """
    Using an image ID greater than zero will stream the device camera to the chosen image.

    The image must not currently exist, it will be created by this command. Use an `image_id` of 0 to stop streaming,
    this will also delete the image.

    The `camera_id` parameter is used when the device has multiple cameras, for example front and back facing cameras.
    Typically 0 refers the back facing camera. Use `get_num_device_cameras()` to see how many cameras this device has
    and `get_device_camera_type()` to check whether it is front or back facing. This parameter is ignored if the
    `image_id` is 0.

    You can only have one device camera active at once, so to switch from back to front facing cameras you must first
    call this command with `image_id` set to 0 to stop the capture, then start it again with the new `camera_id`.

    Returns True if it was successful, False if there was a problem or the current platform doesn't support this
    command. This is currently supported on iOS, Android 4.0.3 and above, and Windows.

    :param int camera_id: The ID of the device camera you want to use, could be back or front facing camera.
    :param int image_id: The imageID you want to use for this image, must not exist.
    :rtype: bool
    """
    pass    


def set_image_mag_filter(image_id: int, mode: int) -> None:
    """
    Sets the filter for textures when the texture is larger than the screen space it is displayed in.

    You can use a mode of 0 (FILTER_NEAREST) to use the nearest pixel, which will appear blocky, or 1 (FILTER_LINEAR) to
    use a linear filter which will look blurry. When the image matches the screen space exactly then both filters will
    look the same when there is a slight difference, nearest tends to be sharper, but may flicker as it changes pixel
    choice.

    :param int image_id: The ID of the image to change.
    :param int mode: The filter mode to use, 0 (FILTER_NEAREST)=nearest, 1 (FILTER_LINEAR)=linear.
    :rtype: None
    """
    pass    


def set_image_mask(dst_image_id: int, src_image_id: int, dst_channel: int, src_channel: int, x: int,
                   y: int) -> None:
    """
    Copies a color channel from one image to another.

    You can specify the source and destination channels using the values 1 (COLOR_CHANNEL_RED), 2 (COLOR_CHANNEL_GREEN),
    3 (COLOR_CHANNEL_BLUE), and 4 (COLOR_CHANNEL_ALPHA) to represent red, green, blue, and alpha respectively.

    This is a slow command and should not be called every frame.

    The x,y offset values allow you to offset the source image on te destination image so a small source image can be
    used to mask any part of a large image. Any part of the large image outside the size of the small image will be left
    unchanged. negative offset values are supported to shift the source image off the top left of the destination image.
    If you add some transparent pixels to an image that currently has none, and you use the image on a sprite, then be
    sure to use `set_sprite_transparency()` to make the sprite transparent.

    :param int dst_image_id: The ID of the image to change.
    :param int src_image_id: The ID of the image to use as a source.
    :param int dst_channel: The ID of the color channel to use as the destination, 1-4 for RGBA.
    :param int src_channel: The ID of the color channel to use as the source, 1-4 for RGBA.
    :param int x: The x offset for the source image on the destination image.
    :param int y: The y offset for the source image on the destination image.
    :rtype: None
    """
    pass    


def set_image_min_filter(image_id: int, mode: int) -> None:
    """
    Sets the filter for textures when the texture is smaller than the screen space it is displayed in.

    You can use a mode of 0 (FILTER_NEAREST) to use the nearest pixel, which will appear blocky, or 1 (FILTER_LINEAR) to
    use a linear filter which will look blurry. When the image matches the screen space exactly then both filters will
    look the same when there is a slight difference, nearest tends to be sharper, but may flicker as it changes pixel
    choice.

    :param int image_id: The ID of the image to change.
    :param int mode: The filter mode to use, 0 (FILTER_NEAREST)=nearest, 1 (FILTER_LINEAR)=linear.
    :rtype: None
    """
    pass    


def set_image_subimages(image_id: int, filename: str) -> None:
    """
    Sets the sub image data for an atlas image, which is the layout of where each sub image is located within the atlas
    image. Normally this is loaded automatically from the subimages.txt file when the image is loaded, but if this is
    not possible then this command can be used to set that data. The file must be a valid subimages.txt file in the same
    format as that specified in `load_subimage()` Unlike the normal load image command the file does not need to be
    named subimages.txt, it can have any name and path.

    :param int image_id: The ID of the image to change.
    :param str filename: The path to the sub images file.
    :rtype: None
    """
    pass    


def set_image_transparent_color(image_id: int, red: int, green: int, blue: int) -> None:
    """
    Turns a particular color completely transparent in the chosen image.

    This is a slow command and should not be called every frame.

    :param int image_id: The ID of the image to change.
    :param int red: The red component of the color to set as transparent.
    :param int green: The red component of the color to set as transparent.
    :param int blue: The red component of the color to set as transparent.
    :rtype: None
    """
    pass    


def set_image_wrap_u(image_id: int, wrap_mode: int) -> None:
    """
    Sets the UV wrap mode of the image when the U coordinate goes outside the range 0-1.

    The default is mode 0 which clamps the pixel value to the last valid pixel, mode 1 repeats the texture starting from
    the opposite side.

    To use UV values outside 0-1 successfully on all platforms the image in question must be a power of 2 in width and
    height, and not be part of an atlas texture. This applies to both clamp and repeat.

    :param int image_id: The ID of the image to change.
    :param int wrap_mode: The wrap mode to use, 0 (WRAP_CLAMP)=clamp, 1 (WRAP_REPEAT)=repeat.
    :rtype: None
    """
    pass    


def set_image_wrap_v(image_id: int, wrap_mode: int) -> None:
    """
    Sets the UV wrap mode of the image when the V coordinate goes outside the range 0-1.

    The default is mode 0 which clamps the pixel value to the last valid pixel, mode 1 repeats the texture starting from
    the opposite side.

    To use UV values outside 0-1 successfully on all platforms the image in question must be a power of 2 in width and
    height, and not be part of an atlas texture. This applies to both clamp and repeat.

    :param int image_id: The ID of the image to change.
    :param int wrap_mode: The wrap mode to use, 0 (WRAP_CLAMP)=clamp, 1 (WRAP_REPEAT)=repeat.
    :rtype: None
    """
    pass    


def show_choose_image_screen() -> bool:
    """
    Presents the user with an option to choose an image stored on their current platform, for example a photo on a phone
    or an image saved on a PC.

    This does not immediately capture the image, depending on the platform your app may continue running in the
    background whilst the user is choosing an image, or it may pause execution whilst the image is chosen. In any case
    you must assume your app continues running but is no longer visible, use `is_choosing_image()` to check when the
    user returns from the image choosing process, and `get_chosen_image()` to discover the result of the process.

    This function returns True if it was successful in displaying the choose screen, False otherwise.

    :rtype: bool
    """
    pass    


def add_virtual_button(button_id: int, x: Union[float, int], y: Union[float, int],
                       size: Union[float, int]) -> None:
    """
    Creates an on-screen button that can be controlled by a touch screen, mouse, or other pointer device.

    These are separate to physical joystick buttons or keyboard keys so you could have a virtual button with ID 1 and a
    real joystick button with ID 1. You may have up to 100 virtual buttons on screen at the same time. If a virtual
    button is on screen and is clicked or touched the button will capture that event and `get_raw_mouse_left_state()`
    will return 0 (up), and a touch event will not be generated for that action.

    :param int button_id: The ID of the virtual button to create, must be in the range 1 to 100.
    :param Union[float, int] x: The x position of the center of the button in screen coordinates.
    :param Union[float, int] y: The y position of the center of the button in screen coordinates.
    :param Union[float, int] size: The diameter of the button in screen coordinates.
    :rtype: None
    """
    pass    


def add_virtual_joystick(joystick_id: int, x: Union[float, int], y: Union[float, int],
                         size: Union[float, int]) -> None:
    """
    Creates an on-screen joystick that can be controlled by a touch screen, mouse, or other pointer device.

    These are separate to physical joysticks so you could have a virtual joystick with ID 1 and a real joystick with ID
    1. You may have up to 4 virtual joysticks on screen at the same time.

    If a virtual joystick is on screen and is clicked or touched the joystick will capture that event and
    `get_raw_mouse_left_state()` will return 0 (up), and a touch event will not be generated for that action.

    :param int joystick_id: The ID of the virtual joystick to create, must be in the range 1 to 4.
    :param Union[float, int] x: The x position of the center of the joystick in screen coordinates.
    :param Union[float, int] y: The y position of the center of the joystick in screen coordinates.
    :param Union[float, int] size: The diameter of the joystick in screen coordinates.
    :rtype: None
    """
    pass    


def create_edit_box() -> int:
    """
    Create an edit box that can be positioned anywhere on screen.

    It returns the ID used to reference this edit box later.

    :rtype: int
    """
    pass    


def create_edit_box_id(editbox_id: int) -> None:
    """
    Create an edit box that can be positioned anywhere on screen.

    It returns the ID used to reference this edit box later.

    :param int editbox_id: The ID to use for this edit box.
    :rtype: None
    """
    pass    


def delete_edit_box(editbox_id: int) -> None:
    """
    Deletes any edit box at the given ID.

    :param int editbox_id: The ID of the edit box to delete.
    :rtype: None
    """
    pass    


def delete_virtual_button(button_id: int) -> None:
    """
    Deletes the virtual button at the given `button_id`. No further virtual button commands can be called on this
    `button_id` unless it is recreated using `add_virtual_button()`.

    :param int button_id: The ID of the virtual button to delete.
    :rtype: None
    """
    pass    


def delete_virtual_joystick(joystick_id: int) -> None:
    """
    Deletes a virtual joystick and removes it from screen.

    No further virtual joystick commands can be called on this `joystick_id` unless it is recreated using
    `add_virtual_joystick()`.

    :param int joystick_id: The ID of the virtual joystick to delete.
    :rtype: None
    """
    pass    


def fix_edit_box_to_screen(editbox_id: int, fixed: Union[bool, int]) -> None:
    """
    By default sprites and edit boxes are created in world coordinates and `set_view_offset()` can be used to move
    around the world.

    Use this command to instead fix the edit box to the screen so it will move with the viewport when the viewport is
    moved around. You can still reposition an edit box that is fixed to the screen, it only affects what happens when
    the viewport is moved.

    :param int editbox_id: The ID of the edit box to modify.
    :param Union[bool, int] fixed: False to move when the view port moves, True to stay fixed to the screen no matter
        where the viewport is moved to.
    :rtype: None
    """
    pass    


def get_button_pressed(button_id: int) -> bool:
    """
    This function returns True if the specified button has just been pressed, then returns False while the button is
    held down.

    The AGK buttons are an emulated input method that uses whatever device inputs are available to produce 5 buttons. If
    a real joystick is found then the first 5 buttons from that will be used for the AGK button commands. Otherwise the
    AGK looks for a full-size keyboard and if found will use the following keys in the following order Space, E, R, Q,
    Control, to represent buttons 1 to 5 respectively. If neither a joystick nor keyboard is found then a virtual button
    is created that will appear on screen and can be pressed with either touch screen inputs or a mouse. Every platform
    is guaranteed to have a method of activating the AGK buttons.

    :param int button_id: The ID of the button to check, must be in the range 1 to 5 inclusive.
    :rtype: bool
    """
    pass    


def get_button_released(button_id: int) -> bool:
    """
    This function returns True if the specified button has just been released, then returns False whilst the button is
    up.

    The AGK buttons are an emulated input method that uses whatever device inputs are available to produce 5 buttons. If
    a real joystick is found then the first 5 buttons from that will be used for the AGK button commands. Otherwise the
    AGK looks for a full-size keyboard and if found will use the following keys in the following order Space, E, R, Q,
    Control, to represent buttons 1 to 5 respectively. If neither a joystick nor keyboard is found then a virtual button
    is created that will appear on screen and can be pressed with either touch screen inputs or a mouse. Every platform
    is guaranteed to have a method of activating the AGK buttons.

    :param int button_id: The ID of the button to check, must be in the range 1 to 5 inclusive.
    :rtype: bool
    """
    pass    


def get_button_state(button_id: int) -> int:
    """
    This function returns 1 (STATE_DOWN) if the specified button is currently being held down, otherwise 0 (STATE_UP).

    The AGK buttons are an emulated input method that uses whatever device inputs are available to produce 5 buttons.

    If a real joystick is found then the first 5 buttons from that will be used for the AGK button commands. Otherwise
    the AGK looks for a full-size keyboard and if found will use the following keys in the following order Space, E, R,
    Q, Control, to represent buttons 1 to 5 respectively. If neither a joystick nor keyboard is found then a virtual
    button is created that will appear on screen and can be pressed with either touch screen inputs or a mouse. Every
    platform is guaranteed to have a method of activating the AGK buttons.

    :param int button_id: The ID of the button to check, must be in the range 1 to 5 inclusive.
    :rtype: int
    """
    pass    


def get_current_edit_box() -> int:
    """
    Returns the ID of the currently active edit box, only one edit box may focus at a time.

    If no edit box currently has focus it returns 0.

    :rtype: int
    """
    pass    


def get_direction_angle() -> float:
    """
    Returns the current direction angle with respect to x=0, y=-1 (up).

    The angle will be in the range 0-360. The direction is an emulated value that will use an accelerometer where
    available or keyboard arrow keys if not.

    :rtype: float
    """
    pass    


def get_direction_speed() -> float:
    """
    Returns the current direction speed as an absolute value between 0 and 1.4, this is used with
    `get_direction_angle()` to determine the extent of the direction.

    The direction is an emulated value that will use an accelerometer where available or keyboard arrow keys if not.

    :rtype: float
    """
    pass    


def get_direction_x() -> float:
    """
    Returns the current direction value in the X direction.

    The direction is an emulated value that will use an accelerometer where available or keyboard arrow keys if not.

    :rtype: float
    """
    pass    


def get_direction_y() -> float:
    """
    Returns the current direction value in the Y direction.

    The direction is an emulated value that will use an accelerometer where available or keyboard arrow keys if not.

    :rtype: float
    """
    pass    


def get_edit_box_active(editbox_id: int) -> bool:
    """
    Returns True if the edit box is enabled and can be clicked on, False if the edit box is disabled and cannot be
    changed.

    :param int editbox_id: The ID of the edit box to check.
    :rtype: bool
    """
    pass    


def get_edit_box_changed(editbox_id: int) -> bool:
    """
    Returns True if the edit box has just lost focus, meaning the text may have changed and is not likely to change
    again in the short term.

    :param int editbox_id: The ID of the edit box to check.
    :rtype: bool
    """
    pass    


def get_edit_box_cursor_position(editbox_id: int) -> int:
    """
    Gets the cursor to the specified position in the text, i.e.

    position 0 is left of the first character, position 1 is left of the second character, and so on.

    :param int editbox_id: The ID of the edit box to check.
    :rtype: int
    """
    pass    


def get_edit_box_depth(index: int) -> int:
    """
    Returns the current depth of the edit box with 0 being the front of the screen and 10000 being the back.

    :param int index: The ID of the edit box to check.
    :rtype: int
    """
    pass    


def get_edit_box_exists(editbox_id: int) -> bool:
    """
    Returns True if an edit box with the given ID exists, False otherwise.

    :param int editbox_id: The ID of the edit box to check.
    :rtype: bool
    """
    pass    


def get_edit_box_has_focus(editbox_id: int) -> bool:
    """
    Returns True if the edit box has been clicked on and is accepting input.

    :param int editbox_id: The ID of the edit box to check.
    :rtype: bool
    """
    pass    


def get_edit_box_height(editbox_id: int) -> float:
    """
    Returns the current height of the edit box.

    This is the height of the actual text entry box, any border will extend beyond this value.

    :param int editbox_id: The ID of the edit box to check.
    :rtype: float
    """
    pass    


def get_edit_box_lines(editbox_id: int) -> int:
    """
    Returns the number of lines of text the user has entered into the edit box.

    :param int editbox_id: The ID of the edit box to check.
    :rtype: int
    """
    pass    


def get_edit_box_text(editbox_id: int) -> str:
    """
    Returns the text currently being displayed in the edit box.

    :param int editbox_id: The ID of the edit box to check.
    :rtype: str
    """
    pass    


def get_edit_box_visible(editbox_id: int) -> bool:
    """
    Returns True if the edit box is visible and can be clicked on, False if the edit box is invisible and cannot be
    changed.

    :param int editbox_id: The ID of the edit box to check.
    :rtype: bool
    """
    pass    


def get_edit_box_width(editbox_id: int) -> float:
    """
    Returns the current width of the edit box.

    This is the width of the actual text entry box, any border will extend beyond this value.

    :param int editbox_id: The ID of the edit box to check.
    :rtype: float
    """
    pass    


def get_edit_box_x(editbox_id: int) -> float:
    """
    Returns the current X position of the edit box.

    This is the top left corner of the actual text entry box, any border will extend to the left of this point.

    :param int editbox_id: The ID of the edit box to check.
    :rtype: float
    """
    pass    


def get_edit_box_y(editbox_id: int) -> float:
    """
    Returns the current Y position of the edit box.

    This is the top left corner of the actual text entry box, any border will extend above this point.

    :param int editbox_id: The ID of the edit box to check.
    :rtype: float
    """
    pass    


def get_joystick_x() -> float:
    """
    The AGK joystick is an emulated input method that uses whatever device inputs are available to produce a joystick
    style input in the range -1 to 1.

    If a physical joystick is attached to the system then that will be used, otherwise if a full sized keyboard is found
    the keys W,A,S,D will be used as the four directions for the joystick. If neither of these exist then a virtual
    joystick will be created on screen that can be controlled with either a touch screen or mouse. The virtual joystick
    used will be index 1, if it already exists its values will be fed into this emulated joystick command. You may
    position this virtual joystick at a position of your choice on screen using `set_joystick_screen_position()`. Every
    platform is guaranteed to have a method of generating an AGK joystick X value.

    :rtype: float
    """
    pass    


def get_joystick_y() -> float:
    """
    The AGK joystick is an emulated input method that uses whatever device inputs are available to produce a joystick
    style input in the range -1 to 1.

    If a physical joystick is attached to the system then that will be used, otherwise if a full sized keyboard is found
    the keys W,A,S,D will be used as the four directions for the joystick. If neither of these exist then a virtual
    joystick will be created on screen that can be controlled with either a touch screen or mouse. The virtual joystick
    used will be index 1, if it already exists its values will be fed into this emulated joystick command. You may
    position this virtual joystick at a position of your choice on screen using `set_joystick_screen_position()`. Every
    platform is guaranteed to have a method of generating an AGK joystick Y value.

    :rtype: float
    """
    pass    


def get_last_char() -> int:
    """
    Returns the unicode value of the last character input.

    :rtype: int
    """
    pass    


def get_pointer_pressed() -> bool:
    """
    This is an emulated input method that uses whatever device inputs are available to produce a screen pointer.

    If the device has a mouse then this will return True if the left mouse button is pressed, False if not.

    Otherwise the AGK will check for a touch screen and, if found, return True if one or more touch events exist.

    On devices that have neither mice nor touch screens the AGK will attempt to create some form of screen pointer
    controlled by analog sticks or similar.

    :rtype: bool
    """
    pass    


def get_pointer_released() -> bool:
    """
    This is an emulated input method that uses whatever device inputs are available to produce a screen pointer.

    If the device has a mouse then this will return True if the left mouse button is released, False if not.

    Otherwise the AGK will check for a touch screen and, if found, return True if one or more touch events are released.

    On devices that have neither mice nor touch screens the AGK will attempt to create some form of screen pointer
    controlled by analog sticks or similar.

    :rtype: bool
    """
    pass    


def get_pointer_state() -> int:
    """
    This is an emulated input method that uses whatever device inputs are available to produce a screen pointer.

    If the device has a mouse then this will return 1 (STATE_DOWN) if the left mouse button is currently down, 0
    (STATE_UP) if not.

    Otherwise the AGK will check for a touch screen and, if found, return 1 (STATE_DOWN) if one or more touch events are
    currently being pressed.

    On devices that have neither mice nor touch screens the AGK will attempt to create some form of screen pointer
    controlled by analog sticks or similar.

    :rtype: int
    """
    pass    


def get_pointer_x() -> float:
    """
    This is an emulated input method that uses whatever device inputs are available to produce a screen pointer.

    If the device has a mouse then this returns the current X position of the mouse. Otherwise the AGK will check for a
    touch screen and, if found, will return the X position of the most recent touch event. If no events are taking place
    it is the last X position recorded by a touch event. On devices that have neither mice nor touch screens the AGK
    will attempt to create some form of screen pointer controlled by analog sticks or similar.

    This coordinate will be in view coordinates, if you are offsetting the view port you may want to convert it to world
    coordinates using `screen_to_world_x()`.

    :rtype: float
    """
    pass    


def get_pointer_y() -> float:
    """
    This is an emulated input method that uses whatever device inputs are available to produce a screen pointer.

    If the device has a mouse then this returns the current Y position of the mouse. Otherwise the AGK will check for a
    touch screen and, if found, will return the Y position of the most recent touch event. If no events are taking place
    it is the last Y position recorded by a touch event. On devices that have neither mice nor touch screens the AGK
    will attempt to create some form of screen pointer controlled by analog sticks or similar.

    This coordinate will be in view coordinates, if you are offsetting the view port you may want to convert it to world
    coordinates using `screen_to_world_y()`.

    :rtype: float
    """
    pass    


def get_text_input() -> str:
    """
    Returns the string that the user input.

    It will contain characters encoded with UTF-8, some devices may also allow newline characters to be returned. This
    commands value is not defined until `get_text_input_completed()` returns 1.

    :rtype: str
    """
    pass    


def get_text_input_cancelled() -> bool:
    """
    Returns True if the user cancelled the text input, False if not.

    This commands value is not defined until `get_text_input_completed()` returns True.

    :rtype: bool
    """
    pass    


def get_text_input_completed() -> bool:
    """
    Returns True for the frame that the user completed inputting text (successfully or not).

    After completion this command will return to False. At this point you can check if the user cancelled the input by
    using `get_text_input_cancelled()`.

    :rtype: bool
    """
    pass    


def get_text_input_state() -> int:
    """
    Returns 0 (INPUT_TEXT_ACTIVE) if the user is currently inputting text, 1 (INPUT_TEXT_DONE) if not.

    :rtype: int
    """
    pass    


def get_virtual_button_exists(button_id: int) -> bool:
    """
    Returns True if a virtual button exists at the given `button_id`, False otherwise.

    :param int button_id: The ID of the virtual button to check.
    :rtype: bool
    """
    pass    


def get_virtual_button_pressed(button_id: int) -> bool:
    """
    Returns True if a virtual button was pressed this frame, after the initial press this function will return to False.

    Use `get_virtual_button_state()` to check if a virtual button is up or down.

    :param int button_id: The ID of the virtual button to check.
    :rtype: bool
    """
    pass    


def get_virtual_button_released(button_id: int) -> bool:
    """
    Returns True if a virtual button was released this frame, after the initial release this function will return to
    False.

    Use `get_virtual_button_state()` to check if a virtual button is up or down.

    :param int button_id: The ID of the virtual button to check.
    :rtype: bool
    """
    pass    


def get_virtual_button_state(button_id: int) -> int:
    """
    Returns 1 (STATE_DOWN) if a virtual button is currently down, 0 (STATE_UP) if it is up.

    Use `get_virtual_button_pressed()` or `get_virtual_button_released()` to check for the instance a button is pressed
    or released.

    :param int button_id: The ID of the virtual button to check.
    :rtype: int
    """
    pass    


def get_virtual_joystick_exists(joystick_id: int) -> bool:
    """
    Returns True if a virtual joystick exists at the given `joystick_id`. Must be in the range 1 to 4.

    :param int joystick_id: The ID of the virtual joystick to check.
    :rtype: bool
    """
    pass    


def get_virtual_joystick_x(joystick_id: int) -> float:
    """
    Returns the X value of the virtual joystick at the given `joystick_id`. This will be in the range -1.0 to 1.0 with 0
    being centered. When the user is not interacting with the virtual joystick this will return 0.

    :param int joystick_id: The ID of the virtual joystick to check.
    :rtype: float
    """
    pass    


def get_virtual_joystick_y(joystick_id: int) -> float:
    """
    Returns the Y value of the virtual joystick at the given `joystick_id`. This will be in the range -1.0 to 1.0 with 0
    being centered. When the user is not interacting with the virtual joystick this will return 0.

    :param int joystick_id: The ID of the virtual joystick to check.
    :rtype: float
    """
    pass    


def set_button_screen_position(button_id: int, x: Union[float, int], y: Union[float, int],
                               size: Union[float, int]) -> None:
    """
    This function positions a virtual button at the given position only if it is necessary for this device, for example
    if a real joystick or keyboard are present then this command will have no noticeable effect.

    It is recommended you call this command anyway, just in case a virtual button is needed.

    The AGK buttons are an emulated input method that uses whatever device inputs are available to produce 5 buttons. If
    a real joystick is found then the first 5 buttons from that will be used for the AGK button commands. Otherwise the
    AGK looks for a full-size keyboard and if found will use the following keys in the following order Space, E, R, Q,
    Control, to represent buttons 1 to 5 respectively. If neither a joystick nor keyboard is found then a virtual button
    is created that will appear on screen and can be pressed with either touch screen inputs or a mouse. Every platform
    is guaranteed to have a method of activating the AGK buttons. If a virtual button is created it will be centered on
    the given X,Y position.

    :param int button_id: The ID of the button to position, must be in the range 1 to 5 inclusive.
    :param Union[float, int] x: The X coordinate of the button position in screen coordinates.
    :param Union[float, int] y: The Y coordinate of the button position in screen coordinates.
    :param Union[float, int] size: The diameter of the button position in screen coordinates.
    :rtype: None
    """
    pass    


def set_cursor_blink_time(seconds: Union[float, int]) -> None:
    """
    Sets the time in seconds between the cursor appearing and disappearing in the fullscreen edit box.

    :param Union[float, int] seconds: The time in seconds.
    :rtype: None
    """
    pass    


def set_edit_box_active(editbox_id: int, active: Union[bool, int]) -> None:
    """
    Toggles the active status of this edit box, when active is set to 1 the edit box can be clicked on, gain focus and
    be changed, when set to 0 the edit box cannot be changed nor gain focus.

    :param int editbox_id: The ID of the edit box to modify.
    :param Union[bool, int] active: The new state of the edit box, True for active, False for inactive.
    :rtype: None
    """
    pass    


def set_edit_box_background_color(editbox_id: int, red: int, green: int, blue: int,
                                  alpha: int) -> None:
    """
    Sets the color of the main text entry box.

    :param int editbox_id: The ID of the edit box to modify.
    :param int red: The red component of the color (0 to 255).
    :param int green: The green component of the color (0 to 255).
    :param int blue: The blue component of the color (0 to 255).
    :param int alpha: The alpha component of the color (0 to 255). 255 is fully opaque.
    :rtype: None
    """
    pass    


def set_edit_box_background_image(editbox_id: int, image_id: int) -> None:
    """
    Sets an image to use for the background, this can be used together with the background color.

    Use 0 to remove the background image.

    :param int editbox_id: The ID of the edit box to modify.
    :param int image_id: The ID of the image to use.
    :rtype: None
    """
    pass    


def set_edit_box_border_color(editbox_id: int, red: int, green: int, blue: int, alpha: int) -> None:
    """
    Sets the color of any border present.

    You can also use an image by using `set_edit_box_border_image()`.

    :param int editbox_id: The ID of the edit box to modify.
    :param int red: The red component of the color (0 to 255).
    :param int green: The green component of the color (0 to 255).
    :param int blue: The blue component of the color (0 to 255).
    :param int alpha: The alpha component of the color (0 to 255). 255 is fully opaque.
    :rtype: None
    """
    pass    


def set_edit_box_border_image(editbox_id: int, image_id: int) -> None:
    """
    Sets an image to use for the border, this can be used together with the border color.

    Use 0 to remove the border image.

    :param int editbox_id: The ID of the edit box to modify.
    :param int image_id: The ID of the image to use.
    :rtype: None
    """
    pass    


def set_edit_box_border_size(editbox_id: int, size: Union[float, int]) -> None:
    """
    Sets the size of the border in world coordinates that will surround the text entry box.

    For example a value of 2 would add a 2 pixel border around the entry box.

    :param int editbox_id: The ID of the edit box to modify.
    :param Union[float, int] size: The size of the border.
    :rtype: None
    """
    pass    


def set_edit_box_cursor_blink_time(editbox_id: int, seconds: Union[float, int]) -> None:
    """
    Sets the time in seconds between the cursor being visible and invisible in the text entry box.

    :param int editbox_id: The ID of the edit box to modify.
    :param Union[float, int] seconds: The time in seconds.
    :rtype: None
    """
    pass    


def set_edit_box_cursor_color(editbox_id: int, red: int, green: int, blue: int) -> None:
    """
    Sets the color of the flashing cursor in this edit box.

    :param int editbox_id: The ID of the edit box to modify.
    :param int red: The red component of the color (0 to 255).
    :param int green: The green component of the color (0 to 255).
    :param int blue: The blue component of the color (0 to 255).
    :rtype: None
    """
    pass    


def set_edit_box_cursor_position(editbox_id: int, position: int) -> None:
    """
    Sets the cursor to the specified position in the text, i.e.

    position 0 is left of the first character, position 1 is left of the second character, and so on. If the position
    value is out of range it will be clamped to the nearest character. The current cursor position is guaranteed to be
    in view of the user, so this can be used to left or right justify text by setting the cursor to the far left or
    right of the text.

    :param int editbox_id: The ID of the edit box to modify.
    :param int position: The new position of the cursor.
    :rtype: None
    """
    pass    


def set_edit_box_cursor_width(editbox_id: int, width: Union[float, int]) -> None:
    """
    Sets the width in world coordinates of the text input cursor, by default this is set to 1.5 Note that functions that
    change the text size or edit box size may overwrite this value.

    :param int editbox_id: The ID of the edit box to modify.
    :param Union[float, int] width: The new width of the cursor.
    :rtype: None
    """
    pass    


def set_edit_box_depth(editbox_id: int, depth: int) -> None:
    """
    Sets the depth of the edit box so it may appear behind or in front of other sprites and text objects.

    :param int editbox_id: The ID of the edit box to modify.
    :param int depth: The depth in the range 0 (front) to 10000 (back).
    :rtype: None
    """
    pass    


def set_edit_box_extended_font_image(editbox_id: int, image_id: int) -> None:
    """
    Sets the extended font image to use for this edit box, must have been previously loaded with `load_image()`.

    Use 0 to remove the extended font image. If you do not set this image the edit box will not accept extended
    characters such as £ é á etc.

    :param int editbox_id: The ID of the edit box to modify.
    :param int image_id: The ID of the image to use, 0 to use no image.
    :rtype: None
    """
    pass    


def set_edit_box_focus(editbox_id: int, focus: Union[bool, int]) -> None:
    """
    Toggles the focus status of this edit box, when focus is set to 1 the cursor starts flashing and any key presses
    will add text to the edit box.

    When set to 0 the cursor disappears and text will not be added.

    :param int editbox_id: The ID of the edit box to modify.
    :param Union[bool, int] focus: The new focus state of the edit box, True to set focus, False to remove focus.
    :rtype: None
    """
    pass    


def set_edit_box_font(editbox_id: int, font_id: int) -> None:
    """
    Sets the font to use for this edit box, must have been previously loaded with `load_font()`.

    Use 0 to return the edit box to its default font.

    :param int editbox_id: The ID of the edit box to modify.
    :param int font_id: The ID of the font to use, 0 for default font.
    :rtype: None
    """
    pass    


def set_edit_box_font_image(editbox_id: int, image_id: int) -> None:
    """
    Sets the font image to use for this edit box, must have been previously loaded with `load_image()`.

    Use 0 to return the edit box to its default font.

    :param int editbox_id: The ID of the edit box to modify.
    :param int image_id: The ID of the image to use, 0 for default font.
    :rtype: None
    """
    pass    


def set_edit_box_input_type(index: int, mode: int) -> None:
    """
    Sets the type of keyboard that will appear on mobile devices when editing this edit box.

    Where possible a keyboard of that type will be displayed, for example a keyboard with numbers only.

    :param int index: The ID of the edit box to modify.
    :param int mode: 0 for normal text, 1 for numbers only.
    :rtype: None
    """
    pass    


def set_edit_box_max_chars(editbox_id: int, maximum: int) -> None:
    """
    Sets the maximum number of characters that can be entered in this edit box.

    Use 0 for unlimited.

    :param int editbox_id: The ID of the edit box to modify.
    :param int maximum: The maximum number of characters.
    :rtype: None
    """
    pass    


def set_edit_box_max_lines(editbox_id: int, maximum: int) -> None:
    """
    Sets the maximum number of lines that can be entered into this multiline edit box.

    Use 0 for unlimited.

    :param int editbox_id: The ID of the edit box to modify.
    :param int maximum: The maximum number of lines.
    :rtype: None
    """
    pass    


def set_edit_box_multiline(editbox_id: int, enabled: Union[bool, int]) -> None:
    """
    Sets whether the edit box will wrap text to a new line when it reaches the edge of the edit box.

    The default is for multiline to be 0 so text is one continuous line in the box.

    :param int editbox_id: The ID of the edit box to modify.
    :param Union[bool, int] enabled: True to enable multiline, False to disable.
    :rtype: None
    """
    pass    


def set_edit_box_password_mode(editbox_id: int, enabled: Union[bool, int]) -> None:
    """
    Sets whether the edit box display stars instead of the text input.

    Using `get_edit_box_text()` will still return the actual characters entered by the user.

    :param int editbox_id: The ID of the edit box to modify.
    :param Union[bool, int] enabled: True to display stars, False to display the normal input.
    :rtype: None
    """
    pass    


def set_edit_box_position(editbox_id: int, x: Union[float, int], y: Union[float, int]) -> None:
    """
    Sets the position in world coordinates of the edit box using it's top left corner.

    This sets the position of the actual text entry box, its border will extend to the left and above this point.

    :param int editbox_id: The ID of the edit box to modify.
    :param Union[float, int] x: The X value of the position.
    :param Union[float, int] y: The Y value of the position.
    :rtype: None
    """
    pass    


def set_edit_box_scissor(editbox_id: int, x1: Union[float, int], y1: Union[float, int],
                         x2: Union[float, int], y2: Union[float, int]) -> None:
    """
    Clips the edit box to the specified world coordinates when drawn.

    :param int editbox_id: The ID of the edit box to modify.
    :param Union[float, int] x1: The x coordinate of the top left corner of the box to use as a clip boundary.
    :param Union[float, int] y1: The y coordinate of the top left corner of the box to use as a clip boundary.
    :param Union[float, int] x2: The x coordinate of the bottom right corner of the box to use as a clip boundary.
    :param Union[float, int] y2: The y coordinate of the bottom right corner of the box to use as a clip boundary.
    :rtype: None
    """
    pass    


def set_edit_box_size(editbox_id: int, width: Union[float, int], height: Union[float, int]) -> None:
    """
    Sets the size of the edit box in world coordinates.

    This sets the size of the actual text entry box, its border will extend beyond these values.

    :param int editbox_id: The ID of the edit box to modify.
    :param Union[float, int] width: The width of the new size.
    :param Union[float, int] height: The height of the new size.
    :rtype: None
    """
    pass    


def set_edit_box_text(editbox_id: int, text: str) -> None:
    """
    Sets the text which is currently being displayed in the edit box.

    :param int editbox_id: The ID of the edit box to modify.
    :param str text: The new text to display.
    :rtype: None
    """
    pass    


def set_edit_box_text_color(editbox_id: int, red: int, green: int, blue: int) -> None:
    """
    Sets the color of the text being input.

    :param int editbox_id: The ID of the edit box to modify.
    :param int red: The red component of the color (0 to 255).
    :param int green: The green component of the color (0 to 255).
    :param int blue: The blue component of the color (0 to 255).
    :rtype: None
    """
    pass    


def set_edit_box_text_size(editbox_id: int, size: Union[float, int]) -> None:
    """
    Sets the height in world coordinates of the text in this edit box.

    By default it is set to the edit box's height minus 2. `set_edit_box_text_size()` will not allow the text height to
    be set greater than the height of the edit box.

    :param int editbox_id: The ID of the edit box to modify.
    :param Union[float, int] size: The new size of font to use.
    :rtype: None
    """
    pass    


def set_edit_box_use_alternate_input(editbox_id: int, enabled: Union[bool, int]) -> None:
    """
    Sets whether the edit box will use an alternate text input method if the edit box would be hidden by a virtual
    keyboard.

    This only applies to mobile platforms like iOS and Android and the alternate input method is usually a smaller edit
    box placed just above the keyboard. The edit box will still update in real time as if it is being typed into
    directly, but since it is covered by the keyboard the user will not see it. By default this is turned on. If you
    wish you can turn it off and move the edit box into view when `get_edit_box_has_focus()` returns 1, be sure to move
    it back again when `get_edit_box_has_focus()` returns 0.

    :param int editbox_id: The ID of the edit box to modify.
    :param Union[bool, int] enabled: True to use alternate input (default), False to use the normal input.
    :rtype: None
    """
    pass    


def set_edit_box_visible(editbox_id: int, visible: Union[bool, int]) -> None:
    """
    Toggles the visible status of this edit box, when visible is set to 1 the edit box can be clicked on, gain focus and
    be changed, when set to 0 the edit box is not shown, cannot be changed, nor gain focus.

    :param int editbox_id: The ID of the edit box to modify.
    :param Union[bool, int] visible: The new state of the edit box, True for visible, False for invisible.
    :rtype: None
    """
    pass    


def set_edit_box_wrap_mode(editbox_id: int, mode: int) -> None:
    """
    When `set_edit_box_multiline()` is set to False this command sets whether the single line of text will scroll to the
    right or wrap to a new line when it over flows the edit box width.

    The user will still not be allowed to enter new line characters themselves.

    :param int editbox_id: The ID of the edit box to modify.
    :param int mode: 0 (EDIT_BOX_WRAP_SCROLL) to scroll to the right (default), 1 (EDIT_BOX_WRAP_NEW_LINE) to wrap to a
        new line.
    :rtype: None
    """
    pass    


def set_joystick_dead_zone(threshold: Union[float, int]) -> None:
    """
    Sets the dead zone for the universal joysticks so that any X or Y value below the given threshold will return 0
    instead.

    This value must be between 0 and 1, by default it is set to 0.15.

    :param Union[float, int] threshold: The value below which 0 will be returned.
    :rtype: None
    """
    pass    


def set_joystick_screen_position(x: Union[float, int], y: Union[float, int], size: Union[float,
                                 int]) -> None:
    """
    The AGK joystick is an emulated input method that uses whatever device inputs are available to produce a joystick
    style input in the range -1 to 1.

    This command positions a virtual joystick on screen only if it is necessary to emulate this input. For example if a
    real joystick or keyboard are available then this command has no noticeable effect. It is recommended that you
    always call this command anyway if you intend to use `get_joystick_x()` or `get_joystick_y()` just in case a virtual
    joystick is needed. Any virtual joystick will be centered on the given X and Y position.

    :param Union[float, int] x: The X coordinate of the new position in screen coordinates.
    :param Union[float, int] y: The Y coordinate of the new position in screen coordinates.
    :param Union[float, int] size: The diameter of the joystick in screen coordinates.
    :rtype: None
    """
    pass    


def set_text_input_max_chars(maximum: int) -> None:
    """
    Sets the maximum number of characters that can be entered in the fullscreen edit box.

    Use 0 for unlimited.

    :param int maximum: The maximum number of characters.
    :rtype: None
    """
    pass    


def set_virtual_button_active(button_id: int, active: Union[bool, int]) -> None:
    """
    Sets whether the virtual will capture mouse and touch events.

    If set to 0 it will not capture input and will not update its pressed state, it will return to 0 (up). This will not
    affect the virtual button's visibility, use `set_virtual_button_visible()` to change if it is visible.

    :param int button_id: The ID of the virtual button to set.
    :param Union[bool, int] active: True to accept input, False to deactivate it.
    :rtype: None
    """
    pass    


def set_virtual_button_alpha(button_id: int, alpha: int) -> None:
    """
    Sets the transparency of the virtual button at the given `button_id`. The alpha value should be in the range 0-255
    where 255 is fully opaque.

    :param int button_id: The ID of the virtual button to set.
    :param int alpha: The new alpha value for this button.
    :rtype: None
    """
    pass    


def set_virtual_button_color(button_id: int, red: int, green: int, blue: int) -> None:
    """
    Sets the color of the virtual button at the given `button_id`. By default buttons are greyscale so that they can
    accept various colors. Colors should be specified in the range 0-255.

    :param int button_id: The ID of the virtual button to set.
    :param int red: The red component of the new color.
    :param int green: The green component of the new color.
    :param int blue: The blue component of the new color.
    :rtype: None
    """
    pass    


def set_virtual_button_image_down(button_id: int, image_id: int) -> None:
    """
    Sets the image used by the button when it is pressed.

    You can use an image ID of 0 to return it to the default image.

    :param int button_id: The ID of the virtual button to set.
    :param int image_id: The image ID to use for this button.
    :rtype: None
    """
    pass    


def set_virtual_button_image_up(button_id: int, image_id: int) -> None:
    """
    Sets the image used by the button when it is not being pressed.

    You can use an image ID of 0 to return it to the default image.

    :param int button_id: The ID of the virtual button to set.
    :param int image_id: The image ID to use for this button.
    :rtype: None
    """
    pass    


def set_virtual_button_position(button_id: int, x: Union[float, int], y: Union[float, int]) -> None:
    """
    Sets the position of the virtual button in screen coordinates.

    You can use `get_virtual_width()` and `get_virtual_height()` to find the current bounds of the screen. The button
    will be centered on the given x and y position.

    :param int button_id: The ID of the virtual button to set.
    :param Union[float, int] x: The x coordinate of the new position in screen coordinates.
    :param Union[float, int] y: The y coordinate of the new position in screen coordinates.
    :rtype: None
    """
    pass    


def set_virtual_button_size(button_id: int, width: Union[float, int], height: Optional[Union[float,
                            int]] = None) -> None:
    """
    Sets the size of the virtual button in screen coordinates.

    :param int button_id: The ID of the virtual button to set.
    :param Union[float, int] width: The new X size of the button in screen coordinates.
    :param Optional[Union[float, int]] height: The new Y size of the button in screen coordinates. If not given, it will
        match the width.
    :rtype: None
    """
    pass    


def set_virtual_button_text(button_id: int, text: str) -> None:
    """
    Sets the text displayed in the center of the button.

    :param int button_id: The ID of the virtual button to set.
    :param str text: The text to display.
    :rtype: None
    """
    pass    


def set_virtual_button_visible(button_id: int, visible: Union[bool, int]) -> None:
    """
    Sets whether the virtual is visible on screen, this does not affect its ability to accept input, use
    `set_virtual_button_active()` to affect if a virtual button will accept input.

    An invisible button can still be active.

    :param int button_id: The ID of the virtual button to set.
    :param Union[bool, int] visible: True to show the button, False to hide it.
    :rtype: None
    """
    pass    


def set_virtual_joystick_active(joystick_id: int, active: Union[bool, int]) -> None:
    """
    Sets whether the joystick will capture mouse and touch events.

    If set to 0 it will not capture input and will not update its X and Y values, they will return to 0. This will not
    affect the virtual joystick's visibility, use `set_virtual_joystick_visible()` to change if it is visible.

    :param int joystick_id: The ID of the virtual joystick to set.
    :param Union[bool, int] active: True to allow input, False to deactivate it.
    :rtype: None
    """
    pass    


def set_virtual_joystick_alpha(joystick_id: int, outer: int, inner: int) -> None:
    """
    Sets the transparency of the virtual joystick on screen.

    The virtual joystick is composed of two parts the inner movable part, and the outer static part. The `outer`
    parameter sets the transparency of the outer part in the range 0-255 with 255 being fully opaque. The `inner`
    parameter sets the transparency of the inner part in the range 0-255.

    :param int joystick_id: The ID of the virtual joystick to set.
    :param int outer: The alpha value of the outer part of the joystick.
    :param int inner: The alpha value of the inner part of the joystick.
    :rtype: None
    """
    pass    


def set_virtual_joystick_dead_zone(threshold: Union[float, int]) -> None:
    """
    Sets the dead zone for all virtual joysticks so that any X or Y value below the given threshold will return 0
    instead.

    This value must be between 0 and 1, by default it is set to 0.15.

    :param Union[float, int] threshold: The value below which 0 will be returned.
    :rtype: None
    """
    pass    


def set_virtual_joystick_image_inner(joystick_id: int, image_id: int) -> None:
    """
    Sets the image used by the inner (movable) portion of the joystick.

    You can use an image ID of 0 to return it to the default image.

    :param int joystick_id: The ID of the virtual joystick to set.
    :param int image_id: The image ID to use for this joystick.
    :rtype: None
    """
    pass    


def set_virtual_joystick_image_outer(joystick_id: int, image_id: int) -> None:
    """
    Sets the image used by the outer (fixed) portion of the joystick.

    You can use an image ID of 0 to return it to the default image.

    :param int joystick_id: The ID of the virtual joystick to set.
    :param int image_id: The image ID to use for this joystick.
    :rtype: None
    """
    pass    


def set_virtual_joystick_position(joystick_id: int, x: Union[float, int], y: Union[float,
                                  int]) -> None:
    """
    Sets the position of the virtual joystick in screen coordinates.

    You can use `get_virtual_width()` and `get_virtual_height()` to find the current bounds of the screen. The joystick
    will be centered on the given x and y position. Moving a virtual joystick whilst it is in use will alter the current
    X and Y values being returned.

    :param int joystick_id: The ID of the virtual joystick to set.
    :param Union[float, int] x: The x coordinate of the new position.
    :param Union[float, int] y: The y coordinate of the new position.
    :rtype: None
    """
    pass    


def set_virtual_joystick_size(joystick_id: int, size: Union[float, int]) -> None:
    """
    Sets the diameter of the virtual joystick in screen coordinates.

    Resizing a virtual joystick whilst it is in use will alter the current X and Y values being returned.

    :param int joystick_id: The ID of the virtual joystick to set.
    :param Union[float, int] size: The new diameter of the joystick in screen coordinates.
    :rtype: None
    """
    pass    


def set_virtual_joystick_visible(joystick_id: int, visible: Union[bool, int]) -> None:
    """
    Sets whether the joystick is visible on screen, this does not affect its ability to accept input, use
    `set_virtual_joystick_active()` to affect if a virtual joystick will accept input.

    An invisible joystick can still be active.

    :param int joystick_id: The ID of the virtual joystick to set.
    :param Union[bool, int] visible: True to display the joystick, False to hide it.
    :rtype: None
    """
    pass    


def start_text_input(text: Optional[str] = None) -> None:
    """
    This command pops up a text entry prompt over your app whilst your app continues in the background.

    Accepted characters are ASCII values in the range 32 to 126 inclusive, unless you have activated the new default
    fonts with `use_new_default_fonts()`, in which case any Unicode characters can be used. If a virtual keyboard is
    required for text entry on this device then it will be displayed over your app. You cannot assume that any part of
    your app will be visible whilst text entry is in progress, although your code will continue running. When the user
    has finished entering text `get_text_input_completed()` will return 1 and `get_text_input_cancelled()` will let you
    know if they completed the text entry or cancelled it. On keyboard based devices cancelling is done with the escape
    key whilst completing is done with the enter key. If successful you can get the inputted text with
    `get_text_input()`.

    :param Optional[str] text: The initial string to display to the user that they can edit.
    :rtype: None
    """
    pass    


def stop_text_input() -> None:
    """
    This command stops and hides any text entry prompt previously started with `start_text_input()` command.

    :rtype: None
    """
    pass    


def complete_raw_joystick_detection() -> None:
    """
    Waits for the detection of physical joysticks to complete, on some systems this may take a few seconds so is run in
    a separate thread along side the main application.

    If you do not use any of the real joystick commands (include the AGK joystick) you may ignore this command and let
    the joystick detection complete whenever it likes. However if you do wish to use joystick commands in your app you
    must call this command to make sure that the total number of joysticks connected have been found. After this initial
    detection process plugging in additional joysticks will not be detected.

    :rtype: None
    """
    pass    


def get_accelerometer_exists() -> bool:
    """
    Returns True if the current device has an accelerometer that is currently supported by AGK, False if not.

    :rtype: bool
    """
    pass    


def get_camera_exists() -> bool:
    """
    Returns True if the current device has a camera, False if not.

    On some platforms this command enumerates the hardware devices to check for a camera which may be slow. It is not
    recommended that you call this every frame. On Windows this command will successfully detect a new camera being
    plugged in whilst the app is running.

    :rtype: bool
    """
    pass    


def get_char_buffer() -> str:
    """
    Returns a string of all the characters pressed since the last time this command was called, after this command is
    called the buffer is cleared.

    This only works on devices with a physical keyboard. The buffer is limited to 1024 characters, after which
    additional characters will be ignored.

    :rtype: str
    """
    pass    


def get_char_buffer_length() -> int:
    """
    Returns the current length of the char buffer wihtout modifying it.

    Note that this is the length in characters, not bytes, which may be different when the string contains unicode
    characters.

    :rtype: int
    """
    pass    


def get_gps_sensor_exists() -> bool:
    """
    Returns True if the current device has a GPS receiver that is currently supported by AGK, False if not.

    :rtype: bool
    """
    pass    


def get_gyro_sensor_exists() -> bool:
    """
    Returns True if the current device has a gyroscope that is currently supported by AGK, False if not.

    :rtype: bool
    """
    pass    


def get_joystick_exists() -> bool:
    """
    Returns True if the current device has at least one physical joystick available as an input method, False if it has
    no joystick physical joysticks.

    If you find that the platform has no physical joysticks you can create virtual ones that appear on screen for use by
    touch screens or mice with `add_virtual_joystick()`. `get_joystick_exists()` does not count virtual joysticks in its
    check. On some platforms joystick detection is run on a background thread that may not complete for some time after
    your app has started, to wait for the thread to complete use `complete_raw_joystick_detection()` to be sure that any
    connected joysticks have been found.

    :rtype: bool
    """
    pass    


def get_keyboard_exists() -> int:
    """
    Returns:
     * 1 (KEYBOARD_FULL_SIZE) if the current device has a full sized keyboard,
     * 2 (KEYBOARD_VIRTUAL) if the device has a virtual or mobile phone keyboard and
     * 0 (KEYBOARD_NONE) for no keyboard at all.

    :rtype: int
    """
    pass    


def get_light_sensor_exists() -> bool:
    """
    Returns True if the current device has an ambient light sensor that is currently supported by AGK, False if not.

    :rtype: bool
    """
    pass    


def get_magnetic_sensor_exists() -> bool:
    """
    Returns True if the current device has a magnetism sensor that is currently supported by AGK, False if not.

    :rtype: bool
    """
    pass    


def get_mouse_exists() -> bool:
    """
    Returns True if the current device has a mouse, False if not.

    :rtype: bool
    """
    pass    


def get_multi_touch_exists() -> bool:
    """
    Returns True if the current device supports multitouch, False if not.

    :rtype: bool
    """
    pass    


def get_proximity_sensor_exists() -> bool:
    """
    Returns True if the current device has a proximity sensor that is currently supported by AGK, False if not.

    :rtype: bool
    """
    pass    


def get_raw_accel_x() -> float:
    """
    If an accelerometer exists, returns the current accelerometer reading for the X direction in the range -1 to 1.

    This matches the screen coordinate system of positive being to the right. If no accelerometer exists this will
    always return 0. You can use the `get_direction_x()` command to emulate a direction input. If you have not used
    `set_orientation_allowed()` to select your desired orientation then this command will lock the device in the current
    orientation to prevent the accelerometer rotating the screen. You should use `set_orientation_allowed()` if you want
    to enable screen rotation when using the accelerometer.

    :rtype: float
    """
    pass    


def get_raw_accel_y() -> float:
    """
    If an accelerometer exists, returns the current accelerometer reading for the Y direction in the range -1 to 1.

    This matches the screen coordinate system of positive being down. If no accelerometer exists this will always return
    0. You can use the `get_direction_y()` command to emulate a direction input. If you have not used
    `set_orientation_allowed()` to select your desired orientation then this command will lock the device in the current
    orientation to prevent the accelerometer rotating the screen. You should use `set_orientation_allowed()` if you want
    to enable screen rotation when using the accelerometer.

    :rtype: float
    """
    pass    


def get_raw_accel_z() -> float:
    """
    If an accelerometer exists, returns the current accelerometer reading for the Z direction in the range -1 to 1.

    A positive Z value means the screen is facing upwards. If no accelerometer exists this will always return 0, there
    is no emulated command for the Z direction. If you have not used `set_orientation_allowed()` to select your desired
    orientation then this command will lock the device in the current orientation to prevent the accelerometer rotating
    the screen. You should use `set_orientation_allowed()` if you want to enable screen rotation when using the
    accelerometer.

    :rtype: float
    """
    pass    


def get_raw_first_touch_event(include_unknown: int) -> int:
    """
    Returns an index to the first touch event available for reading.

    By default the AGK does not count an event until it knows what type of event it is, e.g. short, long, drag, etc. To
    receive unknown events as well set `include_unknown` to True. Use False to ignore unknown events. All you can be
    sure about with unknown events is that the finger is currently on screen and has been there less than 1 second.
    After 1 second it automatically becomes a hold event. If the user lifts their finger off the screen it becomes a
    short event, and if they move their finger it becomes a drag event. If no events are available it returns 0.

    :param int include_unknown: Set to true to receive unknown events which may become any type of event in the future.
    :rtype: int
    """
    pass    


def get_raw_gps_altitude() -> float:
    """
    Returns the most up to date altitude available in meters above sea level.

    :rtype: float
    """
    pass    


def get_raw_gps_latitude() -> float:
    """
    Returns the most up to date latitude available.

    :rtype: float
    """
    pass    


def get_raw_gps_longitude() -> float:
    """
    Returns the most up to date longitude available.

    :rtype: float
    """
    pass    


def get_raw_gyro_velocity_x() -> float:
    """
    If a gyroscope exists, returns the X component of the current device rotation speed.

    If you have not used `set_orientation_allowed()` to select your desired orientation then this command will lock the
    device in the current orientation to prevent the screen from rotating. You should use `set_orientation_allowed()` if
    you want to enable screen rotation when using the gyroscope.

    :rtype: float
    """
    pass    


def get_raw_gyro_velocity_y() -> float:
    """
    If a gyroscope exists, returns the Y component of the current device rotation speed.

    If you have not used `set_orientation_allowed()` to select your desired orientation then this command will lock the
    device in the current orientation to prevent the screen from rotating. You should use `set_orientation_allowed()` if
    you want to enable screen rotation when using the gyroscope.

    :rtype: float
    """
    pass    


def get_raw_gyro_velocity_z() -> float:
    """
    If a gyroscope exists, returns the Z component of the current device rotation speed.

    If you have not used `set_orientation_allowed()` to select your desired orientation then this command will lock the
    device in the current orientation to prevent the screen from rotating. You should use `set_orientation_allowed()` if
    you want to enable screen rotation when using the gyroscope.

    :rtype: float
    """
    pass    


def get_raw_joystick_button_pressed(joystick_id: int, button: int) -> bool:
    """
    Returns True if the given button was pressed this frame, otherwise returns False.

    Once the button has been pressed this function returns to False, to check the state of the button use
    `get_raw_joystick_button_state()`.

    AGK supports up to 64 joystick buttons in the range 1-64.

    :param int joystick_id: The ID of the joystick to check.
    :param int button: The ID of the button to check.
    :rtype: bool
    """
    pass    


def get_raw_joystick_button_released(joystick_id: int, button: int) -> bool:
    """
    Returns True if the given button was released this frame, otherwise returns False.

    Once the button has been released this function returns to False, to check the state of the button use
    `get_raw_joystick_button_state()`.

    AGK supports up to 64 joystick buttons in the range 1-64.

    :param int joystick_id: The ID of the joystick to check.
    :param int button: The ID of the button to check.
    :rtype: bool
    """
    pass    


def get_raw_joystick_button_state(joystick_id: int, button: int) -> int:
    """
    Returns 1 (STATE_DOWN) if the given button is currently down, otherwise returns 0 (STATE_UP).

    To detect the instance that a button is pressed or released use `get_raw_joystick_button_pressed()` or
    `get_raw_joystick_button_released()`.

    AGK supports up to 64 joystick buttons in the range 1-64.

    :param int joystick_id: The ID of the joystick to check.
    :param int button: The ID of the button to check.
    :rtype: int
    """
    pass    


def get_raw_joystick_connected(joystick_id: int) -> bool:
    """
    Returns True if the specified joystick is connected, False if not.

    This only applies to joysticks that were plugged in when the app started, plugging in a new joystick after the app
    has started will not be detected. Use `get_raw_joystick_exists()` to find out which joysticks were detected at
    startup. This command currently does not work on Mac.

    :param int joystick_id: The ID of the joystick to check.
    :rtype: bool
    """
    pass    


def get_raw_joystick_exists(joystick_id: int) -> bool:
    """
    Returns True if a joystick exists at the given `joystick_id`. Physical joysticks are detected at startup and placed
    in IDs 1-8 incrementally. You should call `complete_raw_joystick_detection()` at some point before this command to
    make sure that all present joysticks have been discovered. After the initial detection process plugging in
    additional joysticks will not be detected (except on Android which will detect new joysticks). Unplugging a joystick
    will not delete its `joystick_id` and this command will still return True. You can use
    `get_raw_joystick_connected()` to detect when a previously detected joystick is disconnected. If a disconnected
    joystick is reattached the AGK will attempt to reconnect to it.

    An alternative version of this command exists `get_joystick_exists()`, in which case it will return True if there
    are any raw joysticks attached.

    :param int joystick_id: The ID of the joystick to check.
    :rtype: bool
    """
    pass    


def get_raw_joystick_name(joystick_id: int) -> str:
    """
    Returns the name of the joystick as discovered by the operating system, currently only works on Windows and Linux.

    :param int joystick_id: The ID of the joystick to check.
    :rtype: str
    """
    pass    


def get_raw_joystick_pov(joystick_id: int, pov: int) -> int:
    """
    Returns the current value of the joystick POV, this can vary based on joystick type.

    Currently the POV index must be either 0, 1, 2, or 3

    :param int joystick_id: The ID of the joystick to check.
    :param int pov: The index of the POV to check.
    :rtype: int
    """
    pass    


def get_raw_joystick_rx(joystick_id: int) -> float:
    """
    Returns the current rotational X value (if applicable) for the physical joystick at the given `joystick_id`. This
    will be in the range -1.0 to 1.0 with 0 being centered. In reality some joystick devices use this value for a second
    analogue stick.

    :param int joystick_id: The ID of the joystick to check.
    :rtype: float
    """
    pass    


def get_raw_joystick_ry(joystick_id: int) -> float:
    """
    Returns the current rotational Y value (if applicable) for the physical joystick at the given `joystick_id`. This
    will be in the range -1.0 to 1.0 with 0 being centered. In reality some joystick devices use this value for a second
    analogue stick.

    :param int joystick_id: The ID of the joystick to check.
    :rtype: float
    """
    pass    


def get_raw_joystick_rz(joystick_id: int) -> float:
    """
    Returns the current rotational Z value (if applicable) for the physical joystick at the given `joystick_id`. This
    will be in the range -1.0 to 1.0 with 0 being centered. In reality some joystick devices use this value for a second
    analogue stick.

    :param int joystick_id: The ID of the joystick to check.
    :rtype: float
    """
    pass    


def get_raw_joystick_slider(joystick_id: int, slider: int) -> int:
    """
    Returns the current value of the joystick slider, this can vary based on joystick type.

    Currently the slider index must be either 0 or 1. Sliders are typically used for additional axes.

    :param int joystick_id: The ID of the joystick to check.
    :param int slider: The index of the slider to check.
    :rtype: int
    """
    pass    


def get_raw_joystick_x(joystick_id: int) -> float:
    """
    Returns the current X value for the physical joystick at the given `joystick_id`. This will be in the range -1.0 to
    1.0 with 0 being centered.

    :param int joystick_id: The ID of the joystick to check.
    :rtype: float
    """
    pass    


def get_raw_joystick_y(joystick_id: int) -> float:
    """
    Returns the current Y value for the physical joystick at the given `joystick_id`. This will be in the range -1.0 to
    1.0 with 0 being centered.

    :param int joystick_id: The ID of the joystick to check.
    :rtype: float
    """
    pass    


def get_raw_joystick_z(joystick_id: int) -> float:
    """
    Returns the current Z value (if applicable) for the physical joystick at the given `joystick_id`. This will be in
    the range -1.0 to 1.0 with 0 being centered.

    :param int joystick_id: The ID of the joystick to check.
    :rtype: float
    """
    pass    


def get_raw_key_pressed(key: int) -> bool:
    """
    Returns True if the key code given was pressed this frame, then returns False whilst the key is held down.

    This only applies to platforms with a full sized keyboard such as PC and Mac, otherwise all keys will return False.
    You can check if a keyboard exists by checking `get_keyboard_exists()` returns True. Key codes are in the range 0 to
    255, anything out of range will return False. Check out the scan codes page in the guides section of the help files
    to see which key matches which key code.

    :param int key: The key code of the key to check.
    :rtype: bool
    """
    pass    


def get_raw_key_released(key: int) -> bool:
    """
    Returns True if the key code given was released this frame, then returns False whilst the key is up.

    This only applies to platforms with a full sized keyboard such as PC and Mac, otherwise all keys will return False.
    You can check if a keyboard exists by checking `get_keyboard_exists()` returns True. Key codes are in the range 0 to
    255, anything out of range will return False. Check out the scan codes page in the guides section of the help files
    to see which key matches which key code.

    :param int key: The key code of the key to check.
    :rtype: bool
    """
    pass    


def get_raw_key_state(key: int) -> int:
    """
    Returns 1 (STATE_DOWN) if the key code given is currently down, 0 (STATE_UP) if it is up. This only applies to
    platforms with a full sized keyboard such as PC and Mac, otherwise all keys will return 0 (STATE_UP). You can check
    if a keyboard exists by checking `get_keyboard_exists()` returns True. Key codes are in the range 0 to 255, anything
    out of range will return 0 (STATE_UP). Check out the scan codes page in the guides section of the help files to see
    which key matches which key code.

    :param int key: The key code of the key to check.
    :rtype: int
    """
    pass    


def get_raw_last_key() -> int:
    """
    Returns the key code of the last key pressed.

    This only applies to platforms with a full sized keyboard such as PC, Mac, and Linux. You can check if a keyboard
    exists by using `get_keyboard_exists()`. This function continue to return the last key pressed even when the key has
    been released. Check out the scan codes page in the guides section of the help files to see which key matches which
    key code.

    :rtype: int
    """
    pass    


def get_raw_light_level() -> float:
    """
    If an ambient light sensor exists, get the measurement of the surrounding light in lumels as a float.

    :rtype: float
    """
    pass    


def get_raw_magnetic_x() -> float:
    """
    If an magnetic sensor exists, returns the X component of any surrounding magnetic field.

    On iOS it may take a few seconds to start displaying data other than 0, during this process the device is using
    motion data to calibrate the magnetic sensor.

    :rtype: float
    """
    pass    


def get_raw_magnetic_y() -> float:
    """
    If an magnetic sensor exists, returns the Y component of any surrounding magnetic field.

    On iOS it may take a few seconds to start displaying data other than 0, during this process the device is using
    motion data to calibrate the magnetic sensor.

    :rtype: float
    """
    pass    


def get_raw_magnetic_z() -> float:
    """
    If an magnetic sensor exists, returns the Z component of any surrounding magnetic field.

    On iOS it may take a few seconds to start displaying data other than 0, during this process the device is using
    motion data to calibrate the magnetic sensor.

    :rtype: float
    """
    pass    


def get_raw_mouse_fifth_pressed() -> bool:
    """
    Returns True if the fifth mouse button has been pressed, then returns False whilst the button is held down. If no
    mouse exists it will always return False.

    :rtype: bool
    """
    pass    


def get_raw_mouse_fifth_released() -> bool:
    """
    Returns True if the fifth mouse button has been released, then returns False whilst the button is up. If no mouse
    exists it will always return False.

    :rtype: bool
    """
    pass    


def get_raw_mouse_fifth_state() -> int:
    """
    Returns 1 (STATE_DOWN) if the fifth mouse button is currently down, 0 (STATE_UP) if not. If no mouse exists it will
    always return 0 (STATE_UP).

    :rtype: int
    """
    pass    


def get_raw_mouse_fourth_pressed() -> bool:
    """
    Returns True if the fourth mouse button has been pressed, then returns False whilst the button is held down. If no
    mouse exists it will always return False.

    :rtype: bool
    """
    pass    


def get_raw_mouse_fourth_released() -> bool:
    """
    Returns True if the fourth mouse button has been released, then returns False whilst the button is up. If no mouse
    exists it will always return False.

    :rtype: bool
    """
    pass    


def get_raw_mouse_fourth_state() -> int:
    """
    Returns 1 (STATE_DOWN) if the fourth mouse button is currently down, 0 (STATE_UP) if not. If no mouse exists it will
    always return 0 (STATE_UP).

    :rtype: int
    """
    pass    


def get_raw_mouse_left_pressed() -> bool:
    """
    Returns True if the left mouse button has been pressed, then returns False whilst the button is held down.

    If no mouse exists it will always return False.

    :rtype: bool
    """
    pass    


def get_raw_mouse_left_released() -> bool:
    """
    Returns True if the left mouse button has been released, then returns False whilst the button is up.

    If no mouse exists it will always return False.

    :rtype: bool
    """
    pass    


def get_raw_mouse_left_state() -> int:
    """
    Returns 1 (STATE_DOWN) if the left mouse button is currently down, 0 (STATE_UP) if not.

    If no mouse exists it will always return 0 (STATE_UP).

    :rtype: int
    """
    pass    


def get_raw_mouse_middle_pressed() -> bool:
    """
    Returns True if the middle mouse button has been pressed, then returns False whilst the button is held down.

    If no mouse exists it will always return False.

    :rtype: bool
    """
    pass    


def get_raw_mouse_middle_released() -> bool:
    """
    Returns True if the middle mouse button has been released, then returns False whilst the button is up.

    If no mouse exists it will always return False.

    :rtype: bool
    """
    pass    


def get_raw_mouse_middle_state() -> int:
    """
    Returns 1 (STATE_DOWN) if the middle mouse button is currently down, 0 (STATE_UP) if not.

    If no mouse exists it will always return 0 (STATE_UP).

    :rtype: int
    """
    pass    


def get_raw_mouse_right_pressed() -> bool:
    """
    Returns True if the right mouse button has been pressed, then returns False whilst the button is held down.

    If no mouse exists it will always return False.

    :rtype: bool
    """
    pass    


def get_raw_mouse_right_released() -> bool:
    """
    Returns True if the right mouse button has been released, then returns False whilst the button is up.

    If no mouse exists it will always return False.

    :rtype: bool
    """
    pass    


def get_raw_mouse_right_state() -> int:
    """
    Returns 1 (STATE_DOWN) if the right mouse button is currently down, 0 (STATE_UP) if not. If no mouse exists it will
    always return 0 (STATE_UP).

    :rtype: int
    """
    pass    


def get_raw_mouse_wheel() -> float:
    """
    Returns the current position of the mouse wheel, can be positive or negative, starts at 0.

    If no mouse exists it will always return 0.

    :rtype: float
    """
    pass    


def get_raw_mouse_wheel_delta() -> float:
    """
    Returns the difference between the current mouse wheel position and the previous mouse wheel position, can be
    positive or negative, updated once a frame.

    If no mouse exists it will always return 0.

    :rtype: float
    """
    pass    


def get_raw_mouse_x() -> float:
    """
    Returns the X component of the current mouse position in screen coordinates.

    If no mouse exists it will always return 0.

    :rtype: float
    """
    pass    


def get_raw_mouse_y() -> float:
    """
    Returns the Y component of the current mouse position in screen coordinates.

    If no mouse exists it will always return 0.

    :rtype: float
    """
    pass    


def get_raw_next_touch_event() -> int:
    """
    Returns an index to the next touch event available for reading, if no more events are available it returns 0.

    :rtype: int
    """
    pass    


def get_raw_proximity_distance() -> float:
    """
    If a proximity sensor exists, returns the distance of the device from any object currently in front of it, untested
    as no device supported it during testing.

    :rtype: float
    """
    pass    


def get_raw_rotation_vector_w() -> float:
    """
    Returns the W component of the current device orientation as a quaternion.

    This can be applied to objects with the `set_object_rotation_quat()` to mimic the device orientation with an object.
    This command is designed for use with objects, if you want to orientate the camera use
    `get_raw_rotation_vector_w2()`.

    :rtype: float
    """
    pass    


def get_raw_rotation_vector_w2() -> float:
    """
    Returns the W component of the current device orientation as a quaternion.

    This can be applied to cameras with `set_camera_rotation_quat()` to use the device like a virtual reality headset.
    This command does internal calculations based on the `set_orientation_allowed()` values to produce the correct
    camera orientation for the current device orientation. This command is designed for use with cameras, if you want to
    orientate an object use `get_raw_rotation_vector_w()`.

    :rtype: float
    """
    pass    


def get_raw_rotation_vector_x() -> float:
    """
    Returns the X component of the current device orientation as a quaternion.

    This can be applied to objects with the `set_object_rotation_quat()` to mimic the device orientation with an object.
    This command is designed for use with objects, if you want to orientate the camera use
    `get_raw_rotation_vector_x2()`.

    :rtype: float
    """
    pass    


def get_raw_rotation_vector_x2() -> float:
    """
    Returns the X component of the current device orientation as a quaternion.

    This can be applied to cameras with `set_camera_rotation_quat()` to use the device like a virtual reality headset.
    This command does internal calculations based on the `set_orientation_allowed()` values to produce the correct
    camera orientation for the current device orientation. This command is designed for use with cameras, if you want to
    orientate an object use `get_raw_rotation_vector_x()`.

    :rtype: float
    """
    pass    


def get_raw_rotation_vector_y() -> float:
    """
    Returns the Y component of the current device orientation as a quaternion.

    This can be applied to objects with the `set_object_rotation_quat()` to mimic the device orientation with an object.
    This command is designed for use with objects, if you want to orientate the camera use
    `get_raw_rotation_vector_y2()`.

    :rtype: float
    """
    pass    


def get_raw_rotation_vector_y2() -> float:
    """
    Returns the Y component of the current device orientation as a quaternion.

    This can be applied to cameras with `set_camera_rotation_quat()` to use the device like a virtual reality headset.
    This command does internal calculations based on the `set_orientation_allowed()` values to produce the correct
    camera orientation for the current device orientation. This command is designed for use with cameras, if you want to
    orientate an object use `get_raw_rotation_vector_y()`.

    :rtype: float
    """
    pass    


def get_raw_rotation_vector_z() -> float:
    """
    Returns the Z component of the current device orientation as a quaternion.

    This can be applied to objects with the `set_object_rotation_quat()` to mimic the device orientation with an object.
    This command is designed for use with objects, if you want to orientate the camera use
    `get_raw_rotation_vector_z2()`.

    :rtype: float
    """
    pass    


def get_raw_rotation_vector_z2() -> float:
    """
    Returns the Z component of the current device orientation as a quaternion.

    This can be applied to cameras with `set_camera_rotation_quat()` to use the device like a virtual reality headset.
    This command does internal calculations based on the `set_orientation_allowed()` values to produce the correct
    camera orientation for the current device orientation. This command is designed for use with cameras, if you want to
    orientate an object use `get_raw_rotation_vector_z()`.

    :rtype: float
    """
    pass    


def get_raw_touch_count(include_unknown: Union[bool, int]) -> int:
    """
    Returns the number of touch events currently taking place.

    By default the AGK does not count an event until it knows what type of event it is, e.g. short, long, drag, etc. To
    count unknown events as well, set `include_unknown` to True. Use False to ignore unknown events.

    :param Union[bool, int] include_unknown: Set to True to count unknown events which may become any type of touch
        event in the future.
    :rtype: int
    """
    pass    


def get_raw_touch_current_x(index: int) -> float:
    """
    Returns the X position in screen coordinates where the touch event is currently located.

    This coordinate will be in view coordinates, if you are offsetting the view port you may want to convert it to world
    coordinates using `screen_to_world_x()`.

    :param int index: The index of the event to check, received from `get_raw_next_touch_event()` or
        `get_raw_first_touch_event()`.
    :rtype: float
    """
    pass    


def get_raw_touch_current_y(index: int) -> float:
    """
    Returns the Y position in screen coordinates where the touch event is currently located.

    This coordinate will be in view coordinates, if you are offsetting the view port you may want to convert it to world
    coordinates using `screen_to_world_y()`.

    :param int index: The index of the event to check, received from `get_raw_next_touch_event()` or
        `get_raw_first_touch_event()`.
    :rtype: float
    """
    pass    


def get_raw_touch_last_x(index: int) -> float:
    """
    Returns the X position in screen coordinates where the touch event was last recorded before its current location.

    This coordinate will be in view coordinates, if you are offsetting the view port you may want to convert it to world
    coordinates using `screen_to_world_x()`.

    :param int index: The index of the event to check, received from `get_raw_next_touch_event()` or
        `get_raw_first_touch_event()`.
    :rtype: float
    """
    pass    


def get_raw_touch_last_y(index: int) -> float:
    """
    Returns the Y position in screen coordinates where the touch event was last recorded before its current location.

    This coordinate will be in view coordinates, if you are offsetting the view port you may want to convert it to world
    coordinates using `screen_to_world_y()`.

    :param int index: The index of the event to check, received from `get_raw_next_touch_event()` or
        `get_raw_first_touch_event()`.
    :rtype: float
    """
    pass    


def get_raw_touch_released(index: int) -> bool:
    """
    Returns True if the touch has been released, this will always be True for short events, hold and drag events will
    keep reporting False until they are released at which point you may wish to take some action.

    Each event will only report released as True once before being removed from the event list. If a touch event is
    ignored (not queried) for one frame after it is released it will be deleted from the event list.

    :param int index: The index of the event to check, received from `get_raw_next_touch_event()` or
        `get_raw_first_touch_event()`.
    :rtype: bool
    """
    pass    


def get_raw_touch_start_x(index: int) -> float:
    """
    Returns the X position in screen coordinates where the touch event started.

    This coordinate will be in view coordinates, if you are offsetting the view port you may want to convert it to world
    coordinates using `screen_to_world_x()`.

    :param int index: The index of the event to check, received from `get_raw_next_touch_event()` or
        `get_raw_first_touch_event()`.
    :rtype: float
    """
    pass    


def get_raw_touch_start_y(index: int) -> float:
    """
    Returns the Y position in screen coordinates where the touch event started.

    This coordinate will be in view coordinates, if you are offsetting the view port you may want to convert it to world
    coordinates using `screen_to_world_y()`.

    :param int index: The index of the event to check, received from `get_raw_next_touch_event()` or
        `get_raw_first_touch_event()`.
    :rtype: float
    """
    pass    


def get_raw_touch_time(index: int) -> float:
    """
    Returns the total time that this event took, from press to release in seconds.

    :param int index: The index of the event to check, received from `get_raw_next_touch_event()` or
        `get_raw_first_touch_event()`.
    :rtype: float
    """
    pass    


def get_raw_touch_type(index: int) -> int:
    """
    Returns the type of the given touch event.

    All you can be sure about with unknown events is that the finger is currently on screen and has been there less than
    1 second. After 1 second it automatically becomes a hold event. If the user lifts their finger off the screen before
    this then it becomes a short event, and if they move their finger further than the distance specified by
    `set_raw_touch_move_sensitivity()` then it becomes a drag event. If the current event is not known then it returns
    0.

    Events may change from being hold events to being drag events, but short and drag events do not change type. Unknown
    events are guaranteed to change type once more information is available.

    Possible return values are:
     * 0 (TOUCH_UNKNOWN) to indicate unknown,
     * 1 (TOUCH_SHORT) for a short touch,
     * 2 (TOUCH_HOLD) for a hold and
     * 3 (TOUCH_DRAG) for dragging.

    :param int index: The index of the event to check, received from `get_raw_next_touch_event()` or
        `get_raw_first_touch_event()`.
    :rtype: int
    """
    pass    


def get_raw_touch_value(index: int) -> int:
    """
    Retrieves a value previously stored in this event by `set_raw_touch_value()`.

    :param int index: The index of the event to check, received from `get_raw_next_touch_event()` or
        `get_raw_first_touch_event()`.
    :rtype: int
    """
    pass    


def get_rotation_vector_sensor_exists() -> bool:
    """
    Returns True if the current device has a rotation vector sensor that is currently supported by AGK, False if not.

    :rtype: bool
    """
    pass    


def set_raw_joystick_dead_zone(threshold: Union[float, int]) -> None:
    """
    Sets the dead zone for all real joysticks so that any X or Y value below the given threshold will return 0 instead.

    This value must be between 0 and 1, by default it is set to 0.15.

    :param Union[float, int] threshold: The value below which 0 will be returned.
    :rtype: None
    """
    pass    


def set_raw_mouse_position(x: Union[float, int], y: Union[float, int]) -> None:
    """
    Attempts to position any mouse pointer used on this platform.

    Not guaranteed to work on all platforms. Will only work whilst your app window has focus.

    :param Union[float, int] x: The X component of the new mouse position.
    :param Union[float, int] y: The Y component of the new mouse position.
    :rtype: None
    """
    pass    


def set_raw_mouse_visible(visible: Union[bool, int]) -> None:
    """
    Attempts to hide or show any mouse pointer used on this platform.

    Not guaranteed to work on all platforms.

    :param Union[bool, int] visible: True to make it visible, False to hide it.
    :rtype: None
    """
    pass    


def set_raw_touch_move_sensitivity(distance: int) -> None:
    """
    Sets the distance a touch event has to move before it gets classed as a drag event.

    By default this is set at 6.

    :param int distance: The distance the touch event has to move in virtual coordinates
    :rtype: None
    """
    pass    


def set_raw_touch_value(index: int, value: int) -> None:
    """
    Allows you to set some custom data to be stored in this event that you can retrieve later.

    Could be a value or pointer.

    :param int index: The index of the event to check, received from `get_raw_next_touch_event()` or
        `get_raw_first_touch_event()`.
    :param int value: The value to store with this event.
    :rtype: None
    """
    pass    


def start_gps_tracking() -> None:
    """
    Starts the process of getting a GPS location if possible on the current device.

    This may produce a permission request on some platforms the first time you call it. If the user denies permission
    then `get_gps_sensor_exists()` may return False from then on. You should only call this command when the user is
    doing an activity they know will require a location, otherwise they may deny it and never get asked again (they will
    have to go into their device settings to enable it). This command will consume a lot of battery power, so use
    `stop_gps_tracking()` when you no longer need a location. This command works on iOS, Android, Mac, and Windows 7 and
    above. It may take some time from calling this command to get an accurate location from `get_raw_gps_latitude()` and
    `get_raw_gps_longitude()`.

    :rtype: None
    """
    pass    


def stop_gps_tracking() -> None:
    """
    Stops GPS location updates, use this to save battery power when you no longer need a location.

    :rtype: None
    """
    pass    


def create_vector3(x: Optional[Union[float, int]] = 0.0, y: Optional[Union[float, int]] = 0.0,
                   z: Optional[Union[float, int]] = 0.0) -> int:
    """
    Creates a vector and fills it with the values passed in.

    Returns a vector ID.

    :param Optional[Union[float, int]] x: The x component of the vector (default: 0).
    :param Optional[Union[float, int]] y: The y component of the vector (default: 0).
    :param Optional[Union[float, int]] z: The z component of the vector (default: 0).
    :rtype: int
    """
    pass    


def delete_vector3(vector_id: int) -> None:
    """
    Deletes the Vector.

    :param int vector_id: ID of vector.
    :rtype: None
    """
    pass    


def get_vector3_add(result_vector_id: int, add_vector_id: int) -> None:
    """
    Fills the `result_vector_id` vector with the sum of the `result_vector_id` vector and the `add_vector_id` vector.

    :param int result_vector_id: ID of the vector to add and hold results.
    :param int add_vector_id: ID of vector to add.
    :rtype: None
    """
    pass    


def get_vector3_cross(result_vector_id: int, vector_id1: int, vector_id2: int) -> None:
    """
    Fills the result vector with the cross product of 2 vectors passed in.

    :param int result_vector_id: ID of vector for results.
    :param int vector_id1: ID of the first vector.
    :param int vector_id2: ID of the second vector.
    :rtype: None
    """
    pass    


def get_vector3_distance(vector_id1: int, vector_id2: int) -> float:
    """
    Returns the distance between the 2 vectors.

    :param int vector_id1: ID of the first vector.
    :param int vector_id2: ID of the second vector.
    :rtype: float
    """
    pass    


def get_vector3_dot(vector_id1: int, vector_id2: int) -> float:
    """
    Returns the dot product of 2 vectors.

    :param int vector_id1: ID of the first vector.
    :param int vector_id2: ID of the second vector.
    :rtype: float
    """
    pass    


def get_vector3_length(vector_id: int) -> float:
    """
    Returns the length of the vector.

    :param int vector_id: ID of the vector.
    :rtype: float
    """
    pass    


def get_vector3_multiply(vector_id: int, multiplier: Union[float, int]) -> None:
    """
    Multiplies the components of the given vector by the given multiplier.

    :param int vector_id: ID of the vector to multiply.
    :param Union[float, int] multiplier: Float value to multiply by.
    :rtype: None
    """
    pass    


def get_vector3_x(vector_id: int) -> float:
    """
    Gets the x from the vector.

    :param int vector_id: ID of the vector.
    :rtype: float
    """
    pass    


def get_vector3_y(vector_id: int) -> float:
    """
    Gets the y from the vector.

    :param int vector_id: ID of the vector.
    :rtype: float
    """
    pass    


def get_vector3_z(vector_id: int) -> float:
    """
    Gets the z from the vector.

    :param int vector_id: ID of the vector.
    :rtype: float
    """
    pass    


def set_vector3(vector_id: int, x: Union[float, int], y: Union[float, int], z: Union[float,
                int]) -> None:
    """
    Fills the specified vector.

    :param int vector_id: ID of vector.
    :param Union[float, int] x: The x component of the vector.
    :param Union[float, int] y: The y component of the vector.
    :param Union[float, int] z: The z component of the vector.
    :rtype: None
    """
    pass    


def add_object_mesh_from_memblock(object_id: int, memblock_id: int) -> None:
    """
    Adds a new mesh to the object, constructed from the given memblock.

    The first 4 bytes of the memblock represent the number of vertices in the mesh.

    The second 4 bytes represent the number of indices in the mesh, this may be 0 in which case every three vertices
    represents a polygon, and no vertices can be shared. If the number of indices is greater than 0 then every three
    indices represent a polygon and vertices may be shared between polygons. Indices start at 0 so index 0 references
    the first vertex in the list.

    The third 4 bytes represents the number of attributes per vertex, e.g. position, normals, and UV data are all
    potential attributes, so a vertex containing all three would have 3 attributes. A vertex must have a position
    attribute, everything else is optional.

    The fourth 4 bytes represent the size of a single vertex in bytes, this can be calculated from the attribute data
    but is given for convenience.

    The fifth 4 bytes is offset for the beginning of the vertex data, so you can reach it easily.

    The sixth 4 bytes is offset for the beginning of the index data, will be 0 if there are no indices.

    After those 6 values, starting at offset 24, is the vertex attribute data. The vertex attribute data describes how
    the vertex data is laid out, for example if it has normals, UV data, etc.

    For each attribute there is a 1 byte data type, 1 byte component count, 1 byte normalize flag, 1 byte string length,
    and X bytes of string data for the attribute name. The data type will be 0 for floats (used for almost everything,
    e.g. position, normals, etc) or 1 for unsigned bytes (used for vertex colors).

    The component count is the number of values per attribute, e.g. position has 3 components, x,y,z, UV data has 2
    components, and vertex colors have 4 components. Note that any unsigned byte data type must have 4 components even
    if some are unused.

    The normalize flag is only used for unsigned byte data types and will convert values in the range 0-255 into 0.0-1.0
    for use in a shader. Usually the normalize flag will be 1 for color attributes and 0 for everything else.

    The string length byte must always be a multiple of 4 for alignment reasons, the string itself might have slightly
    less characters but always round up to the nearest multiple of 4 for the string length value. e.g. a string of
    length 5 should have a string length value of 8. Note that a string of 4 characters has a null terminator on the end
    which makes it length 5, so even though it has a multiple of 4 characters already it must use a length value of 8
    due to the null terminator.

    The attribute name string will be used by the shader to recognise what the vertex data is, the attribute names
    recognised by AGK are "position", "normal", "tangent", "binormal", "color", "uv", "uv1", "boneweights", and
    "boneindices", however you may add attributes with any name you like as long as you write a matching shader that has
    the same names. If you are not using your own shader and instead rely on AGK to draw the object then you must stick
    to the above attribute names.

    Following the attribute data is the raw vertex data, which usually starts with the "position" attribute. It will be
    a 4 byte float for the X position, a 4 byte float for the Y position, and a 4 byte float for the Z position. This
    continues for each attribute specified in the attribute data. Note that color data will always be 4 bytes in total,
    1 unsigned byte for each color channel. You can access individual vertices by using the vertex size provided above
    and the vertex index like so offset=vertexDataOffset+(vertexIndex*vertexSize).

    Lastly is the index data, if present. Each index is a 4 byte integer which references a vertex in the vertex data.
    Every three indices represents a polygon.

    :param int object_id: The ID of the object to modify.
    :param int memblock_id: The index of the memblock to use to create the new mesh.
    :rtype: None
    """
    pass    


def copy_memblock(src_memblock_id: int, dst_memblock_id: int, src_offset: int, dst_offset: int,
                  size: int) -> None:
    """
    Copies a portion of one memblock to another.

    Both memblocks must exist and can be of different sizes.

    :param int src_memblock_id: The ID of the memblock to copy from.
    :param int dst_memblock_id: The ID of the memblock to copy to.
    :param int src_offset: The offset in the source memblock to start copying from.
    :param int dst_offset: The offset of the destination memblock to copy to.
    :param int size: The number of bytes to copy.
    :rtype: None
    """
    pass    


def create_file_from_memblock(filename: str, memblock_id: int) -> None:
    """
    Creates a file from a memblock without any processing of the memblock data, the file will be a byte for byte copy of
    the memblock data.

    You can use relative paths in the file name to write to sub folders or use `set_folder()` to browse there first. You
    can use absolute paths by adding a forward slash to the beginning of the filename, in this case the folder set with
    `set_folder()` is ignored. For example /media/file.txt will place it in the media folder even if `set_folder()` was
    used to browse to /media/somefolder.

    :param str filename: The name of the file to create, if it already exists it will be overwritten.
    :param int memblock_id: The ID of the memblock to read, the memblock is unaffected by this command.
    :rtype: None
    """
    pass    


def create_image_from_memblock(memblock_id: int) -> int:
    """
    Creates an image from a memblock.

    The memblock must exist, if the image exists it will be overwritten, if not it will be created.

    The first 4 bytes of the memlbock store the image width, the next 4 bytes store the image height, the next 4 bytes
    store the bit depth, currently this must be 32.

    After that the raw image data begins in the format RGBA, with each component stored in a single byte, so each pixel
    takes up 4 bytes. The size of the image data can be calculated by width*height*4 bytes (for now bit depth can be
    assumed to be 32 bits = 4 bytes).

    Note that due to little endian format writing the image data with bytes will result in offsets 0=R, 1=G, 2=B, 3=A,
    but writing them all as a single integer will be interpreted as a value with A as the most significant byte,
    followed by B, then G, then R as the least significant byte.

    The pixel data starts in the top left corner of the image an proceeds left to right then top to bottom resulting in
    the image being stored as a sequence of rows ending in the bottom right corner.

    This command uses a lot of GPU bandwidth so it is not recommended that this command be called every frame on large
    images.

    :param int memblock_id: The ID of the memblock to read, the memblock is unaffected by this command.
    :rtype: int
    """
    pass    


def create_image_id_from_memblock(image_id: int, memblock_id: int) -> None:
    """
    Creates an image from a memblock.

    The memblock must exist, if the image exists it will be overwritten, if not it will be created.

    The first 4 bytes of the memlbock store the image width, the next 4 bytes store the image height, the next 4 bytes
    store the bit depth, currently this must be 32.

    After that the raw image data begins in the format RGBA, with each component stored in a single byte, so each pixel
    takes up 4 bytes. The size of the image data can be calculated by width*height*4 bytes (for now bit depth can be
    assumed to be 32 bits = 4 bytes).

    Note that due to little endian format writing the image data with bytes will result in offsets 0=R, 1=G, 2=B, 3=A,
    but writing them all as a single integer will be interpreted as a value with A as the most significant byte,
    followed by B, then G, then R as the least significant byte.

    The pixel data starts in the top left corner of the image an proceeds left to right then top to bottom resulting in
    the image being stored as a sequence of rows ending in the bottom right corner.

    This command uses a lot of GPU bandwidth so it is not recommended that this command be called every frame on large
    images.

    :param int image_id: The ID of the image to create or modify.
    :param int memblock_id: The ID of the memblock to read, the memblock is unaffected by this command.
    :rtype: None
    """
    pass    


def create_image_from_png_memblock(memblock_id: int) -> int:
    """
    Creates an image from a memblock. The memblock must exist, if the image exists it will be overwritten, if not it
    will be created. The memblock must contain a valid PNG file such as one loaded with
    `create_memblock_id_from_file(`memblock_id`, "image.png")`.

    :param int memblock_id: The ID of the memblock to read, the memblock is unaffected by this command.
    :rtype: int
    """
    pass    


def create_image_id_from_png_memblock(image_id: int, memblock_id: int) -> None:
    """
    Creates an image from a memblock. The memblock must exist, if the image exists it will be overwritten, if not it
    will be created. The memblock must contain a valid PNG file such as one loaded with
    `create_memblock_id_from_file(`memblock_id`, "image.png")`.

    :param int image_id: The ID of the image to create.
    :param int memblock_id: The ID of the memblock to read, the memblock is unaffected by this command.
    :rtype: None
    """
    pass    


def create_memblock(size: int) -> int:
    """
    Creates a section of memory of the given size for read or write access.

    A memblock must not already exist with your chosen `memblock_id`.

    :param int size: The size of the memblock in bytes. max 100,000,000.
    :rtype: int
    """
    pass    


def create_memblock_id(memblock_id: int, size: int) -> None:
    """
    Creates a section of memory of the given size for read or write access.

    A memblock must not already exist with your chosen `memblock_id`.

    :param int memblock_id: The ID of the memblock you want to use.
    :param int size: The size of the memblock in bytes. max 100,000,000.
    :rtype: None
    """
    pass    


def create_memblock_from_file(filename: str) -> int:
    """
    Creates a memblock from a file without any processing of the file data, the memblock will be a byte for byte copy of
    the file.

    Returns an ID that can be used to reference this memblock later. You can use relative paths in the file name to read
    from sub folders or use `set_folder()` to browse there first. You can use absolute paths by adding a forward slash
    to the beginning of the filename, in this case the folder set with `set_folder()` is ignored. For example
    /media/file.txt will read it from the media folder even if `set_folder()` was used to browse to /media/somefolder.

    :param str filename: The name of the file to read, if it doesn't exist this will fail.
    :rtype: int
    """
    pass    


def create_memblock_id_from_file(memblock_id: int, filename: str) -> None:
    """
    Creates a memblock from a file without any processing of the file data, the memblock will be a byte for byte copy of
    the file.

    Returns an ID that can be used to reference this memblock later. You can use relative paths in the file name to read
    from sub folders or use `set_folder()` to browse there first. You can use absolute paths by adding a forward slash
    to the beginning of the filename, in this case the folder set with `set_folder()` is ignored. For example
    /media/file.txt will read it from the media folder even if `set_folder()` was used to browse to /media/somefolder.

    :param int memblock_id: The ID of the memblock to create.
    :param str filename: The name of the file to read, if it doesn't exist this will fail.
    :rtype: None
    """
    pass    


def create_memblock_from_image(image_id: int) -> int:
    """
    Creates a memblock from a loaded image, atlas sub images are not supported.

    The image must exist and is unaffected by this command.

    The first 4 bytes of the memlbock store the image width, the next 4 bytes store the image height, the next 4 bytes
    store the bit depth, currently this will always be 32.

    After that the raw image data begins in the format RGBA, with each component stored in a single byte, so each pixel
    takes up 4 bytes. The size of the image data can be calculated by width*height*4 bytes (for now bit depth can be
    assumed to be 32 bits = 4 bytes). Note that due to little endian format reading the image data with bytes will
    return offsets 0=R, 1=G, 2=B, 3=A, but reading them all as a single integer will produce a value with A as the most
    significant byte, followed by B, then G, then R as the least significant byte.

    The pixel data starts in the top left corner of the image an proceeds left to right then top to bottom resulting in
    the image being stored as a sequence of rows ending in the bottom right corner.

    Returns an ID that can be used to reference this memblock in other commands.

    :param int image_id: The ID of the image to read.
    :rtype: int
    """
    pass    


def create_memblock_id_from_image(memblock_id: int, image_id: int) -> None:
    """
    Creates a memblock from a loaded image, atlas sub images are not supported.

    The image must exist and is unaffected by this command.

    The first 4 bytes of the memlbock store the image width, the next 4 bytes store the image height, the next 4 bytes
    store the bit depth, currently this will always be 32.

    After that the raw image data begins in the format RGBA, with each component stored in a single byte, so each pixel
    takes up 4 bytes. The size of the image data can be calculated by width*height*4 bytes (for now bit depth can be
    assumed to be 32 bits = 4 bytes). Note that due to little endian format reading the image data with bytes will
    return offsets 0=R, 1=G, 2=B, 3=A, but reading them all as a single integer will produce a value with A as the most
    significant byte, followed by B, then G, then R as the least significant byte.

    The pixel data starts in the top left corner of the image an proceeds left to right then top to bottom resulting in
    the image being stored as a sequence of rows ending in the bottom right corner.

    Returns an ID that can be used to reference this memblock in other commands.

    :param int memblock_id: The ID of the memblock to create.
    :param int image_id: The ID of the image to read.
    :rtype: None
    """
    pass    


def create_memblock_from_object_mesh(object_id: int, mesh: int) -> int:
    """
    Creates a memblock from an object mesh.

    An object can contain one or more meshes, mesh indices are in the range 1 to `get_object_num_meshes()` inclusive.
    The mesh is copied into the memblock so any changes to the memblock do not immediately affect the mesh, you must use
    one of the other commands such as `set_object_mesh_from_memblock()` to copy the memblock back into a mesh.

    The first 4 bytes of the memblock represent the number of vertices in the mesh.

    The second 4 bytes represent the number of indices in the mesh, this may be 0 in which case every three vertices
    represents a polygon, and no vertices can be shared. If the number of indices is greater than 0 then every three
    indices represent a polygon and vertices may be shared between polygons. Indices start at 0 so index 0 references
    the first vertex in the list.

    The third 4 bytes represents the number of attributes per vertex, e.g. position, normals, and UV data are all
    potential attributes, so a vertex containing all three would have 3 attributes. A vertex must have a position
    attribute, everything else is optional.

    The fourth 4 bytes represent the size of a single vertex in bytes, this can be calculated from the attribute data
    but is given for convenience.

    The fifth 4 bytes is offset for the beginning of the vertex data, so you can reach it easily.

    The sixth 4 bytes is offset for the beginning of the index data, will be 0 if there are no indices.

    After those 6 values, starting at offset 24, is the vertex attribute data. The vertex attribute data describes how
    the vertex data is laid out, for example if it has normals, UV data, etc.

    For each attribute there is a 1 byte data type, 1 byte component count, 1 byte normalize flag, 1 byte string length,
    and X bytes of string data for the attribute name. The data type will be 0 for floats (used for almost everything,
    e.g. position, normals, etc) or 1 for unsigned bytes (used for vertex colors).

    The component count is the number of values per attribute, e.g. position has 3 components, x,y,z, UV data has 2
    components, and vertex colors have 4 components. Note that any unsigned byte data type must have 4 components even
    if some are unused.

    The normalize flag is only used for unsigned byte data types and will convert values in the range 0-255 into 0.0-1.0
    for use in a shader. Usually the normalize flag will be 1 for color attributes and 0 for everything else.

    The string length byte will always be a multiple of 4 to simplify alignment issues, the string itself might have
    slightly less characters and be padded with null terminators, but read all the bytes specified and you will get the
    correct length string.

    The attribute name string will be used by the shader to recognise what the vertex data is, the attribute names
    recognised by AGK are "position", "normal", "tangent", "binormal", "color", "uv", "uv1", "boneweights", and
    "boneindices", however you may add attributes with any name you like as long as you write a matching shader that has
    the same names. If you are not using your own shader and instead rely on AGK to draw the object then you must stick
    to the above attribute names.

    Following the attribute data is the raw vertex data, which usually starts with the "position" attribute. It will be
    a 4 byte float for the X position, a 4 byte float for the Y position, and a 4 byte float for the Z position. This
    continues for each attribute specified in the attribute data. Note that color data will always be 4 bytes in total,
    1 unsigned byte for each color channel. You can access individual vertices by using the vertex size provided above
    and the vertex index like so offset=vertexDataOffset+(vertexIndex*vertexSize).

    Lastly is the index data, if present. Each index is a 4 byte integer which references a vertex in the vertex data.
    Every three indices represents a polygon.

    If you plan on making regular changes to the mesh you should keep the memblock around after using
    `set_object_mesh_from_memblock()` instead of regenerating from the object it every time you want to make a change.
    Then call `set_object_mesh_from_memblock()` again when you want to push your new changes onto the object.

    :param int object_id: The ID of the object containing the mesh to read.
    :param int mesh: The index of the mesh to copy into a memblock.
    :rtype: int
    """
    pass    


def create_memblock_id_from_object_mesh(memblock_id: int, object_id: int, mesh: int) -> None:
    """
    Creates a memblock from an object mesh.

    An object can contain one or more meshes, mesh indices are in the range 1 to `get_object_num_meshes()` inclusive.
    The mesh is copied into the memblock so any changes to the memblock do not immediately affect the mesh, you must use
    one of the other commands such as `set_object_mesh_from_memblock()` to copy the memblock back into a mesh.

    The first 4 bytes of the memblock represent the number of vertices in the mesh.

    The second 4 bytes represent the number of indices in the mesh, this may be 0 in which case every three vertices
    represents a polygon, and no vertices can be shared. If the number of indices is greater than 0 then every three
    indices represent a polygon and vertices may be shared between polygons. Indices start at 0 so index 0 references
    the first vertex in the list.

    The third 4 bytes represents the number of attributes per vertex, e.g. position, normals, and UV data are all
    potential attributes, so a vertex containing all three would have 3 attributes. A vertex must have a position
    attribute, everything else is optional.

    The fourth 4 bytes represent the size of a single vertex in bytes, this can be calculated from the attribute data
    but is given for convenience.

    The fifth 4 bytes is offset for the beginning of the vertex data, so you can reach it easily.

    The sixth 4 bytes is offset for the beginning of the index data, will be 0 if there are no indices.

    After those 6 values, starting at offset 24, is the vertex attribute data. The vertex attribute data describes how
    the vertex data is laid out, for example if it has normals, UV data, etc.

    For each attribute there is a 1 byte data type, 1 byte component count, 1 byte normalize flag, 1 byte string length,
    and X bytes of string data for the attribute name. The data type will be 0 for floats (used for almost everything,
    e.g. position, normals, etc) or 1 for unsigned bytes (used for vertex colors).

    The component count is the number of values per attribute, e.g. position has 3 components, x,y,z, UV data has 2
    components, and vertex colors have 4 components. Note that any unsigned byte data type must have 4 components even
    if some are unused.

    The normalize flag is only used for unsigned byte data types and will convert values in the range 0-255 into 0.0-1.0
    for use in a shader. Usually the normalize flag will be 1 for color attributes and 0 for everything else.

    The string length byte will always be a multiple of 4 to simplify alignment issues, the string itself might have
    slightly less characters and be padded with null terminators, but read all the bytes specified and you will get the
    correct length string.

    The attribute name string will be used by the shader to recognise what the vertex data is, the attribute names
    recognised by AGK are "position", "normal", "tangent", "binormal", "color", "uv", "uv1", "boneweights", and
    "boneindices", however you may add attributes with any name you like as long as you write a matching shader that has
    the same names. If you are not using your own shader and instead rely on AGK to draw the object then you must stick
    to the above attribute names.

    Following the attribute data is the raw vertex data, which usually starts with the "position" attribute. It will be
    a 4 byte float for the X position, a 4 byte float for the Y position, and a 4 byte float for the Z position. This
    continues for each attribute specified in the attribute data. Note that color data will always be 4 bytes in total,
    1 unsigned byte for each color channel. You can access individual vertices by using the vertex size provided above
    and the vertex index like so offset=vertexDataOffset+(vertexIndex*vertexSize).

    Lastly is the index data, if present. Each index is a 4 byte integer which references a vertex in the vertex data.
    Every three indices represents a polygon.

    If you plan on making regular changes to the mesh you should keep the memblock around after using
    `set_object_mesh_from_memblock()` instead of regenerating from the object it every time you want to make a change.
    Then call `set_object_mesh_from_memblock()` again when you want to push your new changes onto the object.

    :param int memblock_id: The ID of the new memblock.
    :param int object_id: The ID of the object containing the mesh to read.
    :param int mesh: The index of the mesh to copy into a memblock.
    :rtype: None
    """
    pass    


def create_memblock_from_sound(sound_id: int) -> int:
    """
    Creates a memblock from a loaded sound file.

    The sound file must have been loaded with `load_sound()` and is unaffected by this command.

    The first 2 bytes of the memlbock store the number of channels (1 or 2 supported), the next 2 bytes store the bits
    per sample (8 or 16 supported), the next 4 bytes store the samples per second, for example 44100. The next 4 bytes
    are the number of frames in the sound data, the size of the sound data in bytes can be calculated from this with the
    formula numFrames*(bitsPerSample/8)*channels. In a 2 channel sound a frame contains 2 samples, one for each channel.
    In a mono sound a frame contains 1 sample.

    The rest of the memblock is raw sound data, for example in an 8bit stereo sound with 3 frames the raw data would
    look like this:
    ::
        byte offset 0 = Frame 1, left channel data
        byte offset 1 = Frame 1, right channel data
        byte offset 2 = Frame 2, left channel data
        byte offset 3 = Frame 2, right channel data
        byte offset 4 = Frame 3, left channel data
        byte offset 5 = Frame 3, right channel data

    The duration of the sound can be calculated with the following formula, numFrames/samplesPerSecond. This command
    does not work with sound instance IDs, only sound file IDs.

    Returns an ID that can be used to reference this memblock in other commands.

    :param int sound_id: The ID of the sound to read.
    :rtype: int
    """
    pass    


def create_memblock_id_from_sound(memblock_id: int, sound_id: int) -> None:
    """
    Creates a memblock from a loaded sound file.

    The sound file must have been loaded with `load_sound()` and is unaffected by this command.

    The first 2 bytes of the memlbock store the number of channels (1 or 2 supported), the next 2 bytes store the bits
    per sample (8 or 16 supported), the next 4 bytes store the samples per second, for example 44100. The next 4 bytes
    are the number of frames in the sound data, the size of the sound data in bytes can be calculated from this with the
    formula numFrames*(bitsPerSample/8)*channels. In a 2 channel sound a frame contains 2 samples, one for each channel.
    In a mono sound a frame contains 1 sample.

    The rest of the memblock is raw sound data, for example in an 8bit stereo sound with 3 frames the raw data would
    look like this:
    ::
        byte offset 0 = Frame 1, left channel data
        byte offset 1 = Frame 1, right channel data
        byte offset 2 = Frame 2, left channel data
        byte offset 3 = Frame 2, right channel data
        byte offset 4 = Frame 3, left channel data
        byte offset 5 = Frame 3, right channel data

    The duration of the sound can be calculated with the following formula, numFrames/samplesPerSecond. This command
    does not work with sound instance IDs, only sound file IDs.

    Returns an ID that can be used to reference this memblock in other commands.

    :param int memblock_id: The ID of the memblock to create.
    :param int sound_id: The ID of the sound to read.
    :rtype: None
    """
    pass    


def create_music_from_ogg_memblock(memblock_id: int) -> int:
    """
    Creates a music entity from a memblock. The memblock must exist. This will create a new music ID and return it The
    memblock must contain a valid OGG file such as one loaded with `create_memblock_id_from_file(`memblock_id`,
    "music.ogg")`.

    :param int memblock_id: The ID of the memblock to read, the memblock is unaffected by this command.
    :rtype: int
    """
    pass    


def create_music_id_from_ogg_memblock(music_id: int, memblock_id: int) -> None:
    """
    Creates a music entity from a memblock. The memblock must exist. This will create a new music ID and return it The
    memblock must contain a valid OGG file such as one loaded with `create_memblock_id_from_file(`memblock_id`,
    "music.ogg")`.

    :param int music_id: The ID of the music to create.
    :param int memblock_id: The ID of the memblock to read, the memblock is unaffected by this command.
    :rtype: None
    """
    pass    


def create_object_from_mesh_memblock(memblock_id: int) -> int:
    """
    Creates an object with a single mesh constructed from the given memblock.

    Any subsequent changes to the memblock will not affect the mesh, you should call `set_object_mesh_from_memblock()`
    to modify an existing mesh.

    The first 4 bytes of the memblock represent the number of vertices in the mesh.

    The second 4 bytes represent the number of indices in the mesh, this may be 0 in which case every three vertices
    represents a polygon, and no vertices can be shared. If the number of indices is greater than 0 then every three
    indices represent a polygon and vertices may be shared between polygons. Indices start at 0 so index 0 references
    the first vertex in the list.

    The third 4 bytes represents the number of attributes per vertex, e.g. position, normals, and UV data are all
    potential attributes, so a vertex containing all three would have 3 attributes. A vertex must have a position
    attribute, everything else is optional.

    The fourth 4 bytes represent the size of a single vertex in bytes, this can be calculated from the attribute data
    but is given for convenience.

    The fifth 4 bytes is offset for the beginning of the vertex data, so you can reach it easily.

    The sixth 4 bytes is offset for the beginning of the index data, will be 0 if there are no indices.

    After those 6 values, starting at offset 24, is the vertex attribute data. The vertex attribute data describes how
    the vertex data is laid out, for example if it has normals, UV data, etc.

    For each attribute there is a 1 byte data type, 1 byte component count, 1 byte normalize flag, 1 byte string length,
    and X bytes of string data for the attribute name. The data type will be 0 for floats (used for almost everything,
    e.g. position, normals, etc) or 1 for unsigned bytes (used for vertex colors).

    The component count is the number of values per attribute, e.g. position has 3 components, x,y,z, UV data has 2
    components, and vertex colors have 4 components. Note that any unsigned byte data type must have 4 components even
    if some are unused.

    The normalize flag is only used for unsigned byte data types and will convert values in the range 0-255 into 0.0-1.0
    for use in a shader. Usually the normalize flag will be 1 for color attributes and 0 for everything else.

    The string length byte must always be a multiple of 4 for alignment reasons, the string itself might have slightly
    less characters but always round up to the nearest multiple of 4 for the string length value. e.g. a string of
    length 5 should have a string length value of 8. Note that a string of 4 characters has a null terminator on the end
    which makes it length 5, so even though it has a multiple of 4 characters already it must use a length value of 8
    due to the null terminator.

    The attribute name string will be used by the shader to recognise what the vertex data is, the attribute names
    recognised by AGK are "position", "normal", "tangent", "binormal", "color", "uv", "uv1", "boneweights", and
    "boneindices", however you may add attributes with any name you like as long as you write a matching shader that has
    the same names. If you are not using your own shader and instead rely on AGK to draw the object then you must stick
    to the above attribute names.

    Following the attribute data is the raw vertex data, which usually starts with the "position" attribute. It will be
    a 4 byte float for the X position, a 4 byte float for the Y position, and a 4 byte float for the Z position. This
    continues for each attribute specified in the attribute data. Note that color data will always be 4 bytes in total,
    1 unsigned byte for each color channel. You can access individual vertices by using the vertex size provided above
    and the vertex index like so offset=vertexDataOffset+(vertexIndex*vertexSize).

    Lastly is the index data, if present. Each index is a 4 byte integer which references a vertex in the vertex data.
    Every three indices represents a polygon.

    :param int memblock_id: The index of the memblock to use to create the object mesh.
    :rtype: int
    """
    pass    


def create_object_id_from_mesh_memblock(object_id: int, memblock_id: int) -> None:
    """
    Creates an object with a single mesh constructed from the given memblock.

    Any subsequent changes to the memblock will not affect the mesh, you should call `set_object_mesh_from_memblock()`
    to modify an existing mesh.

    The first 4 bytes of the memblock represent the number of vertices in the mesh.

    The second 4 bytes represent the number of indices in the mesh, this may be 0 in which case every three vertices
    represents a polygon, and no vertices can be shared. If the number of indices is greater than 0 then every three
    indices represent a polygon and vertices may be shared between polygons. Indices start at 0 so index 0 references
    the first vertex in the list.

    The third 4 bytes represents the number of attributes per vertex, e.g. position, normals, and UV data are all
    potential attributes, so a vertex containing all three would have 3 attributes. A vertex must have a position
    attribute, everything else is optional.

    The fourth 4 bytes represent the size of a single vertex in bytes, this can be calculated from the attribute data
    but is given for convenience.

    The fifth 4 bytes is offset for the beginning of the vertex data, so you can reach it easily.

    The sixth 4 bytes is offset for the beginning of the index data, will be 0 if there are no indices.

    After those 6 values, starting at offset 24, is the vertex attribute data. The vertex attribute data describes how
    the vertex data is laid out, for example if it has normals, UV data, etc.

    For each attribute there is a 1 byte data type, 1 byte component count, 1 byte normalize flag, 1 byte string length,
    and X bytes of string data for the attribute name. The data type will be 0 for floats (used for almost everything,
    e.g. position, normals, etc) or 1 for unsigned bytes (used for vertex colors).

    The component count is the number of values per attribute, e.g. position has 3 components, x,y,z, UV data has 2
    components, and vertex colors have 4 components. Note that any unsigned byte data type must have 4 components even
    if some are unused.

    The normalize flag is only used for unsigned byte data types and will convert values in the range 0-255 into 0.0-1.0
    for use in a shader. Usually the normalize flag will be 1 for color attributes and 0 for everything else.

    The string length byte must always be a multiple of 4 for alignment reasons, the string itself might have slightly
    less characters but always round up to the nearest multiple of 4 for the string length value. e.g. a string of
    length 5 should have a string length value of 8. Note that a string of 4 characters has a null terminator on the end
    which makes it length 5, so even though it has a multiple of 4 characters already it must use a length value of 8
    due to the null terminator.

    The attribute name string will be used by the shader to recognise what the vertex data is, the attribute names
    recognised by AGK are "position", "normal", "tangent", "binormal", "color", "uv", "uv1", "boneweights", and
    "boneindices", however you may add attributes with any name you like as long as you write a matching shader that has
    the same names. If you are not using your own shader and instead rely on AGK to draw the object then you must stick
    to the above attribute names.

    Following the attribute data is the raw vertex data, which usually starts with the "position" attribute. It will be
    a 4 byte float for the X position, a 4 byte float for the Y position, and a 4 byte float for the Z position. This
    continues for each attribute specified in the attribute data. Note that color data will always be 4 bytes in total,
    1 unsigned byte for each color channel. You can access individual vertices by using the vertex size provided above
    and the vertex index like so offset=vertexDataOffset+(vertexIndex*vertexSize).

    Lastly is the index data, if present. Each index is a 4 byte integer which references a vertex in the vertex data.
    Every three indices represents a polygon.

    :param int object_id: The ID of the object to create.
    :param int memblock_id: The index of the memblock to use to create the object mesh.
    :rtype: None
    """
    pass    


def create_sound_from_memblock(memblock_id: int) -> int:
    """
    Creates an sound from a memblock.

    The memblock must exist, this creates a new sound and returns the ID. This will not affect any sound instances
    already playing, only future ones.

    The first 2 bytes of the memlbock store the number of channels (1 or 2 supported), the next 2 bytes store the bits
    per sample (8 or 16 supported), the next 4 bytes store the samples per second, for example 44100. The next 4 bytes
    are the number of frames in the sound data, the size of the sound data in bytes can be calculated from this with the
    formula numFrames*(bitsPerSample/8)*channels. In a 2 channel sound a frame contains 2 samples, one for each channel.
    In a mono sound a frame contains 1 sample.

    The rest of the memblock is raw sound data, for example in an 8bit stereo sound with 3 frames the raw data would
    look like this:
    ::
        byte offset 0 = Frame 1, left channel data
        byte offset 1 = Frame 1, right channel data
        byte offset 2 = Frame 2, left channel data
        byte offset 3 = Frame 2, right channel data
        byte offset 4 = Frame 3, left channel data
        byte offset 5 = Frame 3, right channel data

    Returns the ID of the new sound.

    :param int memblock_id: The ID of the memblock to read, the memblock is unaffected by this command.
    :rtype: int
    """
    pass    


def create_sound_id_from_memblock(sound_id: int, memblock_id: int) -> None:
    """
    Creates an sound from a memblock.

    The memblock must exist, this creates a new sound and returns the ID. This will not affect any sound instances
    already playing, only future ones.

    The first 2 bytes of the memlbock store the number of channels (1 or 2 supported), the next 2 bytes store the bits
    per sample (8 or 16 supported), the next 4 bytes store the samples per second, for example 44100. The next 4 bytes
    are the number of frames in the sound data, the size of the sound data in bytes can be calculated from this with the
    formula numFrames*(bitsPerSample/8)*channels. In a 2 channel sound a frame contains 2 samples, one for each channel.
    In a mono sound a frame contains 1 sample.

    The rest of the memblock is raw sound data, for example in an 8bit stereo sound with 3 frames the raw data would
    look like this:
    ::
        byte offset 0 = Frame 1, left channel data
        byte offset 1 = Frame 1, right channel data
        byte offset 2 = Frame 2, left channel data
        byte offset 3 = Frame 2, right channel data
        byte offset 4 = Frame 3, left channel data
        byte offset 5 = Frame 3, right channel data

    Returns the ID of the new sound.

    :param int sound_id: The ID of the sound to create or modify.
    :param int memblock_id: The ID of the memblock to read, the memblock is unaffected by this command.
    :rtype: None
    """
    pass    


def create_sound_from_ogg_memblock(memblock_id: int) -> int:
    """
    Creates an sound from a memblock. The memblock must exist, this creates a new sound and returns the ID. This will
    not affect any sound instances already playing, only future ones. The memblock must contain a valid OGG file such as
    one loaded with `create_memblock_id_from_file(`memblock_id`, "sound.ogg")`.

    :param int memblock_id: The ID of the memblock to read, the memblock is unaffected by this command.
    :rtype: int
    """
    pass    


def create_sound_id_from_ogg_memblock(sound_id: int, memblock_id: int) -> None:
    """
    Creates an sound from a memblock. The memblock must exist, this creates a new sound and returns the ID. This will
    not affect any sound instances already playing, only future ones. The memblock must contain a valid OGG file such as
    one loaded with `create_memblock_id_from_file(`memblock_id`, "sound.ogg")`.

    :param int sound_id: The ID of the sound to create or modify.
    :param int memblock_id: The ID of the memblock to read, the memblock is unaffected by this command.
    :rtype: None
    """
    pass    


def delete_memblock(memblock_id: int) -> None:
    """
    Deletes the memblock at the given ID.

    If the memblock does not exist or has already been deleted then this command does nothing.

    :param int memblock_id: The ID of the memblock to delete.
    :rtype: None
    """
    pass    


def get_memblock_byte(memblock_id: int, offset: int) -> int:
    """
    Returns the byte value at the given offset.

    The offset must be less than the size of the memblock. The first value is at offset 0. The returned value will be an
    unsigned byte between 0 and 255.

    :param int memblock_id: The ID of the memblock to check.
    :param int offset: The offset from the start of the memblock of the value to return, between 0 and size.
    :rtype: int
    """
    pass    


def get_memblock_byte_signed(memblock_id: int, offset: int) -> int:
    """
    Returns the byte value at the given offset.

    The offset must be less than the size of the memblock. The first value is at offset 0. The returned value will be a
    signed byte between -128 and 127.

    :param int memblock_id: The ID of the memblock to check.
    :param int offset: The offset from the start of the memblock of the value to return, between 0 and size.
    :rtype: int
    """
    pass    


def get_memblock_exists(memblock_id: int) -> bool:
    """
    Returns True if a memblock with the given ID exists, False if not.

    :param int memblock_id: The ID of the memblock to check.
    :rtype: bool
    """
    pass    


def get_memblock_float(memblock_id: int, offset: int) -> float:
    """
    Returns the float (4 byte) value at the given offset.

    The offset must be less than the size of the memblock. The first value is at offset 0. For best performance the
    offset should be a multiple of 4 because reading float values that are not aligned to 4 byte boundaries incurs a
    hardware performance penalty. Float values are stored in IEEE 754 format so writing an float and then reading it
    back in bytes would return various components of the float format.

    :param int memblock_id: The ID of the memblock to check.
    :param int offset: The offset from the start of the memblock of the value to return, between 0 and size.
    :rtype: float
    """
    pass    


def get_memblock_int(memblock_id: int, offset: int) -> int:
    """
    Returns the int (4 byte) value at the given offset.

    The offset must be less than the size of the memblock. The first value is at offset 0. For best performance the
    offset should be a multiple of 4 because reading integer values that are not aligned to 4 byte boundaries incurs a
    hardware performance penalty. Int values are stored in little endian format so writing an int of 23 at offset 0 and
    then reading it back in bytes would return the byte at offset 0 as 23, the byte at offset 1 as 0, the byte at offset
    2 as 0, and the byte at offset 3 as 0. The returned value will be a signed integer between -2,147,483,648 and
    2,147,483,647.

    :param int memblock_id: The ID of the memblock to check.
    :param int offset: The offset from the start of the memblock of the value to return, between 0 and size.
    :rtype: int
    """
    pass    


def get_memblock_sha1(memblock_id: int) -> str:
    """
    Hashes the memblock with SHA1 and returns the resulting hash.

    :param int memblock_id: The ID of the memblock to hash.
    :rtype: str
    """
    pass    


def get_memblock_sha256(memblock_id: int) -> str:
    """
    Hashes the memblock with SHA256 and returns the resulting hash.

    :param int memblock_id: The ID of the memblock to hash.
    :rtype: str
    """
    pass    


def get_memblock_short(memblock_id: int, offset: int) -> int:
    """
    Returns the short (2 byte) value at the given offset.

    The offset must be less than the size of the memblock. The first value is at offset 0. For best performance the
    offset should be a multiple of 2 because reading short values that are not aligned to 2 byte boundaries incurs a
    hardware performance penalty. Short values are stored in little endian format so writing a short of 23 at offset 0
    and then reading it back in bytes would return the byte at offset 0 as 23 and the byte at offset 1 as 0. The
    returned value will be a signed short between -32768 and 32767.

    :param int memblock_id: The ID of the memblock to check.
    :param int offset: The offset from the start of the memblock of the value to return, between 0 and size.
    :rtype: int
    """
    pass    


def get_memblock_size(memblock_id: int) -> int:
    """
    Returns the size of the given memblock in bytes.

    :param int memblock_id: The ID of the memblock to check.
    :rtype: int
    """
    pass    


def get_memblock_string(memblock_id: int, offset: int, length: int) -> str:
    """
    Returns a given number of bytes at the given offset and interprets them as a string.

    The offset plus length must be less than the size of the memblock. The first value is at offset 0. The string will
    be null terminated even if no null terminator is found in the memblock. If a null terminator occurs before length is
    reached then all the bytes will still be read, but only the characters up to the first null terminator will be
    accessible in AGK.

    :param int memblock_id: The ID of the memblock to check.
    :param int offset: The offset from the start of the memblock of the value to return, between 0 and size.
    :param int length: The number of bytes to read.
    :rtype: str
    """
    pass    


def get_mesh_memblock_vertex_alpha(memblock_id: int, vertex: int) -> int:
    """
    Provides a quick way to get the alpha value of the specified vertex from the memblock.

    It uses the attribute data from the beginning of the memblock to work out the vertex offset and the location of the
    color values.

    :param int memblock_id: The ID of the memblock to check.
    :param int vertex: The index of the vertex to check.
    :rtype: int
    """
    pass    


def get_mesh_memblock_vertex_blue(memblock_id: int, vertex: int) -> int:
    """
    Provides a quick way to get the blue value of the specified vertex from the memblock.

    It uses the attribute data from the beginning of the memblock to work out the vertex offset and the location of the
    color values.

    :param int memblock_id: The ID of the memblock to check.
    :param int vertex: The index of the vertex to check.
    :rtype: int
    """
    pass    


def get_mesh_memblock_vertex_green(memblock_id: int, vertex: int) -> int:
    """
    Provides a quick way to get the green value of the specified vertex from the memblock.

    It uses the attribute data from the beginning of the memblock to work out the vertex offset and the location of the
    color values.

    :param int memblock_id: The ID of the memblock to check.
    :param int vertex: The index of the vertex to check.
    :rtype: int
    """
    pass    


def get_mesh_memblock_vertex_normal_x(memblock_id: int, vertex: int) -> float:
    """
    Provides a quick way to get the X component of the normal of the specified vertex from the memblock.

    It uses the attribute data from the beginning of the memblock to work out the vertex offset and the location of the
    normal values.

    :param int memblock_id: The ID of the memblock to check.
    :param int vertex: The index of the vertex to check.
    :rtype: float
    """
    pass    


def get_mesh_memblock_vertex_normal_y(memblock_id: int, vertex: int) -> float:
    """
    Provides a quick way to get the Y component of the normal of the specified vertex from the memblock.

    It uses the attribute data from the beginning of the memblock to work out the vertex offset and the location of the
    normal values.

    :param int memblock_id: The ID of the memblock to check.
    :param int vertex: The index of the vertex to check.
    :rtype: float
    """
    pass    


def get_mesh_memblock_vertex_normal_z(memblock_id: int, vertex: int) -> float:
    """
    Provides a quick way to get the Z component of the normal of the specified vertex from the memblock.

    It uses the attribute data from the beginning of the memblock to work out the vertex offset and the location of the
    normal values.

    :param int memblock_id: The ID of the memblock to check.
    :param int vertex: The index of the vertex to check.
    :rtype: float
    """
    pass    


def get_mesh_memblock_vertex_red(memblock_id: int, vertex: int) -> int:
    """
    Provides a quick way to get the red value of the specified vertex from the memblock.

    It uses the attribute data from the beginning of the memblock to work out the vertex offset and the location of the
    color values.

    :param int memblock_id: The ID of the memblock to check.
    :param int vertex: The index of the vertex to check.
    :rtype: int
    """
    pass    


def get_mesh_memblock_vertex_u(memblock_id: int, vertex: int) -> float:
    """
    Provides a quick way to get the U value of the specified vertex from the memblock.

    It uses the attribute data from the beginning of the memblock to work out the vertex offset and the location of the
    UV values.

    :param int memblock_id: The ID of the memblock to check.
    :param int vertex: The index of the vertex to check.
    :rtype: float
    """
    pass    


def get_mesh_memblock_vertex_v(memblock_id: int, vertex: int) -> float:
    """
    Provides a quick way to get the V value of the specified vertex from the memblock.

    It uses the attribute data from the beginning of the memblock to work out the vertex offset and the location of the
    UV values.

    :param int memblock_id: The ID of the memblock to check.
    :param int vertex: The index of the vertex to check.
    :rtype: float
    """
    pass    


def get_mesh_memblock_vertex_x(memblock_id: int, vertex: int) -> float:
    """
    Provides a quick way to get the X position of the specified vertex from the memblock.

    It uses the attribute data from the beginning of the memblock to work out the vertex offset and the location of the
    position values.

    :param int memblock_id: The ID of the memblock to check.
    :param int vertex: The index of the vertex to check.
    :rtype: float
    """
    pass    


def get_mesh_memblock_vertex_y(memblock_id: int, vertex: int) -> float:
    """
    Provides a quick way to get the Y position of the specified vertex from the memblock.

    It uses the attribute data from the beginning of the memblock to work out the vertex offset and the location of the
    position values.

    :param int memblock_id: The ID of the memblock to check.
    :param int vertex: The index of the vertex to check.
    :rtype: float
    """
    pass    


def get_mesh_memblock_vertex_z(memblock_id: int, vertex: int) -> float:
    """
    Provides a quick way to get the Z position of the specified vertex from the memblock.

    It uses the attribute data from the beginning of the memblock to work out the vertex offset and the location of the
    position values.

    :param int memblock_id: The ID of the memblock to check.
    :param int vertex: The index of the vertex to check.
    :rtype: float
    """
    pass    


def set_memblock_byte(memblock_id: int, offset: int, value: int) -> None:
    """
    Writes a single byte value at the given offset.

    The offset must be less than the size of the memblock. The first value is at offset 0. The given value will be
    truncated to the range 0 and 255.

    :param int memblock_id: The ID of the memblock to modify.
    :param int offset: The offset from the start of the memblock to write to, between 0 and size.
    :param int value: The value to write.
    :rtype: None
    """
    pass    


def set_memblock_byte_signed(memblock_id: int, offset: int, value: int) -> None:
    """
    Writes a single byte value at the given offset.

    The offset must be less than the size of the memblock. The first value is at offset 0. The given value will be
    truncated to the range -128 and 127.

    :param int memblock_id: The ID of the memblock to modify.
    :param int offset: The offset from the start of the memblock to write to, between 0 and size.
    :param int value: The value to write.
    :rtype: None
    """
    pass    


def set_memblock_float(memblock_id: int, offset: int, value: Union[float, int]) -> None:
    """
    Write a float (4 byte) value at the given offset.

    The offset must be less than the size of the memblock. The first value is at offset 0. For best performance the
    offset should be a multiple of 4 because writing float values that are not aligned to 4 byte boundaries incurs a
    hardware performance penalty. Float values are stored in IEEE 754 format so writing an float and then reading it
    back in bytes would return various components of the float format.

    :param int memblock_id: The ID of the memblock to modify.
    :param int offset: The offset from the start of the memblock to write to, between 0 and size.
    :param Union[float, int] value: The value to write.
    :rtype: None
    """
    pass    


def set_memblock_int(memblock_id: int, offset: int, value: int) -> None:
    """
    Writes an int (4 byte) value at the given offset.

    The offset must be less than the size of the memblock. The first value is at offset 0. For best performance the
    offset should be a multiple of 4 because writing integer values that are not aligned to 4 byte boundaries incurs a
    hardware performance penalty. Int values are stored in little endian format so writing an int of 23 at offset 0 and
    then reading it back in bytes would return the byte at offset 0 as 23, the byte at offset 1 as 0, the byte at offset
    2 as 0, and the byte at offset 3 as 0.

    :param int memblock_id: The ID of the memblock to modify.
    :param int offset: The offset from the start of the memblock to write to, between 0 and size.
    :param int value: The value to write.
    :rtype: None
    """
    pass    


def set_memblock_short(memblock_id: int, offset: int, value: int) -> None:
    """
    Writes a short (2 byte) value at the given offset.

    The offset must be less than the size of the memblock. The first value is at offset 0. For best performance the
    offset should be a multiple of 2 because writing short values that are not aligned to 2 byte boundaries incurs a
    hardware performance penalty. Short values are stored in little endian format so writing a short of 23 at offset 0
    and then reading it back in bytes would return the byte at offset 0 as 23 and the byte at offset 1 as 0. The given
    value will be truncated to the range -32768 and 32767.

    :param int memblock_id: The ID of the memblock to modify.
    :param int offset: The offset from the start of the memblock to write to, between 0 and size.
    :param int value: The value to write.
    :rtype: None
    """
    pass    


def set_memblock_string(memblock_id: int, offset: int, value: str) -> None:
    """
    Writes a string to a memblock as raw bytes.

    The first null terminator found will end the string and a single null terminator will be written to the memblock
    data. To read the string out of the memblock again you will need to know its length, so it is recommended that you
    also write a string length value before the string data to help read the string back later. The offset plus the
    length of the string, plus 1 for the null terminator, must be less than the memblock size.

    :param int memblock_id: The ID of the memblock to modify.
    :param int offset: The offset from the start of the memblock to write to, between 0 and size.
    :param str value: The string to write.
    :rtype: None
    """
    pass    


def set_mesh_memblock_vertex_color(memblock_id: int, vertex: int, red: int, green: int, blue: int,
                                   alpha: int) -> None:
    """
    Provides a quick way to modify the color values of a vertex inside a mesh memblock.

    It uses the attribute data from the beginning of the memblock to work out the vertex offset and change the color
    values. Vertices start at index 0. Color values must be between 0 and 255.

    :param int memblock_id: The ID of the memblock to modify.
    :param int vertex: The index of the vertex to modify.
    :param int red: The new red value for this vertex.
    :param int green: The new green value for this vertex.
    :param int blue: The new blue value for this vertex.
    :param int alpha: The new alpha value for this vertex.
    :rtype: None
    """
    pass    


def set_mesh_memblock_vertex_normal(memblock_id: int, vertex: int, x: Union[float, int],
                                    y: Union[float, int], z: Union[float, int]) -> None:
    """
    Provides a quick way to modify the normal of a vertex inside a mesh memblock.

    It uses the attribute data from the beginning of the memblock to work out the vertex offset and change the normal
    values. Vertices start at index 0.

    :param int memblock_id: The ID of the memblock to modify.
    :param int vertex: The index of the vertex to modify.
    :param Union[float, int] x: The X component of the new normal for this vertex.
    :param Union[float, int] y: The Y component of the new normal for this vertex.
    :param Union[float, int] z: The Z component of the new normal for this vertex.
    :rtype: None
    """
    pass    


def set_mesh_memblock_vertex_position(memblock_id: int, vertex: int, x: Union[float, int],
                                      y: Union[float, int], z: Union[float, int]) -> None:
    """
    Provides a quick way to modify the position of a vertex inside a mesh memblock.

    It uses the attribute data from the beginning of the memblock to work out the vertex offset and change the position
    values. Vertices start at index 0.

    :param int memblock_id: The ID of the memblock to modify.
    :param int vertex: The index of the vertex to modify.
    :param Union[float, int] x: The new X position for this vertex.
    :param Union[float, int] y: The new Y position for this vertex.
    :param Union[float, int] z: The new Z position for this vertex.
    :rtype: None
    """
    pass    


def set_mesh_memblock_vertex_uv(memblock_id: int, vertex: int, u: Union[float, int], v: Union[float,
                                int]) -> None:
    """
    Provides a quick way to modify the UV values of a vertex inside a mesh memblock.

    It uses the attribute data from the beginning of the memblock to work out the vertex offset and change the UV
    values. Vertices start at index 0.

    :param int memblock_id: The ID of the memblock to modify.
    :param int vertex: The index of the vertex to modify.
    :param Union[float, int] u: The new U value for this vertex.
    :param Union[float, int] v: The new V value for this vertex.
    :rtype: None
    """
    pass    


def set_object_mesh_from_memblock(object_id: int, mesh: int, memblock_id: int) -> None:
    """
    Changes an object's mesh based on the memblock provided.

    The memblock need not have the same number of attributes or vertices as the original mesh, but it will improve
    performance if it does.

    The first 4 bytes of the memblock represent the number of vertices in the mesh.

    The second 4 bytes represent the number of indices in the mesh, this may be 0 in which case every three vertices
    represents a polygon, and no vertices can be shared. If the number of indices is greater than 0 then every three
    indices represent a polygon and vertices may be shared between polygons. Indices start at 0 so index 0 references
    the first vertex in the list.

    The third 4 bytes represents the number of attributes per vertex, e.g. position, normals, and UV data are all
    potential attributes, so a vertex containing all three would have 3 attributes. A vertex must have a position
    attribute, everything else is optional.

    The fourth 4 bytes represent the size of a single vertex in bytes, this can be calculated from the attribute data
    but is given for convenience.

    The fifth 4 bytes is offset for the beginning of the vertex data, so you can reach it easily.

    The sixth 4 bytes is offset for the beginning of the index data, will be 0 if there are no indices.

    After those 6 values, starting at offset 24, is the vertex attribute data. The vertex attribute data describes how
    the vertex data is laid out, for example if it has normals, UV data, etc.

    For each attribute there is a 1 byte data type, 1 byte component count, 1 byte normalize flag, 1 byte string length,
    and X bytes of string data for the attribute name. The data type will be 0 for floats (used for almost everything,
    e.g. position, normals, etc) or 1 for unsigned bytes (used for vertex colors).

    The component count is the number of values per attribute, e.g. position has 3 components, x,y,z, UV data has 2
    components, and vertex colors have 4 components. Note that any unsigned byte data type must have 4 components even
    if some are unused.

    The normalize flag is only used for unsigned byte data types and will convert values in the range 0-255 into 0.0-1.0
    for use in a shader. Usually the normalize flag will be 1 for color attributes and 0 for everything else.

    The string length byte must always be a multiple of 4 for alignment reasons, the string itself might have slightly
    less characters but always round up to the nearest multiple of 4 for the string length value. e.g. a string of
    length 5 should have a string length value of 8. Note that a string of 4 characters has a null terminator on the end
    which makes it length 5, so even though it has a multiple of 4 characters already it must use a length value of 8
    due to the null terminator.

    The attribute name string will be used by the shader to recognise what the vertex data is, the attribute names
    recognised by AGK are "position", "normal", "tangent", "binormal", "color", "uv", "uv1", "boneweights", and
    "boneindices", however you may add attributes with any name you like as long as you write a matching shader that has
    the same names. If you are not using your own shader and instead rely on AGK to draw the object then you must stick
    to the above attribute names.

    Following the attribute data is the raw vertex data, which usually starts with the "position" attribute. It will be
    a 4 byte float for the X position, a 4 byte float for the Y position, and a 4 byte float for the Z position. This
    continues for each attribute specified in the attribute data. Note that color data will always be 4 bytes in total,
    1 unsigned byte for each color channel. You can access individual vertices by using the vertex size provided above
    and the vertex index like so offset=vertexDataOffset+(vertexIndex*vertexSize).

    Lastly is the index data, if present. Each index is a 4 byte integer which references a vertex in the vertex data.
    Every three indices represents a polygon.

    If you plan on making regular changes to the mesh you should keep the memblock around after using
    `set_object_mesh_from_memblock()` instead of regenerating from the object it every time you want to make a change.
    Then call `set_object_mesh_from_memblock()` again when you want to push your new changes onto the object.

    :param int object_id: The ID of the object to modify.
    :param int mesh: The index of the mesh to modify.
    :param int memblock_id: The index of the memblock to use to modify the mesh.
    :rtype: None
    """
    pass    


def add_network_message_byte(message_id: int, value: int) -> None:
    """
    Adds an unsigned byte to a previously created network message. This can be called on messages created by
    `create_network_message()` or on messages received from the network.

    :param int message_id: The ID of the message to modify.
    :param int value: The value to add to the message.
    :rtype: None
    """
    pass    


def add_network_message_float(message_id: int, value: Union[float, int]) -> None:
    """
    Adds a float to a previously created network message.

    This can be called on messages created by `create_network_message()` or on messages received from the network.

    :param int message_id: The ID of the message to modify.
    :param Union[float, int] value: The value to add to the message.
    :rtype: None
    """
    pass    


def add_network_message_integer(message_id: int, value: int) -> None:
    """
    Adds an integer to a previously created network message.

    This can be called on messages created by `create_network_message()` or on messages received from the network.

    :param int message_id: The ID of the message to modify.
    :param int value: The value to add to the message.
    :rtype: None
    """
    pass    


def add_network_message_string(message_id: int, value: str) -> None:
    """
    Adds a string to a previously created network message.

    This can be called on messages created by `create_network_message()` or on messages received from the network.

    :param int message_id: The ID of the message to modify.
    :param str value: The string to add to the message.
    :rtype: None
    """
    pass    


def close_network(network_id: int) -> None:
    """
    Disconnects from the specified network.

    The ID is freed and can no longer be used in other network commands.

    :param int network_id: The ID of the network to disconnect from.
    :rtype: None
    """
    pass    


def connect_socket(ip: str, port: int, timeout: int) -> int:
    """
    Creates a socket and attempts to connect to the specified IP address.

    This will create a TCP connection that you can then use to send and receive data. This command will return
    immediately and connect in the background, you should use `get_socket_connected()` to check if the socket connects
    successfully or fails. You should give a timeout value that is long enough for the socket to connect, typically 3000
    milliseconds is a good value, but high latency connections might need longer. If the connection times out then this
    command will return 0. The port number must match the listening port of the device you are connecting to.

    This works slightly differently when exported to HTML5, it uses a WebSocket which sends an HTTP style header and
    requires an HTTP style response to connect.

    :param str ip: The IP address to connect to, this can be IPv4 or IPv6.
    :param int port: The TCP port to connect to, in the range 1025 to 65535.
    :param int timeout: The time in milliseconds to wait before aborting the connection attempt.
    :rtype: int
    """
    pass    


def connect_socket_id(socket_id: int, ip: str, port: int, timeout: int) -> int:
    """
    Creates a socket and attempts to connect to the specified IP address.

    This will create a TCP connection that you can then use to send and receive data. This command will return
    immediately and connect in the background, you should use `get_socket_connected()` to check if the socket connects
    successfully or fails. You should give a timeout value that is long enough for the socket to connect, typically 3000
    milliseconds is a good value, but high latency connections might need longer. If the connection times out then this
    command will return 0. The port number must match the listening port of the device you are connecting to.

    This works slightly differently when exported to HTML5, it uses a WebSocket which sends an HTTP style header and
    requires an HTTP style response to connect.

    :param int socket_id: An ID to use to reference this socket later.
    :param str ip: The IP address to connect to, this can be IPv4 or IPv6.
    :param int port: The TCP port to connect to, in the range 1025 to 65535.
    :param int timeout: The time in milliseconds to wait before aborting the connection attempt.
    :rtype: int
    """
    pass    


def copy_network_message(from_message_id: int) -> int:
    """
    Creates a network message that is a copy of an existing message.

    It returns an ID that can be used to interact with the message. Messages created in this way can read from the
    beginning or added to, and the source messsage can be either a message you have created, or one you have received.
    The new message becomes completely independent of the source message and can be sent using `send_network_message()`
    without affecting the original.

    :param int from_message_id: The id of the message to copy.
    :rtype: int
    """
    pass    


def create_broadcast_listener(port: int) -> int:
    """
    Broadcasts are special network communications as they do not use a destination address and are instead received by
    all devices on a network.

    Broadcast packets are not forwarded by routers so can only be used on the local area network, or more specifically
    the local subnet. This can be useful for discovering devices as one device can send a broadcast packet containing
    its IP address and another device can pick it up, read the IP and connect back to the first device to create a two-
    way connection.

    Warning, if the device listening for broadcasts is an iOS device then it may not be able to receive broadcast
    packets without permission from Apple. As of writing receiving is still allowed but sending requires permission from
    Apple, this may change in future

    AGK networks are broadcast in this manner on port 45631 and send a packet containing the name of a network that has
    been hosted by another AGK device. By using a broadcast listener you can pick these messages up, extract the network
    names and display them to the user for them to choose which network they want to connect to.

    If the device is on an IPv6 network then these rules change slightly. `create_broadcast_listener()` must be called
    with a multicast address, which begins with ff, for example ff02::1 and the broadcast listener will only receive
    packets sent to this multicast address. If no address is specified then the broadcaster will only receive IPv4
    broadcasts. If you pass the address "anyip6" then the broadcast listener will listen on the AGK multicast address
    "FF02::41:474B" which is used for named network discovery on port 45631.

    Returns an ID you can use to interact with this broadcast listener.

    :param int port: The port that the messages are being broadcast on, in the case of AGK networks this will be port
        45631.
    :rtype: int
    """
    pass    


def create_broadcast_listener_ipv6(ipv6: str, port: int) -> int:
    """
    Broadcasts are special network communications as they do not use a destination address and are instead received by
    all devices on a network.

    Broadcast packets are not forwarded by routers so can only be used on the local area network, or more specifically
    the local subnet. This can be useful for discovering devices as one device can send a broadcast packet containing
    its IP address and another device can pick it up, read the IP and connect back to the first device to create a two-
    way connection.

    Warning, if the device listening for broadcasts is an iOS device then it may not be able to receive broadcast
    packets without permission from Apple. As of writing receiving is still allowed but sending requires permission from
    Apple, this may change in future

    AGK networks are broadcast in this manner on port 45631 and send a packet containing the name of a network that has
    been hosted by another AGK device. By using a broadcast listener you can pick these messages up, extract the network
    names and display them to the user for them to choose which network they want to connect to.

    If the device is on an IPv6 network then these rules change slightly. `create_broadcast_listener()` must be called
    with a multicast address, which begins with ff, for example ff02::1 and the broadcast listener will only receive
    packets sent to this multicast address. If no address is specified then the broadcaster will only receive IPv4
    broadcasts. If you pass the address "anyip6" then the broadcast listener will listen on the AGK multicast address
    "FF02::41:474B" which is used for named network discovery on port 45631.

    Returns an ID you can use to interact with this broadcast listener.

    :param str ipv6: The multicast IP to listen for, only applies to IPv6 networks, if left empty then it will listen
        for IPv4 broadcasts.
    :param int port: The port that the messages are being broadcast on, in the case of AGK networks this will be port
        45631.
    :rtype: int
    """
    pass    


def create_network_message() -> int:
    """
    Creates a network message that can be sent to another network device.

    It returns an ID that can be used to interact with the message. Messages created in this way can only be added to,
    not read from. Once passed to a network the message ID is destroyed and handled by the background network code.

    :rtype: int
    """
    pass    


def create_socket_listener(ip: str, port: int) -> int:
    """
    Creates a socket listener that listens on a specified port for incoming socket connections.

    When a connection occurs it will be held in a queue until you retrieve it with `get_socket_listener_connection()`.
    If you want to reject a connection you must retrieve it and then delete it. The listener will continue accepting
    connections until it is deleted. If your device has multiple network interfaces then you can specify which one to
    listen on by using the IP address parameter. To listen on all interfaces use an empty string as the IP address.

    If the device has both IPv4 and IPv6 addresses then the listener can only listen on one or the other, not both. To
    listen for both IPv4 and IPv6 connections you need to create two listeners, one for the IPv4 connections and one for
    the IPv6 connections. Connections from either will behave exactly the same after they are connected. To create an
    IPv6 listener pass an IPv6 IP address to `create_socket_listener()`, or "anyip6" to listen on any suitable IPv6
    address. If you pass an empty string or "anyip4" as the IP address then it will listen for IPv4 connections.

    You can have multiple listeners active at the same time, but they must all use different ports or IPs.

    When choosing a port number you should avoid low values as these will frequently be used by other apps and services.
    If something is already listening on a port then your attempt to listen on it will fail.

    Returns 0 if it failed to start listening.

    :param str ip: The IP address of the interface to listen on, can be IPv4 or IPv6, or "anyip4", or "anyip6".
    :param int port: The TCP port to listen on, in the range 1025 to 65535.
    :rtype: int
    """
    pass    


def create_socket_listener_id(listener_id: int, ip: str, port: int) -> int:
    """
    Creates a socket listener that listens on a specified port for incoming socket connections.

    When a connection occurs it will be held in a queue until you retrieve it with `get_socket_listener_connection()`.
    If you want to reject a connection you must retrieve it and then delete it. The listener will continue accepting
    connections until it is deleted. If your device has multiple network interfaces then you can specify which one to
    listen on by using the IP address parameter. To listen on all interfaces use an empty string as the IP address.

    If the device has both IPv4 and IPv6 addresses then the listener can only listen on one or the other, not both. To
    listen for both IPv4 and IPv6 connections you need to create two listeners, one for the IPv4 connections and one for
    the IPv6 connections. Connections from either will behave exactly the same after they are connected. To create an
    IPv6 listener pass an IPv6 IP address to `create_socket_listener()`, or "anyip6" to listen on any suitable IPv6
    address. If you pass an empty string or "anyip4" as the IP address then it will listen for IPv4 connections.

    You can have multiple listeners active at the same time, but they must all use different ports or IPs.

    When choosing a port number you should avoid low values as these will frequently be used by other apps and services.
    If something is already listening on a port then your attempt to listen on it will fail.

    Returns 0 if it failed to start listening.

    :param int listener_id: An ID to use to reference this listener in the future.
    :param str ip: The IP address of the interface to listen on, can be IPv4 or IPv6, or "anyip4", or "anyip6".
    :param int port: The TCP port to listen on, in the range 1025 to 65535.
    :rtype: int
    """
    pass    


def create_udp_listener(ip: str, port: int) -> int:
    """
    Creates a UDP listener that will recieve UDP packets on the specified IP and port.

    The port value must be in the range 1 to 65535, although values below 1024 are likely to be protected by the
    operating system. If the port is already occupied then this command will fail and return 0. The IP address may be an
    IPv4 or IPv6 address, and can be used to bind to a single incomming network connection when a device has more than
    one IP. To bind to any IP address use the IP address "anyip4" or "anyip6". A single UDP listener can listen on
    either an IPv4 or an IPv6 address, but not both at the same time. To listen on both you should create two listeners,
    one for IPv4 and one for IPv6, in this case they may both use the same port. This command will return the ID of the
    listener that you can use to reference it in future commands.

    :param str ip: The local IP address to bind to.
    :param int port: The local port to bind to.
    :rtype: int
    """
    pass    


def create_udp_listener_id(listener_id: int, ip: str, port: int) -> int:
    """
    Creates a UDP listener that will recieve UDP packets on the specified IP and port.

    The port value must be in the range 1 to 65535, although values below 1024 are likely to be protected by the
    operating system. If the port is already occupied then this command will fail and return 0. The IP address may be an
    IPv4 or IPv6 address, and can be used to bind to a single incomming network connection when a device has more than
    one IP. To bind to any IP address use the IP address "anyip4" or "anyip6". A single UDP listener can listen on
    either an IPv4 or an IPv6 address, but not both at the same time. To listen on both you should create two listeners,
    one for IPv4 and one for IPv6, in this case they may both use the same port. This command will return the ID of the
    listener that you can use to reference it in future commands.

    :param int listener_id: The ID to use to reference this listener in future.
    :param str ip: The local IP address to bind to.
    :param int port: The local port to bind to.
    :rtype: int
    """
    pass    


def delete_broadcast_listener(listener_id: int) -> None:
    """
    Deletes a broadcast listener and frees up the port for something else to listen on it.

    :param int listener_id: The ID of the broadcast listener to delete.
    :rtype: None
    """
    pass    


def delete_network_client(network_id: int, client_id: int) -> None:
    """
    Deletes a disconnected client from the client list.

    If this function is called on a client that is not disconnected it will produce an error and not affect the client.
    Does not delete the client immediately, the background code may take a few frames to get around to deleting it.
    Calling this command multiple times on a disconnected client should not cause a problem.

    :param int network_id: The ID of the network to check.
    :param int client_id: The ID of the client to delete.
    :rtype: None
    """
    pass    


def delete_network_message(message_id: int) -> None:
    """
    Deletes a network message, this should be called on messages received from network devices and messages that have
    not been sent to a network device (if code decides to back out of sending a message).

    Messages that have been created and sent will be handled and deleted by the network code and should not be deleted
    using this command.

    :param int message_id: The ID of the message to read.
    :rtype: None
    """
    pass    


def delete_socket(socket_id: int) -> None:
    """
    Deletes the socket ID so it can be used again.

    If the socket is currently connected then the connection is closed first.

    :param int socket_id: The ID of the socket to delete.
    :rtype: None
    """
    pass    


def delete_socket_listener(listener_id: int) -> None:
    """
    Stops the socket listener from receiving connections and frees the ID to be used again.

    If any connections are still in the queue and have yet to be collected using `get_socket_listener_connection()` then
    they will be closed and deleted.

    :param int listener_id: The ID of the listener to check.
    :rtype: None
    """
    pass    


def delete_udp_listener(listener_id: int) -> None:
    """
    Deletes the specified UDP listenere and frees up the port it was using.

    :param int listener_id: The ID of the listener to delete
    :rtype: None
    """
    pass    


def flush_socket(socket_id: int) -> bool:
    """
    Immediately sends any waiting data to the remote host.

    If you do not call this then data will will wait forever in the buffer until you write more than 1400 bytes to the
    socket, at which point it will automatically be flushed. Every time you call this command a new packet will be sent,
    so when you are sending multiple values you should not call it after each value, as that would waste network
    bandwidth. You should write all the values and then flush so they will be sent together. If there is no data waiting
    to be sent this command does nothing.

    Returns True if the socket was successfully flushed, False if the socket disconnected.

    :param int socket_id: The ID of the socket to check.
    :rtype: bool
    """
    pass    


def get_broadcast_message(listener_id: int) -> int:
    """
    Checks a broadcast listener for any broadcasts.

    Returns 0 if nothing has been received. Returns a message ID if something has been received, you can access the
    contents of this message using network message commands. The message must be deleted when you have finished reading
    from it.

    :param int listener_id: The ID of the broadcast listener to check.
    :rtype: int
    """
    pass    


def get_device_ip() -> str:
    """
    Returns the IPv4 address of the current device, this can be used by other devices to connect to this device.

    To get the IPv6 address use `get_device_ipv6()` instead.

    :rtype: str
    """
    pass    


def get_device_ipv6() -> str:
    """
    Returns the IPv6 address of the current device, this can be used by other devices to connect to this device.

    To get the IPv4 address use `get_device_ip()` instead.

    :rtype: str
    """
    pass    


def get_network_client_disconnected(network_id: int, client_id: int) -> bool:
    """
    Checks whether the specified client has disconnected.

    Disconnected clients are not automatically removed from the client list, allowing you to handle their clean up
    properly. Once you have dealt with this client you must remove it from the client list by calling
    `delete_network_client()`. The client may persist for a little while until the background network code gets around
    to actually deleting it so be prepared for this client to hang around for a few frames declaring that it is
    disconnected and make sure you only clean it up once. You can detect this by setting one of the
    `set_network_client_user_data()` values to notify yourself that it has been dealt with.

    :param int network_id: The ID of the network to check.
    :param int client_id: The ID of the client to check.
    :rtype: bool
    """
    pass    


def get_network_client_float(network_id: int, client_id: int, name: str) -> float:
    """
    Gets a copy of a remote client's float variable by name.

    Can also be used on the client's own variables if the clientID equals `get_network_my_client_id()`. If the variable
    was set as a resetting variable it will return to 0 once read, this does not affect other clients ability to read
    the original value. They will each reset their own copy.

    If the specified client has not set a variable of the given name the value 0 is returned.

    :param int network_id: The ID of the network to check.
    :param int client_id: The ID of the client to check.
    :param str name: The name of the variable to return.
    :rtype: float
    """
    pass    


def get_network_client_integer(network_id: int, client_id: int, name: str) -> int:
    """
    Gets a copy of a remote client's integer variable by name.

    Can also be used on the client's own variables if the clientID equals `get_network_my_client_id()`. If the variable
    was set as a resetting variable it will return to 0 once read, this does not affect other clients ability to read
    the original value. They will each reset their own copy.

    If the specified client has not set a variable of the given name the value 0 is returned.

    :param int network_id: The ID of the network to check.
    :param int client_id: The ID of the client to check.
    :param str name: The name of the variable to return.
    :rtype: int
    """
    pass    


def get_network_client_ip(network_id: int, client_id: int) -> str:
    """
    Returns the IP address being used by the specified `client_id`. This command only works on the server as clients do
    not connect directly to each other

    :param int network_id: The ID of the network to check.
    :param int client_id: the ID of the client to check.
    :rtype: str
    """
    pass    


def get_network_client_name(network_id: int, client_id: int) -> str:
    """
    Returns the name the client used to identify itself when it connected to the host.

    :param int network_id: The ID of the network to check.
    :param int client_id: The ID of the client to check.
    :rtype: str
    """
    pass    


def get_network_client_ping(network_id: int, client_id: int) -> float:
    """
    Returns the ping between the given client and the host.

    To get the total transit time of data from one client to another you must add the two ping times for both clients
    together as all data goes via the host. If you use the host's client ID it will return 0 as the host has no ping to
    itself.The value returned is in seconds as a floating point value.

    :param int network_id: The ID of the network to check.
    :param int client_id: The ID of the client to check.
    :rtype: float
    """
    pass    


def get_network_client_user_data(network_id: int, client_id: int, slot: int) -> int:
    """
    Reads one of the local data slots assigned to the client set using `set_network_client_user_data()`.

    :param int network_id: The ID of the network to get the value from.
    :param int client_id: The ID of the client on the network to get the value from.
    :param int slot: The index (0-4) of the data slot to read.
    :rtype: int
    """
    pass    


def get_network_exists(network_id: int) -> bool:
    """
    Returns True if a network exists at the given ID, otherwise it returns False.

    :param int network_id: The ID of the network to check.
    :rtype: bool
    """
    pass    


def get_network_first_client(network_id: int) -> int:
    """
    Returns the Client ID of the first client in the client list.

    Use this function to start going through the list of clients and continue with `get_network_next_client()` until it
    returns 0. It is very important that once this command is called `get_network_next_client()` is called until it
    returns 0 as the background network code cannot continue until it knows you are finished with the client list.

    The local client will also be returned at some point, which can be detected by comparing the returned ID with
    `get_network_my_client_id()`. The host client will also be returned at some point which can be detected by comparing
    the returned ID with `get_network_server_id()`.

    :param int network_id: The ID of the network to check.
    :rtype: int
    """
    pass    


def get_network_message(network_id: int) -> int:
    """
    Check the network for any messages sent to this client.

    If none are found it returns 0. If a message is found it returns a message ID you can use to read the message. You
    must delete the message using `delete_network_message()` when you are done reading it. You should keep calling
    `get_network_message()` until it returns 0 to make sure you have received all the messages. You can use the message
    reading commands to find out which client ID sent the message.

    :param int network_id: The ID of the network to check for messages.
    :rtype: int
    """
    pass    


def get_network_message_byte(message_id: int) -> int:
    """
    Gets a single unsigned byte from the message and advances the message pointer to the next message item. Messages
    should be created and read according to known formats, e.g. string, int, string as there is no immediate way for the
    receiver to know the format of a message. You could use an initial integer to specify a message type ID which you
    can use to identify the message format.

    :param int message_id: The ID of the message to read.
    :rtype: int
    """
    pass    


def get_network_message_float(message_id: int) -> float:
    """
    Gets a single float from the message and advances the message pointer to the next message item.

    Messages should be created and read according to known formats, e.g. string, int, string as there is no immediate
    way for the receiver to know the format of a message. You could use an initial integer to specify a message type ID
    which you can use to identify the message format.

    :param int message_id: The ID of the message to read.
    :rtype: float
    """
    pass    


def get_network_message_from_client(message_id: int) -> int:
    """
    Returns the client ID that sent this message.

    Only applicable to messages received from networks, broadcast listener and UDP messages will return 0 for this
    function. It will also return 0 for messages created using `create_network_message()`.

    :param int message_id: The ID of the message to read.
    :rtype: int
    """
    pass    


def get_network_message_from_ip(message_id: int) -> str:
    """
    Returns the IP that sent this message.

    Only applicable to messages received from UDP and broadcast listeners, network messages will return an empty string
    for this function. It will also return an empty string for messages created using `create_network_message()`. This
    could be an IPv4 or IPv6 address.

    :param int message_id: The ID of the message to read.
    :rtype: str
    """
    pass    


def get_network_message_from_port(message_id: int) -> int:
    """
    Returns the source port that was used by this message.

    Only applicable to messages received from UDP and broadcast listeners, network messages will return 0 for this
    function. It will also return 0 for messages created using `create_network_message()`. This will be in the range 0
    to 65535.

    :param int message_id: The ID of the message to read.
    :rtype: int
    """
    pass    


def get_network_message_integer(message_id: int) -> int:
    """
    Gets a single integer from the message and advances the message pointer to the next message item.

    Messages should be created and read according to known formats, e.g. string, int, string as there is no immediate
    way for the receiver to know the format of a message. You could use an initial integer to specify a message type ID
    which you can use to identify the message format.

    :param int message_id: The ID of the message to read.
    :rtype: int
    """
    pass    


def get_network_message_string(message_id: int) -> str:
    """
    Gets a single string from the message and advances the message pointer to the next message item.

    Messages should be created and read according to known formats, e.g. string, int, string as there is no immediate
    way for the receiver to know the format of a message. You could use an initial integer to specify a message type ID
    which you can use to identify the message format.

    :param int message_id: The ID of the message to read.
    :rtype: str
    """
    pass    


def get_network_my_client_id(network_id: int) -> int:
    """
    Each client is assigned a unique ID by the host when it connects.

    This function returns the ID that you have been assigned. The host also assigns itself an ID which can be found
    using `get_network_server_id()`.

    :param int network_id: The ID of the network to check.
    :rtype: int
    """
    pass    


def get_network_next_client(network_id: int) -> int:
    """
    Returns the Client ID of the next client in the client list.

    Use this function to continue going through the list of clients started with `get_network_first_client()`. It is
    very important that this command is called until it returns 0 as the background network code cannot continue until
    it knows you are finished with the client list.

    The local client will also be returned at some point, which can be detected by comparing the returned ID with
    `get_network_my_client_id()`. The host client will also be returned at some point which can be detected by comparing
    the returned ID with `get_network_server_id()`.

    :param int network_id: The ID of the network to check.
    :rtype: int
    """
    pass    


def get_network_num_clients(network_id: int) -> int:
    """
    Returns the number of clients connected to the specified network.

    The host counts as a client as does the local client. Meaning that on a connected network there should be at least 2
    clients.

    A host waiting for clients returns 1 if it is on its own. A client trying to connect returns 0 until it connects and
    the host accepts the client, giving it a unique ID, it should then return 2.

    :param int network_id: The ID of the network to check.
    :rtype: int
    """
    pass    


def get_network_server_id(network_id: int) -> int:
    """
    Returns the client ID of the host's client.

    This is useful if you use the server to handle game setup variables such as board size, game length, etc, as only
    the host client should have a copy of these such variables.

    :param int network_id: The ID of the network to check.
    :rtype: int
    """
    pass    


def get_network_server_ip(network_id: int) -> str:
    """
    Returns the IP address being used by the server. This command only works on clients as the server can get its own IP
    using `get_device_ip()` and `get_device_ipv6()`.

    :param int network_id: The ID of the network to check.
    :rtype: str
    """
    pass    


def get_socket_byte(socket_id: int) -> int:
    """
    Will read a single byte from the socket connection and return it.

    If there is no data waiting to be read then this command will return immediately and return 0. You can check how
    much data there is to read by using `get_socket_bytes_available()`.

    :param int socket_id: The ID of the socket to read.
    :rtype: int
    """
    pass    


def get_socket_bytes_available(socket_id: int) -> int:
    """
    Returns the number of bytes available to be read.

    If this returns 0 then the read commands, like `get_socket_integer()` will return no data.

    :param int socket_id: The ID of the socket to check.
    :rtype: int
    """
    pass    


def get_socket_connected(socket_id: int) -> int:
    """
    Returns 1 if the specified socket is connected, 0 if it is still in the process of connecting.

    If the socket becomes disconnected or fails to connect then this will return -1.

    :param int socket_id: The ID of the socket to check.
    :rtype: int
    """
    pass    


def get_socket_exists(socket_id: int) -> bool:
    """
    Returns True if the specified socket exists, False otherwise.

    :param int socket_id: The ID of the socket to check.
    :rtype: bool
    """
    pass    


def get_socket_float(socket_id: int) -> float:
    """
    Will read a 4 byte float from the socket connection and return it.

    If there is less than 4 bytes of data waiting to be read then this command will return immediately and return 0. You
    can check how much data there is to read by using `get_socket_bytes_available()`.

    :param int socket_id: The ID of the socket to read.
    :rtype: float
    """
    pass    


def get_socket_integer(socket_id: int) -> int:
    """
    Will read a 4 byte integer from the socket connection and return it.

    If there is less than 4 bytes of data waiting to be read then this command will return immediately and return 0. You
    can check how much data there is to read by using `get_socket_bytes_available()`.

    :param int socket_id: The ID of the socket to read.
    :rtype: int
    """
    pass    


def get_socket_listener_connection(listener_id: int) -> int:
    """
    Returns the ID of a socket that has connected to your device.

    The listener will accept connections in the background and add them to a queue, this command removes one of the
    sockets from the queue and hands control of it to you. If you do not want to accept the connection you should delete
    it using `delete_socket()`. You should call `get_socket_listener_connection()` in a loop until it returns 0 to be
    sure you have dealt with all connected sockets. You can find out the IP address of the device that connected to you
    by calling `get_socket_remote_ip()` on the returned socket.

    :param int listener_id: The ID of the listener to check.
    :rtype: int
    """
    pass    


def get_socket_remote_ip(socket_id: int) -> str:
    """
    Returns the IP address of the computer or device at the other end of the connection.

    This could be an IPv4 or IPv6 address.

    :param int socket_id: The ID of the socket to check.
    :rtype: str
    """
    pass    


def get_socket_string(socket_id: int) -> str:
    """
    Will read a string from the socket connection and return it.

    If you are sending a string from a source other than AGK then the string must begin with a 4 byte length value
    followed by X bytes of string data, where X is the length value. The string should not be null terminated. If there
    is less than 4 bytes of data waiting to be read then this command will return immediately and return an empty
    string. You can check how much data there is to read by using `get_socket_bytes_available()`. If there are 4 or more
    bytes waiting to be read then this command will wait until the entire string has been received before returning.

    :param int socket_id: The ID of the socket to read.
    :rtype: str
    """
    pass    


def get_udp_network_message(listener_id: int) -> int:
    """
    Checks a UDP listener for any broadcasts.

    Returns 0 if nothing has been received. Returns a message ID if something has been received, you can access the
    contents of this message using network message commands. The message must be deleted when you have finished reading
    from it.

    :param int listener_id: The ID of the listener to check for messages
    :rtype: int
    """
    pass    


def host_network(network_name: str, my_name: str, port: int, portv6: Optional[int] = 0) -> int:
    """
    Creates an AGK network with this app as the controller, this app is added as the first client to the network.

    AGK networks are identified by name and are automatically broadcast to anyone listening on the local area network,
    meaning that other AGK apps on the LAN can pick up all broadcast networks, display their names to their users and
    allow them to choose one to join. AGK apps outside the LAN need the IP address and port of the hoster to join the
    network, this port will need forwarding to the host through any intervening firewall. The port value must be between
    1025 and 65535, and will fail if another application is already listening on that port.

    Warning, if the device hosting the network is an iOS device then the broadcasting part of this process will fail
    unless you get permission from Apple to send broadcast packets, see the following page to request permission https:
    developer.apple.com/contact/request/networking-multicast. If you do not have the permission then devices should
    still be able to join such a network if they have the IP address and port of the hosting device

    You must also specify a client name to use to identify your client, all client names must be unique. This name will
    be visible to all other clients. Clients will be added to the network automatically and can be counted using
    `get_network_num_clients()`. You can call `is_network_active()` immediately after this command to check that the
    network was setup successfully, once setup the network will not become inactive for a hoster.

    Once connected the app becomes a client of the network, any other clients that connect to it join the network. All
    clients are treated equally and have a list of local variables that they can read from and write to, all clients can
    also read any variables on other clients on a read only basis.

    Some ports are used by AGK for internal networking and should not be used by your application. Ports 5689-5692 are
    used to manage apps broadcast from the IDE. Ports 45631 and 45632 are used for named network connections. On IPv4
    networks the network broadcast goes to all devices on the local subnet, on IPv6 networks the broadcast goes to the
    AGK multicast address "FF02::41:474B". If the device has both IPv4 and IPv6 IP addresses then `host_network()` will
    accept connections from both IPv4 and IPv6 networks.

    If you specify 0 for `port` then it will disable IPv4 connections, if you set `portv6` to 0 then it will disable
    IPv6 connections. At least one must be greater than 0 or an error will be generated. If you do not specify `portv6`
    at all then it will be set to 0. It should be safe to use the same port for both IPv4 and IPv6, but this hasn't been
    widely tested.

    Returns an ID you can use to interact with this network.

    Does not work when exported to HTML5.

    :param str network_name: The name to use in identifying this network.
    :param str my_name: The name to use in identifying this client.
    :param int port: The port that other clients should use to connect to this network when using IPv4, 0 to disable
        IPv4 connections.
    :param Optional[int] portv6: The port that other clients should use to connect to this network when using IPv6, 0 to
        disable IPv6 connections.
    :rtype: int
    """
    pass    


def is_network_active(network_id: int) -> bool:
    """
    Checks that the network is active, in the case of joining a network this will return False if the connection failed
    or for some reason the connection to the server broke.

    For a hoster this function will return False if it failed to listen on the specified port for clients, otherwise it
    will forever return True as it will not stop managing any connected clients, even if everyone disconnects.

    :param int network_id: The ID of the network to check.
    :rtype: bool
    """
    pass    


def join_network(network_name: str, my_name: str) -> int:
    """
    Joins an AGK network hosted by another app.

    The network is specified by name, or by IP address and port number. For named networks the app will look for any AGK
    networks broadcast with that name and connect to it if found. Alternatively using an IP address and port number will
    attempt a direct connection to the host. In the case of internet connections an IP and port is the only way to
    connect as broadcasts will not leave the local area network. IP addresses can be IPv4 or IPv6 depending on what IP
    addresses the host is using (it could have one or more of each).

    You may detect all the networks available for connecting to by setting up a broadcast listener and listening for the
    broadcasts yourself, you could then display a list of discovered networks to the user to let them decide which one
    to connect to.

    Warning, if the device listening for broadcasts is an iOS device then it may not be able to receive broadcast
    packets without permission from Apple. As of writing receiving is still allowed but sending requires permission from
    Apple, this may change in future.

    This function does not connect immediately, it returns a network ID and continues to attempt to connect in the
    background. You can detect when a connection is made by checking the `get_network_num_clients()` is greater than 1,
    indicating that at least the local client and server client have been detected. If `is_network_active()` returns 0
    at any time then the connection to the server failed and the network should be closed, you may attempt to reconnect
    by opening a new network.

    Once connected the app becomes a client of the network, along with the host and any other clients that have
    connected to it. All clients are treated equally and have a list of local variables that they can read from and
    write to, all clients can also read any variables on other clients on a read only basis.

    You must identify your client with a client name that will be visible to other clients, the client name does not
    need to be unique.

    Returns a network ID to use when interacting with this network.

    Does not work when exported to HTML5.

    :param str network_name: The name of the network to connect to.
    :param str my_name: The name to use in identifying this client.
    :rtype: int
    """
    pass    


def join_network_ip(ip: str, port: int, my_name: str) -> int:
    """
    Joins an AGK network hosted by another app.

    The network is specified by name, or by IP address and port number. For named networks the app will look for any AGK
    networks broadcast with that name and connect to it if found. Alternatively using an IP address and port number will
    attempt a direct connection to the host. In the case of internet connections an IP and port is the only way to
    connect as broadcasts will not leave the local area network. IP addresses can be IPv4 or IPv6 depending on what IP
    addresses the host is using (it could have one or more of each).

    You may detect all the networks available for connecting to by setting up a broadcast listener and listening for the
    broadcasts yourself, you could then display a list of discovered networks to the user to let them decide which one
    to connect to.

    Warning, if the device listening for broadcasts is an iOS device then it may not be able to receive broadcast
    packets without permission from Apple. As of writing receiving is still allowed but sending requires permission from
    Apple, this may change in future.

    This function does not connect immediately, it returns a network ID and continues to attempt to connect in the
    background. You can detect when a connection is made by checking the `get_network_num_clients()` is greater than 1,
    indicating that at least the local client and server client have been detected. If `is_network_active()` returns 0
    at any time then the connection to the server failed and the network should be closed, you may attempt to reconnect
    by opening a new network.

    Once connected the app becomes a client of the network, along with the host and any other clients that have
    connected to it. All clients are treated equally and have a list of local variables that they can read from and
    write to, all clients can also read any variables on other clients on a read only basis.

    You must identify your client with a client name that will be visible to other clients, the client name does not
    need to be unique.

    Returns a network ID to use when interacting with this network.

    Does not work when exported to HTML5.

    :param str ip: The IP address of the host to connect to, can be IPv4 or IPv6.
    :param int port: The port to connect to.
    :param str my_name: The name to use in identifying this client.
    :rtype: int
    """
    pass    


def kick_network_client(network_id: int, client_id: int) -> None:
    """
    Kicks a client from the network.

    This does not happen immediately and the client may remain for a few frames before it is finally kicked. The client
    will disconnect in the normal way, you must check `get_network_client_disconnected()` to detect when the client has
    been kicked, and then call `delete_network_client()` to finally get rid of it.

    :param int network_id: The ID of the network.
    :param int client_id: The ID of the client to kick.
    :rtype: None
    """
    pass    


def send_network_message(network_id: int, client_id: int, message_id: int) -> None:
    """
    Sends a created network message to a given client on a given network.

    Use a client ID of 0 to send to all connected clients (except the sender), otherwise if the client ID does not exist
    an error will be generated. This function will delete the message ID given.

    :param int network_id: The ID of the network to send the message over.
    :param int client_id: The ID of the client to send the message to, 0 to send to all.
    :param int message_id: The ID of the message to send.
    :rtype: None
    """
    pass    


def send_socket_byte(socket_id: int, value: int) -> bool:
    """
    Will send a single byte in the range -128 to 127 to the remote connection.

    Note that data is not sent immediately, you must call `flush_socket()` to send it.

    Returns True if the byte was successfully written to the buffer, False if the socket disconnected.

    :param int socket_id: The ID of the socket to write.
    :param int value: The value to send.
    :rtype: bool
    """
    pass    


def send_socket_float(socket_id: int, value: Union[float, int]) -> bool:
    """
    Will send a 4 byte float to the remote connection.

    Note that data is not sent immediately, you must call `flush_socket()` to send it.

    Returns True if the float was successfully written to the buffer, False if the socket disconnected.

    :param int socket_id: The ID of the socket to write.
    :param Union[float, int] value: The value to send.
    :rtype: bool
    """
    pass    


def send_socket_integer(socket_id: int, value: int) -> bool:
    """
    Will send a 4 byte integer to the remote connection.

    Note that data is not sent immediately, you must call `flush_socket()` to send it.

    Returns True if the integer was successfully written to the buffer, False if the socket disconnected.

    :param int socket_id: The ID of the socket to write.
    :param int value: The value to send.
    :rtype: bool
    """
    pass    


def send_socket_string(socket_id: int, value: str) -> bool:
    """
    Will send a string to the remote connection.

    Note that data is not sent immediately, you must call `flush_socket()` to send it.

    If you are sending the string to a non-AGK app then the string is constructed of a 4 byte length value followed by X
    bytes of string data where X is the length value. The string is not null terminated.

    Returns True if the string was successfully written to the buffer, False if the socket disconnected.

    :param int socket_id: The ID of the socket to write.
    :param str value: The value to send.
    :rtype: bool
    """
    pass    


def send_udp_network_message(listener_id: int, message_id: int, ip: str, port: int) -> None:
    """
    Sends a network message created with `create_network_message()` to the specified remote IP and port.

    You must specify a UDP listener to use as the source IP and port. This function will delete the specified message
    ID.

    Warning, if the IP address is a broadcast or multicast address, e.g. 255.255.255.255 then this will fail to send on
    iOS devices. To send broadcast or multicast packets requires permission from Apple, use the following page to
    request it https: developer.apple.com/contact/request/networking-multicast.

    :param int listener_id: The ID of the listener to use as the source ip and port
    :param int message_id: The ID of the network message to send
    :param str ip: The IP address to send the message to
    :param int port: The port to send the message to
    :rtype: None
    """
    pass    


def set_network_allow_clients(network_id: int) -> None:
    """
    Restarts listening for new client connections, only applicable if you are hosting the network.

    Also restarts the broadcasting of the network to the LAN so it will appear to those apps listening to broadcasts.
    This only needs to be called if you have previously called `set_network_no_more_clients()` and now want to allow
    connections again.

    :param int network_id: The ID of the network to modify.
    :rtype: None
    """
    pass    


def set_network_client_user_data(network_id: int, client_id: int, slot: int, value: int) -> None:
    """
    Assigns a local value to one of 5 data slots in the client that can be used to keep track of items that belong to
    this client.

    For example if you create a sprite to represent the client in your game you could assign the sprite ID to one of
    these data slots so that when you go through the client list you can detect which sprite you used for each client.
    This also allows you to clean up the sprite if the client is found to have disconnected. This value is entirely
    local and does not get transferred across the network.

    :param int network_id: The ID of the network to store the value.
    :param int client_id: The ID of the client on the network to store the value.
    :param int slot: The index (0 to 4) of the data slot to set.
    :param int value: The integer value to set.
    :rtype: None
    """
    pass    


def set_network_latency(network_id: int, latency: int) -> None:
    """
    Sets how often the network sends updates and checks for variable updates from other clients in milliseconds.

    The lower this value the more often this client will send and receive updates meaning shared variables are more
    likely to be up to date, but this will increase network traffic. In the case of connections across the internet this
    is particularly important as a large number of variables being updated frequently means that there may not be enough
    bandwidth. The default is 15 milliseconds which translates to roughly 67 updates every second to match closely a
    game frame rate of 60 fps. If you are updating a large number of variables over an internet connection it is
    recommended you increase this value towards 50 milliseconds resulting in 20 updates per second or further.

    :param int network_id: The ID of the network to disconnect from.
    :param int latency: The latency to use in milliseconds.
    :rtype: None
    """
    pass    


def set_network_local_float(network_id: int, name: str, value: Union[float, int],
                            mode: Optional[int] = 0) -> None:
    """
    Sets a local float variable for this client by name.

    Other clients can then read this variable by using the same name when requesting its value. A float variable may not
    have the same name as an integer variable. If the variable with that name does not exist it is created.

    :param int network_id: The ID of the network to check.
    :param str name: The name of this variable.
    :param Union[float, int] value: The value to set this variable to.
    :param Optional[int] mode: The type of this variable, 0=normal, 1=resetting.
    :rtype: None
    """
    pass    


def set_network_local_integer(network_id: int, name: str, value: int,
                              mode: Optional[int] = 0) -> None:
    """
    Sets a local integer variable for this client by name.

    Other clients can then read this variable by using the same name when requesting its value. The mode parameter
    specifies how this variable should behave, with a value of 1 (NETWORK_VAR_TYPE_RESETTING) meaning that this variable
    will reset to 0 when read. For example if you wanted to send a click notification you could set a value of 1 to
    signify a click with a mode value of 1 (NETWORK_VAR_TYPE_RESETTING). When each client reads the variable, each will
    see the value 1, but if they try to read it again they will get the value 0. Each client only resets its own copy of
    the variable. A mode value of 0 (NETWORK_VAR_TYPE_NORMAL) means it is a normal variable that will not change when
    read.

    If the variable with that name does not exist it is created. Once a variable is created in normal or resetting mode
    it cannot be changed and the mode parameter is ignored.

    :param int network_id: The ID of the network to check.
    :param str name: The name of this variable.
    :param int value: The value to set this variable to.
    :param Optional[int] mode: The type of this variable, 0=normal, 1=resetting.
    :rtype: None
    """
    pass    


def set_network_no_more_clients(network_id: int) -> None:
    """
    Stops anymore clients from connecting to this network, only applicable if you are hosting the network.

    Also stops the broadcasting of the network to the LAN so it will no longer appear to those apps listening to
    broadcasts.

    :param int network_id: The ID of the network to modify.
    :rtype: None
    """
    pass    


def delete_music_ogg(music_id: int) -> None:
    """
    Deletes the music file and frees up the ID to be used again.

    :param int music_id: The ID of the music file to delete.
    :rtype: None
    """
    pass    


def get_music_duration_ogg(music_id: int) -> float:
    """
    Returns the duration of the music file in seconds as a floating point value.

    :param int music_id: The ID of the music file to check.
    :rtype: float
    """
    pass    


def get_music_exists_ogg(music_id: int) -> bool:
    """
    Returns True if a music file exists at the specified ID, False otherwise.

    :param int music_id: The ID to check.
    :rtype: bool
    """
    pass    


def get_music_loop_count_ogg(music_id: int) -> int:
    """
    Returns the number of times this music file has looped.

    :param int music_id: The ID of the music file to check.
    :rtype: int
    """
    pass    


def get_music_playing_ogg(music_id: int) -> bool:
    """
    Returns True if the music file is currently playing, False otherwise.

    This will continue to return True whilst the file is paused.

    :param int music_id: The ID of the music file to check.
    :rtype: bool
    """
    pass    


def get_music_position_ogg(music_id: int) -> float:
    """
    Returns the current position in the music file, between 0 for the beginning of the file and
    `get_music_duration_ogg()` for the end of the file.

    :param int music_id: The ID of the music file to check.
    :rtype: float
    """
    pass    


def load_music_ogg(filename: str) -> int:
    """
    Loads a music file compressed with OGG Vorbis.

    Multiple OGG music files can be played at the same time. OGG music file IDs are separate from normal music file IDs
    and are not limited to a specific range of numbers.

    :param str filename: The filename of the music file to load.
    :rtype: int
    """
    pass    


def load_music_ogg_id(music_id: int, filename: str) -> None:
    """
    Loads a music file compressed with OGG Vorbis.

    Multiple OGG music files can be played at the same time. OGG music file IDs are separate from normal music file IDs
    and are not limited to a specific range of numbers.

    :param int music_id: The ID to use to refer to this music file.
    :param str filename: The filename of the music file to load.
    :rtype: None
    """
    pass    


def pause_music_ogg(music_id: int) -> None:
    """
    Pauses the music file.

    `get_music_playing_ogg()` will continue to return True.

    :param int music_id: The ID of the music file to pause.
    :rtype: None
    """
    pass    


def play_music_ogg(music_id: int, loop: int = 1) -> None:
    """
    Plays the music file.

    Multiple OGG music files can be playing at the same time.

    :param int music_id: The ID of the music file to play.
    :param int loop: The number of times to loop, or 1 to loop forever. (optional, default 1)
    :rtype: None
    """
    pass    


def resume_music_ogg(music_id: int) -> None:
    """
    Resumes the music file if it was paused.

    :param int music_id: The ID of the music file to pause.
    :rtype: None
    """
    pass    


def seek_music_ogg(music_id: int, seconds: Union[float, int], mode: int) -> None:
    """
    Seeks to a given time value, if the file is currently playing then it will immediately continue playing from there.

    If the file is not currently playing then it will take effect after the next call to `play_music_ogg()`. The mode
    parameter lets you choose whether to seek based on an absolute or relative time value. Absolute will seek to that
    position in the file, whilst relative will seek relative to the current position.

    :param int music_id: The ID of the music file to seek.
    :param Union[float, int] seconds: The time in seconds to seek to.
    :param int mode: 0 (SEEK_ABSOLUTE) for absolute seeking, 1 (SEEK_RELATIVE) for relative seeking.
    :rtype: None
    """
    pass    


def set_music_loop_count_ogg(music_id: int, loop: int) -> None:
    """
    Changes the number of times the music file will loop, can be set whilst it is playing.

    Use a value of 0 to play to the end of the file, or the current loop end time, and then stop. A loop value of 1 will
    loop forever, a value greater than 1 will loop for that number of times. This command resets the
    `get_music_loop_count_ogg()` command and it starts counting again from 0.

    :param int music_id: The ID of the music file to change.
    :param int loop: The number of times to loop, 0 to stop looping.
    :rtype: None
    """
    pass    


def set_music_loop_times_ogg(music_id: int, start_time: Union[float, int], end_time: Union[float,
                             int]) -> None:
    """
    Sets the start and end times of the music loop.

    When `play_music_ogg()` is used with the loop parameter it will by default stop at the end of the file and return to
    the beginning of the file. This command will change it to the looping begins and ends at specific times in the music
    file. Using a start time of -1 will return to the beginning of the file, using and end time of -1 will stop at the
    end of the file, these match the default behaviour. If the start time is greater than the current play time then the
    music file will continue playing until it reaches the end time, it will then return to the chosen start time.

    :param int music_id: The ID of the music file to change.
    :param Union[float, int] start_time: The time in seconds to return to at the beginning of a loop.
    :param Union[float, int] end_time: The time in seconds to end the loop and return to the start.
    :rtype: None
    """
    pass    


def set_music_system_volume_ogg(volume: int) -> None:
    """
    Sets the master volume for all OGG music files.

    This is multiplied by the file volume, so if the system volume is set to 100 but the file volume is set to 0 then
    the file will still be at volume 0.

    :param int volume: The master volume to use, between 0 and 100.
    :rtype: None
    """
    pass    


def set_music_volume_ogg(music_id: int, volume: int) -> None:
    """
    Sets the volume on a per file basis.

    By default files are played at volume 100. The volume level should be between 0 and 100.

    :param int music_id: The ID of the music file to modify.
    :param int volume: The volume to use for this file.
    :rtype: None
    """
    pass    


def stop_music_ogg(music_id: int) -> None:
    """
    Stops the music file and resets its position to the beginning of the file.

    :param int music_id: The ID of the music file to stop.
    :rtype: None
    """
    pass    


def add_particles_color_key_frame(emitter_id: int, time: Union[float, int], red: int, green: int,
                                  blue: int, alpha: int) -> None:
    """
    Adds a color change at a certain point in a particle's life.

    For example a color added with time=1 will make the particle equal the given color when it has been alive for 1
    second. If color interpolation is turned on using `set_particles_color_interpolation()` the particle will gradually
    transform from its current color to the next color. For example if you add three colors, red when time=1, green when
    time=2, and blue when time=3, then the particle will start its life as red (as that is the nearest color) and remain
    completely red until it is 1 second old. When the particle is between 1 and 2 seconds old it will gradually change
    from red to green until it is 2 seconds old, at this point it is completely green. When the particle is between 2
    and 3 seconds old it will gradually change from green to blue until it is 3 seconds old, at this point it is
    completely blue. The particle will remain completely blue until the end of its life as no other colors have been
    added.

    :param int emitter_id: The ID of the emitter to modify.
    :param Union[float, int] time: The time that particles should become this color.
    :param int red: The red component of the new color.
    :param int green: The green component of the new color.
    :param int blue: The blue component of the new color.
    :param int alpha: The alpha component of the new color.
    :rtype: None
    """
    pass    


def add_particles_force(emitter_id: int, start_time: Union[float, int], end_time: Union[float, int],
                        x: Union[float, int], y: Union[float, int]) -> None:
    """
    Adds a force that will act at a given time in every particle's life.

    For example a force set to start at time 2 and end at time 3 will start influencing particles when they have been
    alive for 2 seconds. It will continue to act on those particles until they have been alive for 3 seconds. The
    force's influence is defined by an x and y value that represent acceleration in units per second. For example a
    force with x=5 will adjust a particle's horizontal speed by adding 5 units for every second the force is active, if
    the force is only active for 0.5 seconds the particle would then be moving 2.5 units per second faster towards the
    right. Multiple forces can be acting on a particle at the same time if their timings overlap.

    :param int emitter_id: The ID of the emitter to modify.
    :param Union[float, int] start_time: The time in a particle's life at which this force should start having an
        effect.
    :param Union[float, int] end_time: The time in a particle's life at which this force should stop having an effect.
    :param Union[float, int] x: The x component of the force's influence on a particle's speed in units per second.
    :param Union[float, int] y: The y component of the force's influence on a particle's speed in units per second.
    :rtype: None
    """
    pass    


def add_particles_scale_key_frame(emitter_id: int, time: Union[float, int], scale: Union[float,
                                  int]) -> None:
    """
    Adds a size change at a certain point in a particle's life.

    Scale values are relative to the value set by `set_particles_size()` so a scale of 2 means double its normal size
    and 0.5 is half its normal size. A scale added with time=1 will make the particle equal the given size when it has
    been alive for 1 second. The particle will gradually transform from its current size to the next size.

    :param int emitter_id: The ID of the emitter to modify.
    :param Union[float, int] time: The time that particles should become this size.
    :param Union[float, int] scale: The scale relative to the normal particle size, must be greater then or equal to 0.
    :rtype: None
    """
    pass    


def clear_particles_colors(emitter_id: int) -> None:
    """
    Clears all colors that have been assigned to the emitter, the particles will maintain whatever color they currently
    have.

    :param int emitter_id: The ID of the emitter to modify.
    :rtype: None
    """
    pass    


def clear_particles_forces(emitter_id: int) -> None:
    """
    Clears all forces assigned to this emitter.

    All forces will immediately stop influencing particles.

    :param int emitter_id: The ID of the emitter to modify.
    :rtype: None
    """
    pass    


def clear_particles_scales(emitter_id: int) -> None:
    """
    Clears all size modifiers that have been assigned to the emitter, the particles will maintain whatever size they
    currently are.

    :param int emitter_id: The ID of the emitter to modify.
    :rtype: None
    """
    pass    


def create_particles(x: Union[float, int], y: Union[float, int]) -> int:
    """
    Creates a particle emitter in a free ID and at the given location in world coordinates.

    It returns the ID used to create the emitter.

    Particle emitters create a flow of small sprites that last for a fixed amount of time before disappearing. The
    particles can be influenced by forces during their life using `add_particles_force()`. They can also change color
    over time using `add_particles_color_key_frame()`.

    Particles cannot be modified individually and behave as a group using the same texture and depth. This allows the
    AGK to draw them more efficiently than a similar number of normal sprites.

    :param Union[float, int] x: The x coordinate to position this emitter.
    :param Union[float, int] y: The y coordinate to position this emitter.
    :rtype: int
    """
    pass    


def create_particles_id(emitter_id: int, x: Union[float, int], y: Union[float, int]) -> None:
    """
    Creates a particle emitter in a free ID and at the given location in world coordinates.

    It returns the ID used to create the emitter.

    Particle emitters create a flow of small sprites that last for a fixed amount of time before disappearing. The
    particles can be influenced by forces during their life using `add_particles_force()`. They can also change color
    over time using `add_particles_color_key_frame()`.

    Particles cannot be modified individually and behave as a group using the same texture and depth. This allows the
    AGK to draw them more efficiently than a similar number of normal sprites.

    :param int emitter_id: The ID to use when referencing this particle emitter.
    :param Union[float, int] x: The x coordinate to position this emitter.
    :param Union[float, int] y: The y coordinate to position this emitter.
    :rtype: None
    """
    pass    


def delete_particles(emitter_id: int) -> None:
    """
    Deletes a particle emitter and all its particles.

    If any particles were currently visible they will disappear instantly.

    :param int emitter_id: The ID of the emitter to delete.
    :rtype: None
    """
    pass    


def draw_particles(emitter_id: int) -> None:
    """
    Immediately draws the particle emitter to the backbuffer at its current position, size, and rotation.

    This is useful if you want to setup a scene for `get_image()` to capture. Remember to use `clear_screen()` to clear
    any of your own drawing before calling `sync()` or `render()` for the actual frame otherwise your drawing may appear
    twice in the final render.

    :param int emitter_id: The ID of the emitter to draw.
    :rtype: None
    """
    pass    


def fix_particles_to_screen(emitter_id: int, fixed: Union[bool, int]) -> None:
    """
    Fixing particles to the screen will ensure they are not affected by scrolling of the viewport.

    :param int emitter_id: The ID of the emitter to modify.
    :param Union[bool, int] fixed: Use True to fix to the screen. Use False to allow the particles to be affected by
        scrolling.
    :rtype: None
    """
    pass    


def get_particles_active(emitter_id: int) -> bool:
    """
    Returns False if the given particles have been paused using `set_particles_active()`, or True if they are currently
    updating as normal (default).

    :param int emitter_id: The ID of the emitter to check.
    :rtype: bool
    """
    pass    


def get_particles_angle(emitter_id: int) -> float:
    """
    Returns the current emitter angle in degrees.

    This value represents the amount of deviation a particle can have from the emitter direction when emitted. An angle
    of 0 means there is no deviation while an angle of 360 means a particle can be travelling in any direction when
    emitted.

    :param int emitter_id: The ID of the emitter to check.
    :rtype: float
    """
    pass    


def get_particles_angle_rad(emitter_id: int) -> float:
    """
    Returns the current emitter angle in radians.

    This value represents the amount of deviation a particle can have from the emitter direction when emitted. An angle
    of 0 means there is no deviation while an angle of 2*PI means a particle can be travelling in any direction when
    emitted.

    :param int emitter_id: The ID of the emitter to check.
    :rtype: float
    """
    pass    


def get_particles_depth(emitter_id: int) -> int:
    """
    Returns the current depth that all particles will be drawn at.

    This value is in the range 0 to 10000 with 0 being the front of the screen.

    :param int emitter_id: The ID of the emitter to check.
    :rtype: int
    """
    pass    


def get_particles_direction_x(emitter_id: int) -> float:
    """
    Returns the X component of the emitter direction, which is the base direction that particles will be moving when
    they are created.

    Particles can vary their direction slightly when emitted based on the current `get_particles_angle()` value.

    :param int emitter_id: The ID of the emitter to check.
    :rtype: float
    """
    pass    


def get_particles_direction_y(emitter_id: int) -> float:
    """
    Returns the y component of the emitter direction, which is the base direction that particles will be moving when
    they are created.

    Particles can vary their direction slightly when emitted based on the current `set_particles_angle()` value.

    :param int emitter_id: The ID of the emitter to check.
    :rtype: float
    """
    pass    


def get_particles_exists(emitter_id: int) -> bool:
    """
    Returns True if a particle emitter exists at the given ID, False if not.

    :param int emitter_id: The ID of the emitter to check.
    :rtype: bool
    """
    pass    


def get_particles_frequency(emitter_id: int) -> float:
    """
    Returns the current frequency of particle generation in particles per second.

    This value is independent of frame rate.

    :param int emitter_id: The ID of the emitter to check.
    :rtype: float
    """
    pass    


def get_particles_life(emitter_id: int) -> float:
    """
    Returns the current life of particles in seconds.

    It is not possible to get the current life of individual particles. This value is independent of frame rate.

    :param int emitter_id: The ID of the emitter to check.
    :rtype: float
    """
    pass    


def get_particles_max_reached(emitter_id: int) -> bool:
    """
    Returns True if the emitter has emitted the number of particles specified in `set_particles_max()` and all emitted
    particles have since died, otherwise returns False.

    If the max is set at -1 this will always return False. To reset the count and make the emitter start emitting again
    use `reset_particle_count()`.

    :param int emitter_id: The ID of the emitter to check.
    :rtype: bool
    """
    pass    


def get_particles_size(emitter_id: int) -> float:
    """
    Returns the current size of all particles in world coordinates.

    For details on setting the particle size see `set_particles_size()`.

    :param int emitter_id: The ID of the emitter to check.
    :rtype: float
    """
    pass    


def get_particles_visible(emitter_id: int) -> bool:
    """
    Returns False if the given particles have been set as invisible using `set_particles_visible()`, or True if they are
    currently set as visible (default).

    This does not check if the particles are within the visible viewport.

    :param int emitter_id: The ID of the emitter to check.
    :rtype: bool
    """
    pass    


def get_particles_x(emitter_id: int) -> float:
    """
    Returns the current X position of the emitter, this is the point that new particles will appear from.

    It is not possible to get the position of individual particles, they are merely created, follow a path influenced by
    forces, and then disappear.

    :param int emitter_id: The ID of the emitter to check.
    :rtype: float
    """
    pass    


def get_particles_y(emitter_id: int) -> float:
    """
    Returns the current Y position of the emitter, this is the point that new particles will appear from.

    It is not possible to get the position of individual particles, they are merely created, follow a path influenced by
    forces, and then disappear.

    :param int emitter_id: The ID of the emitter to check.
    :rtype: float
    """
    pass    


def offset_particles(emitter_id: int, x: Union[float, int], y: Union[float, int]) -> None:
    """
    Immediately moves all existing particles by the given offset.

    For example an offset of x=3,y=5 would move all particles to the right by 3 units and down 5 units. This does not
    affect the particle emitter but can be used in conjunction with `set_particles_position()` to move both the emitter
    and the particles that already exist.

    :param int emitter_id: The ID of the emitter to modify.
    :param Union[float, int] x: The distance to move the particles in the X direction.
    :param Union[float, int] y: The distance to move the particles in the Y direction.
    :rtype: None
    """
    pass    


def reset_particle_count(emitter_id: int) -> None:
    """
    Resets the emitted particle count when the emitter has been set with a maximum number of particles using
    `set_particles_max()`.

    You can check when the emitter has reached its maximum count using `get_particles_max_reached()`. If the maximum is
    set at -1 then this command has no effect.

    :param int emitter_id: The ID of the emitter to modify.
    :rtype: None
    """
    pass    


def set_particles_active(emitter_id: int, active: Union[bool, int]) -> None:
    """
    Sets whether the emitted particles are updated every frame.

    Set to True to update particles as normal, False to pause them. Particles will continue to be visible when paused.
    To hide particles use `set_particles_visible()`.

    :param int emitter_id: The ID of the emitter to modify.
    :param Union[bool, int] active: True to update normally, False to pause.
    :rtype: None
    """
    pass    


def set_particles_angle(emitter_id: int, angle: Union[float, int]) -> None:
    """
    Sets the range of direction in degrees that a particle can choose when it first starts.

    This takes the base direction set with `set_particles_direction()` and adjusts it by a random amount between 0 and
    angle/2 degrees. For example an angle of 0 would mean that all new particles follow exactly the direction specified
    earlier. An angle of 360 would mean that particles could appear travelling in any direction, and an angle of 90
    would mean that particles would travel outward in a cone of 90 degrees from their start position with the cone
    centered on the given direction.

    :param int emitter_id: The ID of the emitter to modify.
    :param Union[float, int] angle: The range of variation a particle can choose from the emitter direction.
    :rtype: None
    """
    pass    


def set_particles_angle_rad(emitter_id: int, angle: Union[float, int]) -> None:
    """
    Sets the range of direction in radians that a particle can choose when it first starts.

    This takes the base direction set with `set_particles_direction()` and adjusts it by a random amount between 0 and
    angle/2 radians. For example an angle of 0 would mean that all new particles follow exactly the direction specified
    earlier. An angle of 2*PI would mean that particles could appear travelling in any direction, and an angle of PI/2
    would mean that particles would travel outward in a cone of PI/2 radians from their start position with the cone
    centered on the given direction.

    :param int emitter_id: The ID of the emitter to modify.
    :param Union[float, int] angle: The range of variation a particle can choose from the emitter direction.
    :rtype: None
    """
    pass    


def set_particles_color_interpolation(emitter_id: int, mode: int) -> None:
    """
    Sets the interpolation mode for color changes.

    Colors can be set at certain points in a particle's life using `add_particles_color_key_frame()` and the particle
    will either blend between these colors or quickly change when it reaches the next color change.

    :param int emitter_id: The ID of the emitter to modify.
    :param int mode: 1 (INTERPOLATE_SMOOTH)=smooth interpolation, 0 (INTERPOLATE_NONE)=no interpolation.
    :rtype: None
    """
    pass    


def set_particles_depth(emitter_id: int, depth: int) -> None:
    """
    Sets the depth of the particle emitter.

    This affects all particles, even those that are already visible. All particles are drawn at the same depth as the
    emitter so that the AGK can group them into a single draw call for faster drawing. The depth should be between 0 and
    10000, with 0 being the front of the screen.

    :param int emitter_id: The ID of the emitter to modify.
    :param int depth: The new depth value of the particles.
    :rtype: None
    """
    pass    


def set_particles_direction(emitter_id: int, x: Union[float, int], y: Union[float, int]) -> None:
    """
    Sets the initial direction of new particles when they emerge from the emitter.

    This can be used along with the `set_particles_angle()` command to set the range of variation from this initial
    direction that new particles can choose. This also sets the initial speed of the particles by taking the length of
    the vector as units per second. For example if the initial direction is `x`=10, `y`=-15, particles will begin by
    moving to the right at a rate of 10 units per second and upwards at a rate of 15 units per second and will continue
    this rate of motion for their entire life unless influenced by forces added with `add_particles_force()`.

    :param int emitter_id: The ID of the emitter to modify.
    :param Union[float, int] x: The x direction that particles will move initially.
    :param Union[float, int] y: The y direction that particles will move initially.
    :rtype: None
    """
    pass    


def set_particles_face_direction(emitter_id: int, mode: int) -> None:
    """
    Sets particles to rotate to the direction they are moving.

    This overrides any use of `set_particles_rotation_range()` to modify the rate at which particles rotate. Instead
    particles will always rotate to face their direction of travel.

    :param int emitter_id: The ID of the emitter to modify.
    :param int mode: 1 (ROTATE_MOVE_DIRECTION) to make particles rotate to the direction they are moving, 0
        (ROTATE_NORMAL) to use normal rotation.
    :rtype: None
    """
    pass    


def set_particles_frequency(emitter_id: int, frequency: Union[float, int]) -> None:
    """
    Sets the frequency of new particle generation.

    The freq value states how many particles should be produced per second, this is independent of frame rate. This is
    one of the two values that affects the number of particles generated, the other being `set_particles_life()`. The
    maximum number of particles that can be on screen at any one time is freq*life, with life being the number of
    seconds a particle lives before it disappears. This value is independent of frame rate.

    :param int emitter_id: The ID of the emitter to modify.
    :param Union[float, int] frequency: The rate of new particle production in particles per second.
    :rtype: None
    """
    pass    


def set_particles_image(emitter_id: int, image_id: int) -> None:
    """
    Sets the image to use for each particle.

    Since 1083 images can be loaded from sub images contained on atlas textures.

    :param int emitter_id: The ID of the emitter to modify.
    :param int image_id: The ID of an image to use for emitted particles.
    :rtype: None
    """
    pass    


def set_particles_life(emitter_id: int, time: Union[float, int]) -> None:
    """
    Sets the life of particles once they have been emitted in seconds.

    After particles have been alive for the given number of seconds they will disappear. This is one of the two values
    that affects the number of particles generated, the other being `set_particles_frequency()`. The maximum number of
    particles that can be on screen at any one time is freq*life, with freq being the number of particles emitted per
    second. This value is independent of frame rate.

    :param int emitter_id: The ID of the emitter to modify.
    :param Union[float, int] time: The time in seconds that a particle is visible.
    :rtype: None
    """
    pass    


def set_particles_max(emitter_id: int, maximum: int) -> None:
    """
    Sets the maximum number of particles that will be emitted.

    If this value is equal to -1 then the number is infinite. The emitter will keep a count of the number of particles
    it emits and stop when the limit is reached. To check if the emitter has reached its limit use
    `get_particles_max_reached()`. To reset the count and make it start emitting again use `reset_particle_count()`.

    :param int emitter_id: The ID of the emitter to modify.
    :param int maximum: The maximum number of particles to emit.
    :rtype: None
    """
    pass    


def set_particles_position(emitter_id: int, x: Union[float, int], y: Union[float, int]) -> None:
    """
    Sets the position of the particle emitter.

    This is the position that new particles will emerge from and does not affect particles that are already visible.

    :param int emitter_id: The ID of the emitter to modify.
    :param Union[float, int] x: The new x coordinate for the emitter in world coordinates.
    :param Union[float, int] y: The new y coordinate for the emitter in world coordinates.
    :rtype: None
    """
    pass    


def set_particles_rotation_range(emitter_id: int, minimum: Union[float, int], maximum: Union[float,
                                 int]) -> None:
    """
    Sets the range of rotation in radians that a particle can have during its life.

    When a particle is created it starts at angle 0 and chooses and random rotation rate between `minimum` and
    `maximum`. The particle will then rotate at that chosen rate for its entire life. Use negative values for counter-
    clockwise rotation and positive for clockwise rotation.

    :param int emitter_id: The ID of the emitter to modify.
    :param Union[float, int] minimum: The minimum angle of the range in degrees per second.
    :param Union[float, int] maximum: The maximum angle of the range in degrees per second.
    :rtype: None
    """
    pass    


def set_particles_rotation_range_rad(emitter_id: int, minimum: Union[float, int],
                                     maximum: Union[float, int]) -> None:
    """
    Sets the range of rotation in radians that a particle can have during its life.

    When a particle is created it starts at angle 0 and chooses and random rotation rate between `minimum` and
    `maximum`. The particle will then rotate at that chosen rate for its entire life. Use negative values for counter-
    clockwise rotation and positive for clockwise rotation.

    :param int emitter_id: The ID of the emitter to modify.
    :param Union[float, int] minimum: The minimum angle of the range in radians per second.
    :param Union[float, int] maximum: The maximum angle of the range in radians per second.
    :rtype: None
    """
    pass    


def set_particles_size(emitter_id: int, size: Union[float, int]) -> None:
    """
    Sets the size of all particles in world coordinates.

    Setting a large number of particles to a large size will perform poorly on mobile devices that have a low fill rate
    (number of pixels it can draw per second).

    :param int emitter_id: The ID of the emitter to modify.
    :param Union[float, int] size: Size of the particles.
    :rtype: None
    """
    pass    


def set_particles_start_zone(emitter_id: int, x1: Union[float, int], y1: Union[float, int],
                             x2: Union[float, int], y2: Union[float, int]) -> None:
    """
    Sets the area around the emitter where new particles may appear.

    The values are relative to the emitter position, for example a zone of 0,0,0,0 would mean that all particles start
    on the emitter position point. A zone of -10 in x and +10 x, with y being 0 (-10,0,10,0) would create a line
    centered on the emitter position that particles would randomly appear along. A box zone where both x and y are non-
    zero sizes would mean that particles could start at any point inside the box.

    :param int emitter_id: The ID of the emitter to modify.
    :param Union[float, int] x1: The x coordinate of the top left corner of the start zone.
    :param Union[float, int] y1: The y coordinate of the top left corner of the start zone.
    :param Union[float, int] x2: The x coordinate of the bottom right corner of the start zone.
    :param Union[float, int] y2: The y coordinate of the bottom right corner of the start zone.
    :rtype: None
    """
    pass    


def set_particles_transparency(emitter_id: int, mode: int) -> None:
    """
    Set the particle transparency to a particular setting, with a choice of no transparency, alpha transparency, and
    additive blending.

    By default particles are created with alpha transparency.

    :param int emitter_id: The ID of the particle emitter to modify.
    :param int mode: The transparency mode for these particles, 0 (TRANSPARENCY_NONE)=off, 1 (TRANSPARENCY_ALPHA)=alpha
        transparency, 2 (TRANSPARENCY_ADDITIVE)=additive blending.
    :rtype: None
    """
    pass    


def set_particles_velocity_range(emitter_id: int, minimum: Union[float, int], maximum: Union[float,
                                 int]) -> None:
    """
    Sets a minimum and maximum multiplier that will affect particles being emitted.

    This can be used to ensure that there will be some variation when particles are emitted.

    :param int emitter_id: The ID of the emitter to modify.
    :param Union[float, int] minimum: The minimum velocity multiplier.
    :param Union[float, int] maximum: The maximum velocity multiplier.
    :rtype: None
    """
    pass    


def set_particles_visible(emitter_id: int, visible: Union[bool, int]) -> None:
    """
    Sets whether the emitted particles are drawn.

    Set to True to show particles, False to hide them. Particles will still update whilst hidden, you can stop particles
    updating with `set_particles_active()`.

    :param int emitter_id: The ID of the emitter to modify.
    :param Union[bool, int] visible: True to show, False to hide.
    :rtype: None
    """
    pass    


def update_particles(emitter_id: int, time: Union[float, int]) -> None:
    """
    Immediately advances the particle emitter by the given amount of time.

    If you want to advance a high frequency emitter by a large time period such as 1 second you should call this command
    multiple times with a small time value such as 0.02 so that it creates new particles in batches and spreads them out
    evenly. Calling it once with a large time value of 1 second would create a huge batch of particles all at once and
    move them together as a blob instead of spreading them out.

    :param int emitter_id: The ID of the emitter to check.
    :param Union[float, int] time: The time in seconds to advance the emitter.
    :rtype: None
    """
    pass    


def create_skeleton_2d() -> int:
    """
    Creates a 2D skeleton the can be used to animate sprites using bones.

    Currently this command is not very useful as there aren't many commands for setting up a skeleton. Instead skeletons
    should be loaded with `load_skeleton_2d_from_spine_file()`.

    :rtype: int
    """
    pass    


def create_skeleton_2d_id(skeleton_id: int) -> None:
    """
    Creates a 2D skeleton the can be used to animate sprites using bones.

    Currently this command is not very useful as there aren't many commands for setting up a skeleton. Instead skeletons
    should be loaded with `load_skeleton_2d_from_spine_file()`.

    :param int skeleton_id: ID to use to reference this skeleton.
    :rtype: None
    """
    pass    


def delete_skeleton_2d(skeleton_id: int) -> None:
    """
    Deletes the skeleton at the specified ID.

    If no skeleton exists at this ID then nothing happens.

    :param int skeleton_id: The ID of the skeleton to delete.
    :rtype: None
    """
    pass    


def fix_skeleton_2d_to_screen(skeleton_id: int, fixed: Union[bool, int]) -> None:
    """
    Fixes the specified skeleton to the screen so that it is not affected by `set_view_offset()`.

    :param int skeleton_id: ID of the skeleton to modify.
    :param Union[bool, int] fixed: True to fix to screen, False to behave normally (default).
    :rtype: None
    """
    pass    


def fix_sprite_to_skeleton_2d(sprite_id: int, skeleton_id: int, bone: int, zorder: int) -> None:
    """
    Attaches the specified sprite to the given skeleton and bone ID.

    The bone ID can be found by using the `get_skeleton_2d_bone()` command. When a sprite is attached to a skeleton bone
    then it's position and rotation become relative to the bone's position. For example if the sprite position was 0,0
    then it would be drawn in the same position as the bone, but if the position was 0,10 then the sprite would be drawn
    above the bone, relative to the bone. i.e. if the bone is rotated left by 90 degrees then 'above' the bone would be
    to the left of the screen in world coordinates.

    The ZOrder can be specified to draw the sprite in between two of the skeleton's existing sprites, any integer value
    is valid and corresponds to the current order of the sprites in the skeleton. For example a ZOrder of 0 would always
    draw before the first sprite in the skeleton's ZOrder, a value of 1 would always draw before the second sprite in
    the skeleton, and so on. Note that this isn't affected by other sprites you have attached to the skeleton, it only
    counts sprites that were originally loaded with the skeleton. For example if you fixed two new sprites to the
    skeleton both with a zorder equal to 1, then they would both be drawn between between the first and second sprites
    in the original skeleton. Any sprites that are attached to the skeleton using the same zorder value will be drawn in
    the order they were attached.

    Whilst this sprite is attached to a skeleton it will be removed from the normal drawing routines and only drawn when
    the skeleton is visible. You can still force the sprite to draw by calling `draw_sprite()` but it will not be
    ordered with the other sprites in the skeleton.

    To detach a sprite from a skeleton call this command with 0 as the skeletonID, the bone ID and zorder parameters do
    not matter in this case.

    :param int sprite_id: The ID of the sprite to attach
    :param int skeleton_id: ID of the skeleton to attach to
    :param int bone: The ID of the bone in the skeleton to attach to
    :param int zorder: The ZOrder to place the new sprite in the skeleton draw order
    :rtype: None
    """
    pass    


def get_skeleton_2d_angle(skeleton_id: int) -> float:
    """
    Gets the angle of the root of the skeleton, does not change whilst animating.

    :param int skeleton_id: ID of the skeleton to check.
    :rtype: float
    """
    pass    


def get_skeleton_2d_animation_time(skeleton_id: int, name: str) -> float:
    """
    get the total time of a named animation.

    :param int skeleton_id: ID of the skeleton to check.
    :param str name: Name of the animation to check.
    :rtype: float
    """
    pass    


def get_skeleton_2d_bone(skeleton_id: int, name: str) -> int:
    """
    Returns the ID of the specified bone for this skeleton.

    If no bone with the given name exists it will return -1. Index 0 is a valid bone.

    :param int skeleton_id: ID of the skeleton to check.
    :param str name: Name of the bone to find.
    :rtype: int
    """
    pass    


def get_skeleton_2d_bone_angle(skeleton_id: int, bone: int) -> float:
    """
    Returns the original angle of the specified bone also known as the setup pose.

    This value will not change whilst the bone is animating, instead the animation builds on top of the setup pose to
    create the bone rotation seen on screen. If the bone does not exist it will return 0. Bone IDs start at 0.

    :param int skeleton_id: ID of the skeleton to check.
    :param int bone: ID of the bone to check.
    :rtype: float
    """
    pass    


def get_skeleton_2d_bone_curr_angle(skeleton_id: int, bone: int) -> float:
    """
    Returns the current angle of the specified bone in its currently animated position.

    This value will change whilst the bone is animating. If the bone does not exist it will return 0. Bone IDs start at
    0.

    :param int skeleton_id: ID of the skeleton to check.
    :param int bone: ID of the bone to check.
    :rtype: float
    """
    pass    


def get_skeleton_2d_bone_curr_x(skeleton_id: int, bone: int) -> float:
    """
    Returns the current X position of the specified bone in its currently animated position.

    This value will change whilst the bone is animating. If the bone does not exist it will return 0. Bone IDs start at
    0.

    :param int skeleton_id: ID of the skeleton to check.
    :param int bone: ID of the bone to check.
    :rtype: float
    """
    pass    


def get_skeleton_2d_bone_curr_y(skeleton_id: int, bone: int) -> float:
    """
    Returns the current Y position of the specified bone in its currently animated position.

    This value will change whilst the bone is animating. If the bone does not exist it will return 0. Bone IDs start at
    0.

    :param int skeleton_id: ID of the skeleton to check.
    :param int bone: ID of the bone to check.
    :rtype: float
    """
    pass    


def get_skeleton_2d_bone_parent(skeleton_id: int, bone: int) -> int:
    """
    Returns the ID of the parent of the specified bone.

    If the bone does not exist or it does not / have a parent it will return -1. Indices start at 0.

    :param int skeleton_id: ID of the skeleton to check.
    :param int bone: ID of the bone to check.
    :rtype: int
    """
    pass    


def get_skeleton_2d_bone_x(skeleton_id: int, bone: int) -> float:
    """
    Returns the original X position of the specified bone also known as the setup pose.

    This value will not change whilst the bone is animating, instead the animation builds on top of the setup pose to
    create the bone position seen on screen. If the bone does not exist it will return 0. Bone IDs start at 0.

    :param int skeleton_id: ID of the skeleton to check.
    :param int bone: ID of the bone to check.
    :rtype: float
    """
    pass    


def get_skeleton_2d_bone_y(skeleton_id: int, bone: int) -> float:
    """
    Returns the original Y position of the specified bone also known as the setup pose.

    This value will not change whilst the bone is animating, instead the animation builds on top of the setup pose to
    create the bone position seen on screen. If the bone does not exist it will return 0. Bone IDs start at 0.

    :param int skeleton_id: ID of the skeleton to check.
    :param int bone: ID of the bone to check.
    :rtype: float
    """
    pass    


def get_skeleton_2d_current_time(skeleton_id: int) -> float:
    """
    Get the current time of the currently playing animation in seconds.

    :param int skeleton_id: ID of the skeleton to check.
    :rtype: float
    """
    pass    


def get_skeleton_2d_depth(skeleton_id: int) -> int:
    """
    Gets the current depth of the skeleton.

    This is in the range 0-10000. 0 is on top, 10000 is at the back

    :param int skeleton_id: ID of the skeleton to check
    :rtype: int
    """
    pass    


def get_skeleton_2d_exists(skeleton_id: int) -> bool:
    """
    Returns True if a skeleton exists at the specified ID, otherwise False.

    :param int skeleton_id: The ID of the skeleton to check.
    :rtype: bool
    """
    pass    


def get_skeleton_2d_is_animating(skeleton_id: int) -> bool:
    """
    returns True if the skeleton is animating, or tweening to the first frame of a playing animation.

    :param int skeleton_id: ID of the skeleton to check.
    :rtype: bool
    """
    pass    


def get_skeleton_2d_is_tweening(skeleton_id: int) -> bool:
    """
    returns True if the skeleton is tweening to an animation frame.

    :param int skeleton_id: ID of the skeleton to check.
    :rtype: bool
    """
    pass    


def get_skeleton_2d_x(skeleton_id: int) -> float:
    """
    Gets the X position of the root of the skeleton, does not change whilst animating.

    :param int skeleton_id: ID of the skeleton to check.
    :rtype: float
    """
    pass    


def get_skeleton_2d_y(skeleton_id: int) -> float:
    """
    Gets the Y position of the root of the skeleton, does not change whilst animating.

    :param int skeleton_id: ID of the skeleton to check.
    :rtype: float
    """
    pass    


def load_skeleton_2d_from_spine_file(filename: str, scale: Union[float, int], atlas_id: int,
                                     load_animation: Union[bool, int]) -> int:
    """
    Loads a Spine animation exported in the JSON format.

    Please see the guide section for details on what is supported. Returns an ID to use to reference this skeleton. You
    must first load the atlas image exported by Spine into an AGK image with the normal `load_image()` command and pass
    it into this function. You can choose to load animations as well, or just the sprites and bones and move or modify
    them manually. You can use the scale value to change the size of the sprites and bones to match your chosen
    resolution. A value of 1 will not change the sizes, a value of 2 will make everything twice as big, a value of 0.5
    will half the size, and so on.

    :param str filename: Name of the file to load, should be the .json export from Spine.
    :param Union[float, int] scale: The amount to scale the object sizes.
    :param int atlas_id: ID of the atlas image containing all the images.
    :param Union[bool, int] load_animation: True to load animation, False to only load sprites and bones.
    :rtype: int
    """
    pass    


def load_skeleton_2d_id_from_spine_file(skeleton_id: int, filename: str, scale: Union[float, int],
                                        atlas_id: int, load_animation: Union[bool, int]) -> None:
    """
    Loads a Spine animation exported in the JSON format.

    Please see the guide section for details on what is supported. Returns an ID to use to reference this skeleton. You
    must first load the atlas image exported by Spine into an AGK image with the normal `load_image()` command and pass
    it into this function. You can choose to load animations as well, or just the sprites and bones and move or modify
    them manually. You can use the scale value to change the size of the sprites and bones to match your chosen
    resolution. A value of 1 will not change the sizes, a value of 2 will make everything twice as big, a value of 0.5
    will half the size, and so on.

    :param int skeleton_id: ID to use for this skeleton.
    :param str filename: Name of the file to load, should be the .json export from Spine.
    :param Union[float, int] scale: The amount to scale the object sizes.
    :param int atlas_id: ID of the atlas image containing all the images.
    :param Union[bool, int] load_animation: True to load animation, False to only load sprites and bones.
    :rtype: None
    """
    pass    


def load_skeleton_2d_from_spriter_file(filename: str, scale: Union[float, int],
                                       atlas_id: Optional[int] = 0) -> int:
    """
    Loads a Spriter animation exported in the JSON format.

    Please see the guide section for details on what is supported. Returns an ID to use to reference this skeleton. The
    atlas image parameter is not yet supported and must be 0, the images will be loaded from the paths specified in the
    Spriter JSON file. You can use the scale value to change the size of the sprites and bones to match your chosen
    resolution. A value of 1 will not change the sizes, a value of 2 will make everything twice as big, a value of 0.5
    will half the size, and so on.

    :param str filename: Name of the file to load, should be the .json export from Spine.
    :param Union[float, int] scale: The amount to scale the object sizes.
    :param Optional[int] atlas_id: Reserved, must be 0.
    :rtype: int
    """
    pass    


def load_skeleton_2d_id_from_spriter_file(skeleton_id: int, filename: str, scale: Union[float, int],
                                          atlas_id: Optional[int] = 0) -> None:
    """
    Loads a Spriter animation exported in the JSON format.

    Please see the guide section for details on what is supported. Returns an ID to use to reference this skeleton. The
    atlas image parameter is not yet supported and must be 0, the images will be loaded from the paths specified in the
    Spriter JSON file. You can use the scale value to change the size of the sprites and bones to match your chosen
    resolution. A value of 1 will not change the sizes, a value of 2 will make everything twice as big, a value of 0.5
    will half the size, and so on.

    :param int skeleton_id: ID to use for this skeleton.
    :param str filename: Name of the file to load, should be the .json export from Spine.
    :param Union[float, int] scale: The amount to scale the object sizes.
    :param Optional[int] atlas_id: Reserved, must be 0.
    :rtype: None
    """
    pass    


def play_skeleton_2d_animation(skeleton_id: int, name: str, start_time: Optional[Union[float,
                               int]] = 0.0, loop: Optional[int] = 0,
                               tween_time: Optional[Union[float, int]] = 0.0) -> None:
    """
    Plays the given animation by name if it exists with an optional start time (Default 0), optional looping, and
    optional tween time (Default 0).

    The tween time will smoothly interpolate the skeleton from its current state to the first frame of the specified
    animation before it starts animating so that there is no sharp transition. A loop value of 1 will loop forever, a
    loop value greater than 1 will loop for that many times and then stop, and a loop value of 0 will play the animation
    once and then stop.

    :param int skeleton_id: ID of the skeleton to modify.
    :param str name: The name of the animation to play.
    :param Optional[Union[float, int]] start_time: An optional offset into the animation to skip some frames.
    :param Optional[int] loop: 1 to loop the animation until stopped, 0 to play it once, greater than 1 to loop that
        many times.
    :param Optional[Union[float, int]] tween_time: Number of seconds to transition from its current state before
        animating.
    :rtype: None
    """
    pass    


def set_skeleton_2d_animation_frame(skeleton_id: int, name: str, time: Union[float, int],
                                    tween_time: Union[float, int]) -> None:
    """
    Sets the skeleton to a specific point in the animation based on time, with optional tweening time.

    The tween time will smoothly interpolate the skeleton from its current state to the chosen frame of the specified
    animation so that there is no sharp transition.

    :param int skeleton_id: ID of the skeleton to modify.
    :param str name: The name of the animation to use.
    :param Union[float, int] time: The time offset to use to set the frame of the skeleton.
    :param Union[float, int] tween_time: Number of seconds to transition from its current state to the given frame.
    :rtype: None
    """
    pass    


def set_skeleton_2d_animation_speed(skeleton_id: int, speed: Union[float, int]) -> None:
    """
    Sets the animation speed (Default 1.0), negative values are allowed to reverse the animation.

    :param int skeleton_id: ID of the skeleton to modify.
    :param Union[float, int] speed: The speed of the animation with 1.0 being normal speed.
    :rtype: None
    """
    pass    


def set_skeleton_2d_bone_angle(skeleton_id: int, bone: int, angle: Union[float, int]) -> None:
    """
    Set the original angle of a bone relative to its parent.

    All animation will be relative to this angle, this can be changed whilst an animation is playing.

    :param int skeleton_id: ID of the skeleton to modify.
    :param int bone: ID of the bone to modify.
    :param Union[float, int] angle: The new angle to use (in degrees).
    :rtype: None
    """
    pass    


def set_skeleton_2d_bone_mode(skeleton_id: int, bone: int, animate: Union[bool, int]) -> None:
    """
    Sets whether the bone can animate or if it remains stationary.

    You can still modify the bone position, angle, and scale manually.

    :param int skeleton_id: ID of the skeleton to modify.
    :param int bone: ID of the bone to modify.
    :param Union[bool, int] animate: True to let the bone animate, False to stop it.
    :rtype: None
    """
    pass    


def set_skeleton_2d_bone_position(skeleton_id: int, bone: int, x: Union[float, int], y: Union[float,
                                  int]) -> None:
    """
    Set the original position of a bone relative to its parent also know as the setup pose.

    All animation will be relative to this position, this can be changed whilst an animation is playing.

    :param int skeleton_id: ID of the skeleton to modify.
    :param int bone: The ID of the bone to modify.
    :param Union[float, int] x: The new X position to use.
    :param Union[float, int] y: The new Y position to use.
    :rtype: None
    """
    pass    


def set_skeleton_2d_bone_scale(skeleton_id: int, bone: int, x: Union[float, int], y: Union[float,
                               int]) -> None:
    """
    Set the original scale of a bone.

    Animations will override this value.

    :param int skeleton_id: ID of the skeleton to modify.
    :param int bone: ID of the bone to modify.
    :param Union[float, int] x: The new X scale value to use.
    :param Union[float, int] y: The new Y scale value to use.
    :rtype: None
    """
    pass    


def set_skeleton_2d_depth(skeleton_id: int, depth: int) -> None:
    """
    Sets the depth of this skeleton in the range 0-10000 with 0 being top.

    :param int skeleton_id: ID of the skeleton to modify.
    :param int depth: The depth value to use.
    :rtype: None
    """
    pass    


def set_skeleton_2d_flip(skeleton_id: int, horizontal: Union[bool, int], vertical: Union[bool,
                         int]) -> None:
    """
    Sets the horizontal and vertical flip mode of the skeleton, this will flip all bones and sprites along the
    horizontal or vertical axis (or both).

    :param int skeleton_id: ID of the skeleton to modify.
    :param Union[bool, int] horizontal: True to flip the skeleton in the horizontal axis, False for no flip.
    :param Union[bool, int] vertical: True to flip the skeleton in the vertical axis, False for no flip.
    :rtype: None
    """
    pass    


def set_skeleton_2d_position(skeleton_id: int, x: Union[float, int], y: Union[float, int]) -> None:
    """
    Sets the position of the root of the skeleton, the bone positions will be relative to this spot.

    This can be used to move the skeleton whilst it is animating to make it look like it is walking.

    :param int skeleton_id: ID of the skeleton to modify.
    :param Union[float, int] x: The X position of the skeleton.
    :param Union[float, int] y: The Y position of the skeleton.
    :rtype: None
    """
    pass    


def set_skeleton_2d_rotation(skeleton_id: int, angle: Union[float, int]) -> None:
    """
    Sets the angle of the root of the skeleton, the bone angles will be relative to this angle.

    :param int skeleton_id: ID of the skeleton to modify.
    :param Union[float, int] angle: The angle to use in degrees.
    :rtype: None
    """
    pass    


def set_skeleton_2d_visible(skeleton_id: int, visible: Union[bool, int]) -> None:
    """
    Sets whether the specified skeleton is visible or not.

    AGK will automatically hide the skeleton when it moves off screen to improve performance, so you only need to do
    this if you want to hide it whilst it is on screen. When hidden a skeleton will still animate.

    :param int skeleton_id: ID of the skeleton to modify.
    :param Union[bool, int] visible: True to make it visible, False to hide it.
    :rtype: None
    """
    pass    


def stop_skeleton_2d_animation(skeleton_id: int) -> None:
    """
    Stop the skeleton animating.

    :param int skeleton_id: ID of the skeleton to modify.
    :rtype: None
    """
    pass    


def delete_sound(sound_id: int) -> None:
    """
    Delete the sound at the specified sound number.

    This will also delete all instances of the sound.

    :param int sound_id: The sound number to delete.
    :rtype: None
    """
    pass    


def get_sound_exists(sound_id: int) -> bool:
    """
    Returns a value of True if the specified sound number exists, otherwise False is returned.

    :param int sound_id: The sound number to check.
    :rtype: bool
    """
    pass    


def get_sound_instance_loop_count(instance_id: int) -> int:
    """
    If the sound was played with looping turned on this command returns the number of loops completed so far.

    If the instance is using a fixed number of loops then it will never actually reach that loop count value as it will
    be immediately deleted upon reaching the end of its last loop. The instance ID is the value returned from
    `play_sound()` when you initiated the playing of the sound.

    :param int instance_id: The ID of the instance to check.
    :rtype: int
    """
    pass    


def get_sound_instance_playing(instance_id: int) -> bool:
    """
    Returns True if the given instance is still playing or looping, False if it has stopped.

    The instance ID is the value returned from `play_sound()` when you initiated the playing of the sound. Once this
    command returns False the instance has been deleted and can no longer be referenced, any attempt to modify it will
    be ignored. You will need to create a new instance by using `play_sound()` again.

    :param int instance_id: The ID of the instance to check.
    :rtype: bool
    """
    pass    


def get_sound_instance_rate(instance_id: int) -> float:
    """
    Returns the current playback rate of the specified instance, with 1.0 being normal speed, 2.0 being double speed,
    and so on.

    Not all devices are guaranteed to support modifying playback rates.

    :param int instance_id: The ID of the instance to check.
    :rtype: float
    """
    pass    


def get_sound_instances(sound_id: int) -> int:
    """
    Returns the number of instances of this sound ID that are currently playing or looping.

    This is exactly the same as `get_sounds_playing()`.

    :param int sound_id: The sound number to check.
    :rtype: int
    """
    pass    


def get_sound_instance_volume(instance_id: int) -> int:
    """
    Returns the current volume of the specified instance, between 0 and 100.

    :param int instance_id: The ID of the instance to check.
    :rtype: int
    """
    pass    


def get_sound_max_rate() -> float:
    """
    Gets the maximum rate and which sound files can be played on this device.

    A rate of 1.0 is normal speed, a rate of 2.0 would be double speed, 0.5 would be half speed, and so on. If you
    attempt to change a sound playback rate outside of these values it will be clamped to these values. If both min and
    max return 1.0 then changing the speed of sound playback is not supported on this device.

    :rtype: float
    """
    pass    


def get_sound_min_rate() -> float:
    """
    Gets the minimum rate and which sound files can be played on this device.

    A rate of 1.0 is normal speed, a rate of 2.0 would be double speed, 0.5 would be half speed, and so on. If you
    attempt to change a sound playback rate outside of these values it will be clamped to these values. If both min and
    max return 1.0 then changing the speed of sound playback is not supported on this device.

    :rtype: float
    """
    pass    


def get_sounds_playing(sound_id: int) -> int:
    """
    Returns the number of instances of this sound ID that are currently playing or looping.

    This is exactly the same as `get_sound_instances()`.

    :param int sound_id: The sound number to check.
    :rtype: int
    """
    pass    


def get_speech_num_voices() -> int:
    """
    Returns the number of voices that can be selected with the `set_speech_language()` command.

    You can use the `get_speech_voice_name()` and `get_speech_voice_language()` commands to get details about the
    different voices.

    Currently only works on iOS and Android.

    :rtype: int
    """
    pass    


def get_speech_voice_id(index: int) -> str:
    """
    Returns the ID of the given voice.

    The ID can be used with `set_speech_language_by_id()` to select a specific voice.

    :param int index: The index of the voice to check, starts at 0 for the first voice
    :rtype: str
    """
    pass    


def get_speech_voice_language(index: int) -> str:
    """
    Returns the language string of the given voice.

    This can be used directly with the `set_speech_language()` command to use this voice for any future speech.

    Currently only works on iOS and Android.

    :param int index: The index of the voice to check, starts at 0 for the first voice
    :rtype: str
    """
    pass    


def get_speech_voice_name(index: int) -> str:
    """
    Returns the name of the given voice.

    On iOS this is a human readable first name, but does not give any details about the accent or language of that
    voice. On Android the name gives the language and accent information but is not as easy to read.

    Currently only works on iOS and Android.

    :param int index: The index of the voice to check, starts at 0 for the first voice
    :rtype: str
    """
    pass    


def get_text_to_speech_ready() -> bool:
    """
    Returns True when the text to speech engine is ready to start converting text to speech.

    Calling other text to speech commands when it is not ready will be ignored.

    Currently only works on iOS and Android.

    :rtype: bool
    """
    pass    


def is_speaking() -> bool:
    """
    Returns True if Speak has been called and the text has not yet finished. If multiple items of text have been queued
    up then this command will continue to return True until all of them have been spoken, or `stop_speaking()` is
    called.

    Currently only works on iOS and Android.

    :rtype: bool
    """
    pass    


def load_sound(filename: str) -> int:
    """
    Loads a sound file from the application media folder and returns the sound number.

    File paths must be relative, not absolute, you cannot load sound files from elsewhere on the disk.

    Please note that compressed WAV files are not supported. You must use uncompressed WAV files to ensure compatibility
    on all platforms.

    :param str filename: The filename of the sound file to load, must be a WAV file.
    :rtype: int
    """
    pass    


def load_sound_id(sound_id: int, filename: str) -> None:
    """
    Loads a sound file from the application media folder and returns the sound number.

    File paths must be relative, not absolute, you cannot load sound files from elsewhere on the disk.

    Please note that compressed WAV files are not supported. You must use uncompressed WAV files to ensure compatibility
    on all platforms.

    :param int sound_id: The sound number to store the sound.
    :param str filename: The filename of the sound file to load, must be a WAV file.
    :rtype: None
    """
    pass    


def load_sound_ogg(filename: str) -> int:
    """
    Loads a sound file from the application media folder.

    File paths must be relative, not absolute, you cannot load sound files from elsewhere on the disk.

    This command takes a compressed OGG file and decompresses it during loading, allowing you to save file size, but
    memory usage will be the same as if you used a WAV file. If you want to use OGG whilst also saving memory then use
    the new `load_music_ogg()` commands.

    :param str filename: The filename of the sound file to load, must be a OGG file.
    :rtype: int
    """
    pass    


def load_sound_ogg_id(sound_id: int, filename: str) -> None:
    """
    Loads a sound file from the application media folder.

    File paths must be relative, not absolute, you cannot load sound files from elsewhere on the disk.

    This command takes a compressed OGG file and decompresses it during loading, allowing you to save file size, but
    memory usage will be the same as if you used a WAV file. If you want to use OGG whilst also saving memory then use
    the new `load_music_ogg()` commands.

    :param int sound_id: The sound number to store the sound.
    :param str filename: The filename of the sound file to load, must be a OGG file.
    :rtype: None
    """
    pass    


def play_sound(sound_id: int, volume: int = 100, loop: Optional[int] = 0,
               priority: Optional[int] = 0) -> int:
    """
    Play the sound previously loaded into the specified sound number.

    This command can be called multiple times for the same sound ID and it will start multiple copies of that sound
    playing as instances. The command will return an instance ID that can be used to interact with this instance whilst
    it is still playing. When an instance stops playing then it is automatically deleted and can no longer be
    referenced. By default the sound is not looped.

    :param int sound_id: The sound number to play.
    :param int volume: The volume at which the sound should be played (optional, default 100).
    :param Optional[int] loop: The number of times to loop the instance, or 1 for forever. (optional, default 0)
    :param Optional[int] priority: Reserved for future use, must be 0 (optional, default 0).
    :rtype: int
    """
    pass    


def save_sound(sound_id: int, filename: str) -> None:
    """
    Saves a sound file to the application write folder.

    :param int sound_id: The ID of the sound to save.
    :param str filename: The filename to use for the sound file, recommended it end in .wav.
    :rtype: None
    """
    pass    


def set_sound_device_mode(mode: int) -> None:
    """
    Sets whether the app will allow background music from other apps to continue playing (mode=0) or silence other apps
    whilst this app is active (mode=1). Note that in mode 0 the device considers your app audio to be unimportant so
    will be silenced if the device ringer is set to silent.

    This only works on iOS.

    :param int mode: The sound mode to use (default=0)
    :rtype: None
    """
    pass    


def set_sound_instance_balance(instance_id: int, balance: Union[float, int]) -> None:
    """
    Sets the current balance of the specified instance, with 0 being centered, -1.0 being all on the left speaker, and
    1.0 being all on the right speaker, any values outside this range will be clamped.

    This works best with mono sounds but can be applied to stereo sounds. The instance ID is the value returned from
    `play_sound()` when you initiated the playing of the sound.

    :param int instance_id: The ID of the instance to modify.
    :param Union[float, int] balance: The new balance of the instance.
    :rtype: None
    """
    pass    


def set_sound_instance_rate(instance_id: int, rate: Union[float, int]) -> None:
    """
    Sets the current playback rate of the specified instance, with 1.0 being normal speed, 2.0 being double speed, and
    so on.

    Not all devices are guaranteed to support modifying playback rates. Use `get_sound_max_rate()` and
    `get_sound_min_rate()` to check the valid ranges for the current device, any values outside this range will be
    clamped. The instance ID is the value returned from `play_sound()` when you initiated the playing of the sound.

    :param int instance_id: The ID of the instance to modify.
    :param Union[float, int] rate: The new playback rate of the instance.
    :rtype: None
    """
    pass    


def set_sound_instance_volume(instance_id: int, volume: int) -> None:
    """
    Sets the current volume of the specified instance, between 0 and 100.

    The instance ID is the value returned from `play_sound()` when you initiated the playing of the sound.

    :param int instance_id: The ID of the instance to modify.
    :param int volume: The new volume of the instance, 0 to 100.
    :rtype: None
    """
    pass    


def set_sound_system_volume(volume: int) -> None:
    """
    Sets the master sound volume for all sounds.

    The individual sound volumes will remain intact, but all volumes are multiplied by the master sound volume allowing
    features such as fading.

    :param int volume: The master sound volume for all sounds.
    :rtype: None
    """
    pass    


def set_speech_language(language: str) -> None:
    """
    Sets the language to use when speaking text, for example "en_GB" for British English, "en_US" for American English,
    "fr_FR" for French, and so on.

    If the language engine is not currently on the device then the device will attempt to download it when Speak is next
    called, this may introduce a delay before that text is spoken. If the download fails, or no internet connection is
    available then the default language engine for the current device will be used.

    Currently only works on iOS and Android.

    :param str language: The language to use for speaking text, default is the device's current language.
    :rtype: None
    """
    pass    


def set_speech_language_by_id(lang_id: str) -> None:
    """
    Sets the language to use when speaking text by voice ID.

    The ID can be found with `get_speech_voice_id()`, and is necessary when multiple voices have the same language but
    with different accents.

    :param str lang_id: The language to use for speaking text, default is the device's current language.
    :rtype: None
    """
    pass    


def set_speech_rate(rate: Union[float, int]) -> None:
    """
    Sets the speaking rate, where 1.0 is normal speed, 2.0 is double speed, 0.5 is half speed, and so on.

    Currently only works on iOS and Android.

    :param Union[float, int] rate: The rate to speak text, default is 1.0.
    :rtype: None
    """
    pass    


def speak(text: str, delay: Optional[int] = 0) -> None:
    """
    Queues the given text for speaking.

    If some text is already being spoken then the given text will be spoken after the current speech has finished. This
    command can be called multiple times in quick succession to queue up a lot of text. You can call `is_speaking()` to
    check when the queue is empty and all text has been spoken, or cancelled. Note that there may be a delay on the
    first call to this command when an unfamiliar language has been set with `set_speech_language()`. For example using
    French on a device setup for English will attempt to download the French language engine before starting to speak
    the text.

    If the app is sent to the background then speech will stop and all text will be removed from the queue.

    You can specify an optional delay in milliseconds to make the device wait before starting to say the text.

    Currently only works on iOS and Android.

    :param str text: The text to speak.
    :param Optional[int] delay: The amount of time in milliseconds to wait before starting the speech output.
    :rtype: None
    """
    pass    


def stop_sound(sound_id: int) -> None:
    """
    Stop the sound currently playing at the specified sound number.

    :param int sound_id: The sound number to stop.
    :rtype: None
    """
    pass    


def stop_sound_instance(instance_id: int) -> None:
    """
    Stops the current instance if it hasn't already.

    This deletes the instance and its ID cannot be used again. The instance ID is the value returned from `play_sound()`
    when you initiated the playing of the sound.

    :param int instance_id: The ID of the instance to check.
    :rtype: None
    """
    pass    


def stop_speaking() -> None:
    """
    Immediately stops any text that is being spoken and removes all items from the queue.

    Currently only works on iOS and Android.

    :rtype: None
    """
    pass    


def text_to_speech_setup() -> None:
    """
    Initialises the Text To Speech engine on the device so that it can produce audio.

    Note that this may not be immediate, you should check `get_text_to_speech_ready()` to see if it has finished setting
    up. Calling other text to speech commands when it is not ready will be ignored.

    Currently only works on iOS and Android.

    :rtype: None
    """
    pass    


def vibrate_device(seconds: Union[float, int]) -> None:
    """
    Vibrates the device for the specified number of seconds.

    Works on iOS and Android. Note that on iOS the length value is ignored and only a short vibration will occur, this
    is due to Apple restrictions.

    :param Union[float, int] seconds: The time in seconds to vibrate.
    :rtype: None
    """
    pass    


def add_sprite_animation_frame(sprite_id: int, image_id: int) -> None:
    """
    Adds an image to the sprite as a new animation frame.

    Frame indices start at 1 and increase incrementally. This image may be shared by multiple sprites either as single
    images or as animation frames, the image may also be a part of an atlas texture.

    Alternatively if you have all your animation frames on a single image you can use the faster
    `set_sprite_animation()` that avoids image changes during rendering by modifying the UV coordinates to change frame
    instead.

    :param int sprite_id: The ID of the sprite to set for animation.
    :param int image_id: The ID of the image to add.
    :rtype: None
    """
    pass    


def add_sprite_shape_box(sprite_id: int, x1: Union[float, int], y1: Union[float, int],
                         x2: Union[float, int], y2: Union[float, int], angle: Union[float,
                         int]) -> None:
    """
    Adds a new shape to the sprite, in addition to any it already has.

    These additional shapes only apply to physics sprites and must be added after a sprite has been set to use physics.

    The box is defined by specifying its top left and bottom right coordinates in sprite space, relative to its current
    offset. For example if the current sprite offset was 0,0 the top left box corner would be 0,0, but if the sprite
    offset was the middle of the sprite (default) the top left corner would be -width/2,-height/2. You may also specify
    an angle to offset the box relative to the current sprite rotation.

    This will recalculate the sprite's mass and center of mass values.

    :param int sprite_id: The ID of the sprite to modify.
    :param Union[float, int] x1: The x coordinate of the top left corner of the new box in sprite space.
    :param Union[float, int] y1: The y coordinate of the top left corner of the new box in sprite space.
    :param Union[float, int] x2: The x coordinate of the bottom right corner of the new box in sprite space.
    :param Union[float, int] y2: The Y coordinate of the bottom right corner of the new box in sprite space.
    :param Union[float, int] angle: The angle of the box in radians.
    :rtype: None
    """
    pass    


def add_sprite_shape_chain(sprite_id: int, num_points: int, index: int, loop: Union[bool, int],
                           x: Union[float, int], y: Union[float, int]) -> None:
    """
    Adds a new shape to the sprite, in addition to any it already has.

    Shapes can be added even if the sprite is not setup for physics.

    The chain is defined by a set of points (at least 2) relative to the current sprite's offset. For example, a point
    of 0,0 would be centered on the sprite's offset point, any other value will be offset from this point. Chains are
    rigid and can be used to create hollow concave polygons, or 2D terrains. Set the loop parameter to True to join to
    two ends of the chain together creating a hollow polygon. Points are defined one at a time by calling this command
    multiple times, with `index` starting at 0. Once the `index` equals `num_points`-1 then the shape will be created
    using the previously defined points. Once you start defining points you must complete the process by reaching
    `index`=`num_points`-1 before defining points for any other shape.

    This will recalculate the sprite's mass and center of mass values.

    :param int sprite_id: The ID of the sprite to modify.
    :param int num_points: The number of points to use in the chain; minimum of 2, no maximum.
    :param int index: The index of the point to set, if it equals `num_points`-1 then the shape will be created.
    :param Union[bool, int] loop: True to connect this back to the first point creating a loop, False to leave this
        point hanging on the end (default).
    :param Union[float, int] x: X position for the specified point.
    :param Union[float, int] y: Y position for the specified point.
    :rtype: None
    """
    pass    


def add_sprite_shape_circle(sprite_id: int, x: Union[float, int], y: Union[float, int],
                            radius: Union[float, int]) -> None:
    """
    Adds a new shape to the sprite, in addition to any it already has.

    These additional shapes only apply to physics sprites and must be added after a sprite has been set to use physics.

    The circle is defined by specifying its center point relative to the sprite's current offset and a radius. For
    example, if the circle was to be centered on the sprite's offset point it would be specified at position 0,0. Any
    other value will offset the circle from the sprite. The radius is defined in x coordinates, due to world coordinates
    not necessarily representing the size of items on screen (e.g. 10 units in X may not be the same apparent size as 10
    units in Y).

    This will recalculate the sprite's mass and center of mass values.

    :param int sprite_id: The ID of the sprite to modify.
    :param Union[float, int] x: The x coordinate of the center of the circle in sprite space.
    :param Union[float, int] y: The y coordinate of the center of the circle in sprite space.
    :param Union[float, int] radius: The radius of the circle.
    :rtype: None
    """
    pass    


def add_sprite_shape_polygon(sprite_id: int, total_points: int, point: int, x: Union[float, int],
                             y: Union[float, int]) -> None:
    """
    Adds a new shape to the sprite, in addition to any it already has.

    These additional shapes only apply to physics sprites and must be added after a sprite has been set to use physics.

    The polygon is defined by a set of points (between 2 and 12) relative to the current sprite's offset. For example, a
    point of 0,0 would be centered on the sprite's offset point, any other value will be offset from this point. Points
    are defined one at a time by calling this command multiple times, with `index` starting at 0. Once the `index`
    equals `total_points`-1 then the shape will be created using the previously defined points. Once you start defining
    points you must complete the process by reaching `index`=`total_points`-1 before defining points for any other
    shape.

    This will recalculate the sprite's mass and center of mass values.

    :param int sprite_id: The ID of the sprite to modify.
    :param int total_points: The number of points to use in the polygon, min 2, max 12.
    :param int point: Index for points, so you can specify index 0, 1, 2 etc.
    :param Union[float, int] x: X position for the specified point.
    :param Union[float, int] y: Y position for the specified point.
    :rtype: None
    """
    pass    


def calculate_sprite_physics_com(sprite_id: int) -> None:
    """
    Recalculates the COM based on the shapes attached to the sprite, if you have overridden the COM this will set it
    back to a location decided by the AGK.

    If the COM is very different from the offset point the sprite may seem unstable as it will behave like an unbalanced
    spinning top.

    :param int sprite_id: The ID of the sprite to modify.
    :rtype: None
    """
    pass    


def clear_sprite_animation_frames(sprite_id: int) -> None:
    """
    Removes all animation frames from a sprite returning it to a single image sprite.

    If you added images individually to the sprite using `add_sprite_animation_frame()` then the sprite's image will be
    undefined and it is recommended that you assign it a new image.

    :param int sprite_id: The ID of the sprite to clear.
    :rtype: None
    """
    pass    


def clear_sprite_shapes(sprite_id: int) -> None:
    """
    Removes all additional shapes applied to the sprite and keeps only the base shape at shapeID 1.

    :param int sprite_id: The ID of the sprite to modify.
    :rtype: None
    """
    pass    


def clone_sprite(copy_sprite_id: int) -> int:
    """
    Clones a sprite into a given sprite ID.

    The new sprite will be in in exactly the same position as the original.

    Any physics values or shapes assigned to the sprite will not be copied. The new sprite will not be setup for
    physics.

    :param int copy_sprite_id: The ID of the sprite to copy.
    :rtype: int
    """
    pass    


def clone_sprite_to(new_sprite_id: int, copy_sprite_id: int) -> None:
    """
    Clones a sprite into a given sprite ID.

    The new sprite will be in in exactly the same position as the original.

    Any physics values or shapes assigned to the sprite will not be copied. The new sprite will not be setup for
    physics.

    :param int new_sprite_id: The ID to use for the new sprite.
    :param int copy_sprite_id: The ID of the sprite to copy.
    :rtype: None
    """
    pass    


def create_dummy_sprite() -> int:
    """
    Creates a sprite in the given sprite ID, it returns the sprite ID used.

    Dummy sprites behave as normal sprites but have no image or other visual aspect to them. They will not be drawn even
    if an image is assigned to them. They are useful for adding physics objects to a scene without needing visuals to
    accompany the physics shape. You can use the physics contact and feedback commands to work out what has hit these
    hidden physics shapes if desired. If you do not need to know what has hit your hidden shapes then you can add them
    all to a single dummy sprite using `add_sprite_shape_box()`, `add_sprite_shape_chain()`,
    `add_sprite_shape_circle()`, and `add_sprite_shape_polygon()` for best performance.

    `set_sprite_shape()` will not work on dummy sprites as they have no image to calculate a shape, shapes must be
    defined manually using `set_sprite_shape_box()`, `set_sprite_shape_circle()`, or `set_sprite_shape_polygon()`.

    Dummy sprites will not update their stored angle and position with the latest physics versions, so calls to
    `get_sprite_x()`, `get_sprite_y()`, or `get_sprite_angle()` will return the last value you set. Setting the sprite's
    position will update the physics body to the position you set.

    :rtype: int
    """
    pass    


def create_dummy_sprite_id(sprite_id: int) -> None:
    """
    Creates a sprite in the given sprite ID, it returns the sprite ID used.

    Dummy sprites behave as normal sprites but have no image or other visual aspect to them. They will not be drawn even
    if an image is assigned to them. They are useful for adding physics objects to a scene without needing visuals to
    accompany the physics shape. You can use the physics contact and feedback commands to work out what has hit these
    hidden physics shapes if desired. If you do not need to know what has hit your hidden shapes then you can add them
    all to a single dummy sprite using `add_sprite_shape_box()`, `add_sprite_shape_chain()`,
    `add_sprite_shape_circle()`, and `add_sprite_shape_polygon()` for best performance.

    `set_sprite_shape()` will not work on dummy sprites as they have no image to calculate a shape, shapes must be
    defined manually using `set_sprite_shape_box()`, `set_sprite_shape_circle()`, or `set_sprite_shape_polygon()`.

    Dummy sprites will not update their stored angle and position with the latest physics versions, so calls to
    `get_sprite_x()`, `get_sprite_y()`, or `get_sprite_angle()` will return the last value you set. Setting the sprite's
    position will update the physics body to the position you set.

    :param int sprite_id: The ID to use for this sprite.
    :rtype: None
    """
    pass    


def create_sprite(image_id: int) -> int:
    """
    Creates a sprite in a blank sprite ID with an image to use when rendering, it returns the sprite ID used.

    By default sprites are created with a depth of 10, are sized using the given image as a guide, and positioned at 0,0
    using their top left corner.

    You may use an image ID of 0 to create a blank sprite drawn with color only.

    If the assigned image has alpha pixels the sprite is create with a transparency mode of 1, otherwise it uses a
    transparency mode of 0 (opaque).

    :param int image_id: The ID of the image to use when drawing this sprite.
    :rtype: int
    """
    pass    


def create_sprite_id(sprite_id: int, image_id: int) -> None:
    """
    Creates a sprite in a blank sprite ID with an image to use when rendering, it returns the sprite ID used.

    By default sprites are created with a depth of 10, are sized using the given image as a guide, and positioned at 0,0
    using their top left corner.

    You may use an image ID of 0 to create a blank sprite drawn with color only.

    If the assigned image has alpha pixels the sprite is create with a transparency mode of 1, otherwise it uses a
    transparency mode of 0 (opaque).

    :param int sprite_id: The sprite ID to use to reference this sprite later (separate from image IDs, so there can be
        both a sprite 1 and an image 1).
    :param int image_id: The ID of the image to use when drawing this sprite.
    :rtype: None
    """
    pass    


def delete_all_sprites() -> None:
    """
    Deletes all sprites created with `create_sprite()`, `create_dummy_sprite()`, or `load_sprite()`.

    This also resets the auto sprite ID to 10000.

    :rtype: None
    """
    pass    


def delete_sprite(sprite_id: int) -> None:
    """
    Deletes the sprite at the given ID.

    :param int sprite_id: The ID of the sprite to delete.
    :rtype: None
    """
    pass    


def draw_sprite(sprite_id: int) -> None:
    """
    Immediately draws the sprite to the backbuffer at its current position, size, and rotation.

    This is useful if you want to setup a scene for `get_image()` to capture. Remember to use `clear_screen()` to clear
    any of your own drawing before calling `sync()` or `render()` for the actual frame otherwise your drawing may appear
    twice in the final render.

    :param int sprite_id: The ID of the sprite to draw.
    :rtype: None
    """
    pass    


def fix_sprite_to_screen(sprite_id: int, fixed: Union[bool, int]) -> None:
    """
    By default sprites are created in world coordinates and `set_view_offset()` can be used to move around the world.

    Use this command to instead fix the sprite to the screen so it will move with the viewport when the viewport is
    moved around. You can still reposition a sprite that is fixed to the screen, it only affects what happens when the
    viewport is moved. You should not use physics or collision commands on sprites fixed to the screen as their debug
    shapes will not line up and they will interfere with physics sprites not fixed to the screen.

    :param int sprite_id: The ID of the sprite to change.
    :param Union[bool, int] fixed: True for screen sprite, False for world sprite.
    :rtype: None
    """
    pass    


def get_physics_collision(sprite_id1: int, sprite_id2: int) -> bool:
    """
    Returns True if two physics sprites overlap, otherwise it returns False.

    This function doesn't do any calculation, it simply looks up the results of the last physics step to determine if
    the sprites currently overlap. If this function returns true you can get the point of collision using
    `get_physics_collision_x()` and `get_physics_collision_y()`, if there is more than one point of collision it is not
    known which point will be returned. You can check the sprite's contact list to get the full list of contact points.

    This function is affected by group and category settings.

    :param int sprite_id1: The ID of the first sprite to check.
    :param int sprite_id2: The ID of the second sprite to check.
    :rtype: bool
    """
    pass    


def get_physics_collision_world_x() -> float:
    """
    Returns the X coordinate of the collision point from the last call to `get_physics_collision()` in world
    coordinates.

    :rtype: float
    """
    pass    


def get_physics_collision_world_y() -> float:
    """
    Returns the Y coordinate of the collision point from the last call to `get_physics_collision()` in world
    coordinates.

    :rtype: float
    """
    pass    


def get_physics_collision_x() -> float:
    """
    Returns the X coordinate of the collision point from the last call to `get_physics_collision()` relative to the
    first sprite's offset.

    :rtype: float
    """
    pass    


def get_physics_collision_y() -> float:
    """
    Returns the Y coordinate of the collision point from the last call to `get_physics_collision()` relative to the
    first sprite's offset.

    :rtype: float
    """
    pass    


def get_sprite_active(sprite_id: int) -> bool:
    """
    Returns False if the sprite has been set as inactive using `set_sprite_active()`, otherwise returns True.

    :param int sprite_id: The ID of the sprite to check.
    :rtype: bool
    """
    pass    


def get_sprite_angle(sprite_id: int) -> float:
    """
    Returns the current angle of the sprite in degrees, 0 degrees being the direction x=0 y=-1 and proceeding clockwise.

    :param int sprite_id: The ID of the sprite to retrieve.
    :rtype: float
    """
    pass    


def get_sprite_angle_rad(sprite_id: int) -> float:
    """
    Returns the current angle of the sprite in radians, 0 radians being the direction x=0 y=-1 and proceeding clockwise.

    :param int sprite_id: The ID of the sprite to retrieve.
    :rtype: float
    """
    pass    


def get_sprite_collision(sprite_id1: int, sprite_id2: int) -> bool:
    """
    Checks two sprites for collision, if they overlap then it returns True.

    Otherwise it returns False. No other information can be returned about this type of collision.

    This command is primarily for sprites that are not using physics. Whilst it can be used on physics sprites the
    physics system will have already calculated the overlap of all physics sprites during the last frame and stored the
    results in the contact list. This function actually does the calculation required to determine if the sprites
    overlap. This function is not limited by group or category settings.

    This function only operates on the sprite's base shape. Any additional shapes added to physics sprites will not be
    used in this function, use `get_physics_collision()` instead. Also Chain shapes will always return no collision
    using this command, chain shapes are only used in physics calculations.

    If you have not assigned a shape to either sprite using `set_sprite_shape()` they will use the default box shape
    based on the sprite's width and height.

    :param int sprite_id1: The sprite to check for intersection with sprite 2.
    :param int sprite_id2: The sprite to check for intersection with sprite 1.
    :rtype: bool
    """
    pass    


def get_sprite_color_alpha(sprite_id: int) -> int:
    """
    Returns the current alpha value of a sprite in the range 0-255.

    :param int sprite_id: The ID of the sprite to check.
    :rtype: int
    """
    pass    


def get_sprite_color_blue(sprite_id: int) -> int:
    """
    Returns the current blue component of a sprite in the range 0-255.

    :param int sprite_id: The ID of the sprite to check.
    :rtype: int
    """
    pass    


def get_sprite_color_green(sprite_id: int) -> int:
    """
    Returns the current green component of a sprite in the range 0-255.

    :param int sprite_id: The ID of the sprite to check.
    :rtype: int
    """
    pass    


def get_sprite_color_red(sprite_id: int) -> int:
    """
    Returns the current red component of a sprite in the range 0-255.

    :param int sprite_id: The ID of the sprite to check.
    :rtype: int
    """
    pass    


def get_sprite_current_frame(sprite_id: int) -> int:
    """
    Gets the sprite's current frame ID.

    :param int sprite_id: The ID of the sprite to retrieve.
    :rtype: int
    """
    pass    


def get_sprite_depth(sprite_id: int) -> int:
    """
    Returns the current depth of the sprite in the range 0-10000, with 0 being the front of the screen and 10000 being
    the back.

    :param int sprite_id: The ID of the sprite to check.
    :rtype: int
    """
    pass    


def get_sprite_distance(sprite_id1: int, sprite_id2: int) -> float:
    """
    Calculates the minimum distance separating the two sprites.

    If the sprites overlap this will be less than 0. Otherwise it will be the distance between the closest points on
    each sprite, these points can be found using `get_sprite_distance_point1_x()`, etc. This calculation takes longer
    than simply checking if the sprites overlap, if you don't need the distance separating the sprites use
    `get_sprite_collision()`.

    This function is not limited by group or category settings.

    If you have not assigned a shape to either sprite using `set_sprite_shape()` they will use the default box shape
    based on the sprite's width and height.

    :param int sprite_id1: The sprite to check for distance with sprite 2.
    :param int sprite_id2: The sprite to check for distance with sprite 1.
    :rtype: float
    """
    pass    


def get_sprite_distance_point1_x() -> float:
    """
    Returns the X coordinate of the closest point on sprite 1 to sprite 2 from the last call to `get_sprite_distance()`
    in world coordinates.

    :rtype: float
    """
    pass    


def get_sprite_distance_point1_y() -> float:
    """
    Returns the Y coordinate of the closest point on sprite 1 to sprite 2 from the last call to `get_sprite_distance()`
    in world coordinates.

    :rtype: float
    """
    pass    


def get_sprite_distance_point2_x() -> float:
    """
    Returns the X coordinate of the closest point on sprite 2 to sprite 1 from the last call to `get_sprite_distance()`
    in world coordinates.

    :rtype: float
    """
    pass    


def get_sprite_distance_point2_y() -> float:
    """
    Returns the Y coordinate of the closest point on sprite 2 to sprite 1 from the last call to `get_sprite_distance()`
    in world coordinates.

    :rtype: float
    """
    pass    


def get_sprite_exists(sprite_id: int) -> bool:
    """
    Returns True if the sprite exists, False if not.

    :param int sprite_id: The ID of the sprite to check.
    :rtype: bool
    """
    pass    


def get_sprite_flipped_h(sprite_id: int) -> bool:
    """
    Returns True if the sprite has been flipped horizontally with `set_sprite_flip()`, otherwise returns False.

    :param int sprite_id: The ID of the sprite to check.
    :rtype: bool
    """
    pass    


def get_sprite_flipped_v(sprite_id: int) -> bool:
    """
    Returns True if the sprite has been flipped vertically with `set_sprite_flip()`, otherwise returns False.

    :param int sprite_id: The ID of the sprite to check.
    :rtype: bool
    """
    pass    


def get_sprite_frame_count(sprite_id: int) -> int:
    """
    Returns the total number of frames the sprite managed to get from its image.

    May be less than the number of frames requested during setup.

    :param int sprite_id: The ID of the sprite to retrieve.
    :rtype: int
    """
    pass    


def get_sprite_group(sprite_id: int) -> int:
    """
    Returns the value of the group set using `set_sprite_group()`.

    If you have not set the group this will be 0.

    :param int sprite_id: The ID of the sprite to check.
    :rtype: int
    """
    pass    


def get_sprite_height(sprite_id: int) -> float:
    """
    Returns the current height of the sprite as a floating point value.

    :param int sprite_id: The ID of the sprite to retrieve.
    :rtype: float
    """
    pass    


def get_sprite_hit(x: Union[float, int], y: Union[float, int]) -> int:
    """
    Returns the ID of the first sprite found under the point x,y in world coordinates, 0 if none.

    Sprites are ordered by depth so a sprite appearing above another in the draw order will be returned instead of the
    sprite behind it.

    Takes into account the rotation and scale values of the sprite. It does not take into account the transparency of
    the sprite, only its collision shape. Uses the shape assigned to it from `set_sprite_shape()`. If no shape is set it
    uses the sprite width and height as a box shape. If you are testing a mouse or touch coordinate, remember to convert
    it to world coordinates using `screen_to_world_x()` and `screen_to_world_y()`.

    :param Union[float, int] x: The x position in world coordinates to check.
    :param Union[float, int] y: The y position in world coordinates to check.
    :rtype: int
    """
    pass    


def get_sprite_hit_category(categories: int, x: Union[float, int], y: Union[float, int]) -> int:
    """
    Returns the ID of the first sprite found under the point x,y in world coordinates, 0 if none.

    Sprites are ordered by depth so a sprite appearing above another in the draw order will be returned instead of the
    sprite behind it.

    This function filters the results so only sprites of certain categories are checked. The category parameter is a
    bitwise field that uses the lower 16 bits to represent each of the possible 16 categories used when setting up a
    sprite. The default value of all 1s means all categories will be included, whereas a value of all 0s means no
    categories will be included. You can set individual bits to set which ones should be checked. You can set which
    categories a sprite belongs to with `set_sprite_category_bits()`. Takes into account the rotation and scale values
    of the sprite. It does not take into account the transparency of the sprite, only its collision shape. Uses the
    shape assigned to it from `set_sprite_shape()`. If no shape is set it uses the sprite width and height as a box
    shape. If you are testing a mouse or touch coordinate, remember to convert it to world coordinates using
    `screen_to_world_x()` and `screen_to_world_y()`.

    :param int categories: The categories to check.
    :param Union[float, int] x: The x position in world coordinates to check.
    :param Union[float, int] y: The y position in world coordinates to check.
    :rtype: int
    """
    pass    


def get_sprite_hit_group(group: int, x: Union[float, int], y: Union[float, int]) -> int:
    """
    Returns the ID of the first sprite found under the point x,y in world coordinates, 0 if none.

    Sprites are ordered by depth so a sprite appearing above another in the draw order will be returned instead of the
    sprite behind it.

    Filters results to only those sprites in the specified group. By default sprites are created in group 0, you can
    change this with `set_sprite_group()`.

    Takes into account the rotation and scale values of the sprite. It does not take into account the transparency of
    the sprite, only its collision shape. Uses the shape assigned to it from `set_sprite_shape()`. If no shape is set it
    uses the sprite width and height as a box shape. If you are testing a mouse or touch coordinate, remember to convert
    it to world coordinates using `screen_to_world_x()` and `screen_to_world_y()`.

    :param int group: The group ID to check.
    :param Union[float, int] x: The x position in world coordinates to check.
    :param Union[float, int] y: The y position in world coordinates to check.
    :rtype: int
    """
    pass    


def get_sprite_hit_test(sprite_id: int, x: Union[float, int], y: Union[float, int]) -> bool:
    """
    Returns True if the point x,y in world coordinates lies within the sprite, False if not.

    Takes into account the rotation and scale values of the sprite.

    Uses the shape assigned to it from `set_sprite_shape()`. If no shape is set it uses the sprite width and height as a
    box shape.

    If you are testing a mouse or touch coordinate, remember to convert it to world coordinates using
    `screen_to_world_x()` and `screen_to_world_y()`.

    :param int sprite_id: The sprite to test.
    :param Union[float, int] x: The x position in world coordinates to check.
    :param Union[float, int] y: The y position in world coordinates to check.
    :rtype: bool
    """
    pass    


def get_sprite_image_id(sprite_id: int) -> int:
    """
    Gets the ID of the image currently assigned to the sprite.

    This only works if the image was loaded with an ID (or assigned one by AGK).

    :param int sprite_id: The ID of the sprite to check.
    :rtype: int
    """
    pass    


def get_sprite_in_box(sprite_id: int, x1: Union[float, int], y1: Union[float, int], x2: Union[float,
                      int], y2: Union[float, int]) -> bool:
    """
    Returns True if the sprite's collision shape is touching the given box in world coordinates, False if not.

    If the sprite does not have a shape it is assigned a box shape of its own which will remain after this command. This
    command takes into account the rotation and scale of the sprite when checking intersection.

    :param int sprite_id: The ID of the sprite to check.
    :param Union[float, int] x1: The X coordinate of the top left corner of the box in world coordinates.
    :param Union[float, int] y1: The Y coordinate of the top left corner of the box in world coordinates.
    :param Union[float, int] x2: The X coordinate of the bottom right corner of the box in world coordinates.
    :param Union[float, int] y2: The Y coordinate of the bottom right corner of the box in world coordinates.
    :rtype: bool
    """
    pass    


def get_sprite_in_circle(sprite_id: int, x: Union[float, int], y: Union[float, int],
                         radius: Union[float, int]) -> bool:
    """
    Returns True if the sprite's collision shape is touching the given circle in world coordinates, False if not.

    If the sprite does not have a shape it is assigned a box shape of its own which will remain after this command. This
    command takes into account the rotation and scale of the sprite when checking intersection. Note that due to aspect
    ratio modifications this command does not behave as expect when using the percentage coordinate system. Instead it
    will check an ellipse with the correct radius in the X direction but a larger radius in the Y direction.

    :param int sprite_id: The ID of the sprite to check.
    :param Union[float, int] x: The X coordinate of the center of the circle in world coordinates.
    :param Union[float, int] y: The Y coordinate of the center of the circle in world coordinates.
    :param Union[float, int] radius: The radius of the circle in world coordinates.
    :rtype: bool
    """
    pass    


def get_sprite_in_screen(sprite_id: int) -> bool:
    """
    Returns True if the sprite is currently within the visible area of the screen, False if it is outside the visible
    area.

    Note that if the sprite is very close to the edge where it may be difficult to determine if all the pixels in the
    sprite are outside the visible area then this command will return True and assume it is visible. In other words if
    this command returns False then the sprite is definitely off screen, if it returns True then the sprite is most
    likely on screen but could actually be off screen and very close to an edge.

    :param int sprite_id: The ID of the sprite to check.
    :rtype: bool
    """
    pass    


def get_sprite_num_shapes(sprite_id: int) -> int:
    """
    Returns the current number of shapes assigned to this sprite.

    Shape IDs are valid from 1 up to and including the value returned by this command.

    :param int sprite_id: The ID of the sprite to check.
    :rtype: int
    """
    pass    


def get_sprite_offset_x(sprite_id: int) -> float:
    """
    Returns the X component of the sprite's current offset point.

    :param int sprite_id: The ID of the sprite to retrieve.
    :rtype: float
    """
    pass    


def get_sprite_offset_y(sprite_id: int) -> float:
    """
    Returns the Y component of the sprite's current offset point.

    :param int sprite_id: The ID of the sprite to retrieve.
    :rtype: float
    """
    pass    


def get_sprite_physics_angular_velocity(sprite_id: int) -> float:
    """
    Returns the angular velocity of the sprite in radians per second.

    This is the speed at which the sprite is currently rotating.

    :param int sprite_id: The ID of the sprite to check.
    :rtype: float
    """
    pass    


def get_sprite_physics_com_x(sprite_id: int) -> float:
    """
    Returns the X value of current Center Of Mass for the given sprite's physics body.

    All shapes currently added to this sprite contribute to this value. If you have set the center of mass manually then
    it will return that value. Physics must be turned on for this sprite for the command to work, otherwise it will
    return 0.

    :param int sprite_id: The ID of the sprite to check.
    :rtype: float
    """
    pass    


def get_sprite_physics_com_y(sprite_id: int) -> float:
    """
    Returns the Y value of current Center Of Mass for the given sprite's physics body.

    All shapes currently added to this sprite contribute to this value. If you have set the center of mass manually then
    it will return that value. Physics must be turned on for this sprite for the command to work, otherwise it will
    return 0.

    :param int sprite_id: The ID of the sprite to check.
    :rtype: float
    """
    pass    


def get_sprite_physics_gravity_scale(sprite_id: int) -> float:
    """
    Returns the gravity scale for the sprite.

    :param int sprite_id: The ID of the sprite to modify.
    :rtype: float
    """
    pass    


def get_sprite_physics_inertia(sprite_id: int) -> float:
    """
    Returns the current inertia of the sprite.

    :param int sprite_id: The ID of the sprite.
    :rtype: float
    """
    pass    


def get_sprite_physics_is_awake(sprite_id: int) -> bool:
    """
    Returns whether the sprite is awake or not.

    :param int sprite_id: The ID of the sprite.
    :rtype: bool
    """
    pass    


def get_sprite_physics_is_bullet(sprite_id: int) -> bool:
    """
    Returns whether the sprite is set to be a bullet or not.

    :param int sprite_id: The ID of the sprite.
    :rtype: bool
    """
    pass    


def get_sprite_physics_mass(sprite_id: int) -> float:
    """
    Returns the mass of the sprite in kilograms currently being used.

    This was either generated automatically when its shape was created or a shape was added, or was set manually.

    :param int sprite_id: The ID of the sprite to check.
    :rtype: float
    """
    pass    


def get_sprite_physics_velocity_x(sprite_id: int) -> float:
    """
    Returns the linear velocity of the sprite in the X direction.

    This is the number of units per second that the sprite is currently moving in your chosen resolution.

    :param int sprite_id: The ID of the sprite to check.
    :rtype: float
    """
    pass    


def get_sprite_physics_velocity_y(sprite_id: int) -> float:
    """
    Returns the linear velocity of the sprite in the Y direction.

    This is the number of units per second that the sprite is currently moving in your chosen resolution.

    :param int sprite_id: The ID of the sprite to check.
    :rtype: float
    """
    pass    


def get_sprite_pixel_from_x(sprite_id: int, x: Union[float, int]) -> int:
    """
    Converts a point on the sprite's image to the pixel on the sprite's image that is underneath that point.

    For example if a 200x100 pixel image was assigned to a sprite of size 10x10, then calling this command with a pixel
    value of 5 (center of the sprite) would return 100 (center of the image). The sprite must have an image assigned for
    this to work or it will always return 0. The command is not limited by the size of the image or sprite, so in the
    above example a pixel value of 20 or -1 would both be valid.

    :param int sprite_id: The ID of the sprite to check.
    :param Union[float, int] x: The x coordinate of the sprite point to check.
    :rtype: int
    """
    pass    


def get_sprite_pixel_from_y(sprite_id: int, y: Union[float, int]) -> int:
    """
    Converts a point on the sprite's image to the pixel on the sprite's image that is underneath that point.

    For example if a 200x100 pixel image was assigned to a sprite of size 10x10, then calling this command with a pixel
    value of 5 (center of the sprite) would return 50 (center of the image). The sprite must have an image assigned for
    this to work or it will always return 0. The command is not limited by the size of the image or sprite, so in the
    above example a pixel value of 20 or -1 would both be valid.

    :param int sprite_id: The ID of the sprite to check.
    :param Union[float, int] y: The y coordinate of the sprite point to check.
    :rtype: int
    """
    pass    


def get_sprite_playing(sprite_id: int) -> bool:
    """
    Returns True if the sprite is currently playing an animation, False if not.

    :param int sprite_id: The ID of the sprite to check.
    :rtype: bool
    """
    pass    


def get_sprite_scale_x(sprite_id: int) -> float:
    """
    Returns the current scaling of the sprite in the X direction as set with `set_sprite_scale()` or
    `set_sprite_scale_by_offset()`.

    :param int sprite_id: The ID of the sprite to retrieve.
    :rtype: float
    """
    pass    


def get_sprite_scale_y(sprite_id: int) -> float:
    """
    Returns the current scaling of the sprite in the Y direction as set with `set_sprite_scale()` or
    `set_sprite_scale_by_offset()`.

    :param int sprite_id: The ID of the sprite to retrieve.
    :rtype: float
    """
    pass    


def get_sprite_shape_num_vertices(sprite_id: int, shape_id: int) -> int:
    """
    Returns the number of vertices in the specified shape.

    This only applies to polygon and chain shapes. Shape IDs start at 1 for the first shape up to and including the
    value returned by `get_sprite_num_shapes()`.

    :param int sprite_id: The ID of the sprite to check.
    :param int shape_id: The ID of the shape to check.
    :rtype: int
    """
    pass    


def get_sprite_shape_vertex_x(sprite_id: int, shape_id: int, vertex: int) -> float:
    """
    Returns the X value of given vertex in the specified shape.

    This only applies to polygon and chain shapes. Shape IDs start at 1 for the first shape up to and including the
    value returned by `get_sprite_num_shapes()`. Vertex IDs start at 1 for the first vertex up to and including the
    value returned by `get_sprite_shape_num_vertices()`.

    :param int sprite_id: The ID of the sprite to check.
    :param int shape_id: The ID of the shape to check.
    :param int vertex: The ID of the vertex to check, vertices start at ID 1.
    :rtype: float
    """
    pass    


def get_sprite_shape_vertex_y(sprite_id: int, shape_id: int, vertex: int) -> float:
    """
    Returns the Y value of given vertex in the specified shape.

    This only applies to polygon and chain shapes. Shape IDs start at 1 for the first shape up to and including the
    value returned by `get_sprite_num_shapes()`. Vertex IDs start at 1 for the first vertex up to and including the
    value returned by `get_sprite_shape_num_vertices()`.

    :param int sprite_id: The ID of the sprite to check.
    :param int shape_id: The ID of the shape to check.
    :param int vertex: The ID of the vertex to check, vertices start at ID 1.
    :rtype: float
    """
    pass    


def get_sprite_transparency(sprite_id: int) -> int:
    """
    Returns the current transparency mode of the sprite:
     * 0 (TRANSPARENCY_NONE)=no transparency,
     * 1 (TRANSPARENCY_ALPHA)=alpha channel transparency,
     * 2 (TRANSPARENCY_ADDITIVE)=additive blending.

    :param int sprite_id: The ID of the sprite to check.
    :rtype: int
    """
    pass    


def get_sprite_visible(sprite_id: int) -> bool:
    """
    Returns False if the sprite has been set as invisible using `set_sprite_visible()`, otherwise returns True.

    :param int sprite_id: The ID of the sprite to check.
    :rtype: bool
    """
    pass    


def get_sprite_width(sprite_id: int) -> float:
    """
    Returns the current width of the sprite as a floating point value.

    :param int sprite_id: The ID of the sprite to retrieve.
    :rtype: float
    """
    pass    


def get_sprite_x(sprite_id: int) -> float:
    """
    Returns the current X coordinate of the sprite's top left corner as a floating point value.

    :param int sprite_id: The ID of the sprite to retrieve.
    :rtype: float
    """
    pass    


def get_sprite_x_by_offset(sprite_id: int) -> float:
    """
    Returns the current X coordinate of the sprite's current offset point in the world.

    :param int sprite_id: The ID of the sprite to retrieve.
    :rtype: float
    """
    pass    


def get_sprite_x_from_pixel(sprite_id: int, x: int) -> float:
    """
    Converts a pixel point on the sprite's image to the point on the sprite's surface that represents where that pixel
    is.

    For example if a 200x100 pixel image was assigned to a sprite of size 10x10, then calling this command with a pixel
    value of 100 (center of the image) would return 5 (center of the sprite). The sprite must have an image assigned for
    this to work or it will always return 0. The command is not limited by the size of the image or sprite, so in the
    above example a pixel value of 300 or -10 would both be valid.

    :param int sprite_id: The ID of the sprite to check.
    :param int x: The x coordinate of the pixel to check.
    :rtype: float
    """
    pass    


def get_sprite_x_from_world(sprite_id: int, x: Union[float, int], y: Union[float, int]) -> float:
    """
    Converts a point in world coordinates to a point on the sprite.

    This is the opposite of `get_world_x_from_sprite()` and will return values relative to the sprite's center point
    defined with `set_sprite_offset()`. By default this is the center of the sprite. The command is not limited by the
    size of the sprite, it may return values larger than the sprite bounds.

    :param int sprite_id: The ID of the sprite to check.
    :param Union[float, int] x: The X component of the point to convert into sprite coordinates.
    :param Union[float, int] y: The Y component of the point to convert into sprite coordinates.
    :rtype: float
    """
    pass    


def get_sprite_y(sprite_id: int) -> float:
    """
    Returns the current Y coordinate of the sprite's top left corner as a floating point value.

    :param int sprite_id: The ID of the sprite to retrieve.
    :rtype: float
    """
    pass    


def get_sprite_y_by_offset(sprite_id: int) -> float:
    """
    Returns the current Y coordinate of the sprite's current offset point in the world.

    :param int sprite_id: The ID of the sprite to retrieve.
    :rtype: float
    """
    pass    


def get_sprite_y_from_pixel(sprite_id: int, y: int) -> float:
    """
    Converts a pixel point on the sprite's image to the point on the sprite's surface that represents where that pixel
    is.

    For example if a 200x100 pixel image was assigned to a sprite of size 10x10, then calling this command with a pixel
    value of 50 (center of the image) would return 5 (center of the sprite). The sprite must have an image assigned for
    this to work or it will always return 0. The command is not limited by the size of the image or sprite, so in the
    above example a pixel value of 300 or -10 would both be valid.

    :param int sprite_id: The ID of the sprite to check.
    :param int y: The y coordinate of the pixel to check.
    :rtype: float
    """
    pass    


def get_sprite_y_from_world(sprite_id: int, x: Union[float, int], y: Union[float, int]) -> float:
    """
    Converts a point in world coordinates to a point on the sprite.

    This is the opposite of `get_world_y_from_sprite()` and will return values relative to the sprite's center point
    defined with `set_sprite_offset()`. By default this is the center of the sprite. The command is not limited by the
    size of the sprite, it may return values larger than the sprite bounds.

    :param int sprite_id: The ID of the sprite to check.
    :param Union[float, int] x: The X component of the point to convert into sprite coordinates.
    :param Union[float, int] y: The Y component of the point to convert into sprite coordinates.
    :rtype: float
    """
    pass    


def get_world_x_from_sprite(sprite_id: int, x: Union[float, int], y: Union[float, int]) -> float:
    """
    Converts a point on the sprite to world coordinates.

    For example if a 10x10 sprite was rotated by 45 degrees around its center point (at 5x5) then to find the position
    in the world of the sprite's top left corner you would call this command with the values -5,-5, since the values are
    relative to the sprite's center point (defined by `set_sprite_offset()`). The command is not limited by the size of
    the sprite, so in the above example values of 20 or -15 would both be valid.

    :param int sprite_id: The ID of the sprite to check.
    :param Union[float, int] x: The X component of the point on the sprite.
    :param Union[float, int] y: The Y component of the point on the sprite.
    :rtype: float
    """
    pass    


def get_world_y_from_sprite(sprite_id: int, x: Union[float, int], y: Union[float, int]) -> float:
    """
    Converts a point on the sprite to world coordinates.

    For example if a 10x10 sprite was rotated by 45 degrees around its center point (at 5x5) then to find the position
    in the world of the sprite's top left corner you would call this command with the values -5,-5, since the values are
    relative to the sprite's center point (defined by `set_sprite_offset()`). The command is not limited by the size of
    the sprite, so in the above example values of 20 or -15 would both be valid.

    :param int sprite_id: The ID of the sprite to check.
    :param Union[float, int] x: The X component of the point on the sprite.
    :param Union[float, int] y: The Y component of the point on the sprite.
    :rtype: float
    """
    pass    


def load_sprite(filename: str) -> int:
    """
    Creates a sprite in a blank sprite ID with an explicit image to use when rendering, it returns the sprite ID used.

    By default sprites are created with a depth of 10, are sized using the given image as a guide, and positioned at 0,0
    using their top left corner.

    If the assigned image has alpha pixels the sprite is create with a transparency mode of 1, otherwise it uses a
    transparency mode of 0 (opaque) This command takes an image file name and loads it specifically for this sprite,
    this image will be deleted when the sprite is deleted.

    If lots of sprites are going to use the same image you should load the image separately and pass its ID to the
    `create_sprite()` command to save memory.

    :param str filename: The file name of the image to use when drawing this sprite.
    :rtype: int
    """
    pass    


def load_sprite_id(sprite_id: int, filename: str) -> None:
    """
    Creates a sprite in a blank sprite ID with an explicit image to use when rendering, it returns the sprite ID used.

    By default sprites are created with a depth of 10, are sized using the given image as a guide, and positioned at 0,0
    using their top left corner.

    If the assigned image has alpha pixels the sprite is create with a transparency mode of 1, otherwise it uses a
    transparency mode of 0 (opaque) This command takes an image file name and loads it specifically for this sprite,
    this image will be deleted when the sprite is deleted.

    If lots of sprites are going to use the same image you should load the image separately and pass its ID to the
    `create_sprite()` command to save memory.

    :param int sprite_id: The sprite ID to use to reference this sprite later (separate from image IDs, so there can be
        both a sprite 1 and an image 1).
    :param str filename: The file name of the image to use when drawing this sprite.
    :rtype: None
    """
    pass    


def play_sprite(sprite_id: int, fps: Union[float, int] = 10, loop: Union[bool, int] = True,
                from_frame: int = -1, to_frame: int = -1) -> None:
    """
    Begins the animation of a sprite based on the given values.

    Animation speed is based on animation frames per second and is not affected by the drawing frame rate.

    :param int sprite_id: The ID of the sprite to animate.
    :param Union[float, int] fps: Frames per second. The number of frames the sprite should attempt to cycle through
        every second (optional, default 10).
    :param Union[bool, int] loop: The looping mode of the sprite, False equals do not loop, True equals loop forever
        (optional, default True).
    :param int from_frame: The frame to begin at, frames start at 1 (optional, default -1).
    :param int to_frame: The frame to end at, frames end at `get_sprite_frame_count()` (optional, default -1).
    :rtype: None
    """
    pass    


def reset_sprite_uv(sprite_id: int) -> None:
    """
    This command reinstates the normal functionality of UV coordinates after a call to `set_sprite_uv()`.

    :param int sprite_id: The ID of the sprite to modify.
    :rtype: None
    """
    pass    


def resume_sprite(sprite_id: int) -> None:
    """
    Continues the animation of the sprite using the values used to set it up.

    Continues from the current frame rather than starting again at the first frame.

    :param int sprite_id: The ID of the sprite to resume animating.
    :rtype: None
    """
    pass    


def set_sprite_active(sprite_id: int, active: Union[bool, int]) -> None:
    """
    Sets whether this sprite updates its animation and physics every frame, the sprite may be visible or not, which is
    controlled by `set_sprite_visible()`.

    :param int sprite_id: The ID of the sprite to modify.
    :param Union[bool, int] active: Set to True if this sprite should be updated, False if not.
    :rtype: None
    """
    pass    


def set_sprite_additional_image(sprite_id: int, image_id: int, stage: int) -> None:
    """
    Adds additional images to the sprite that can be used with shaders.

    The image set with `set_sprite_image()` is used as texture stage 0, and this command will let you set stages 1 to 7.
    These additional images do not play any part in animation or shape calculations. Note that the sprite will have the
    same UV coordinates for each texture so it is recommended that the images have the same dimensions, or use power of
    2 images to avoid UV conversions on mobile devices where images might be scaled.

    :param int sprite_id: The ID of the sprite to modify.
    :param int image_id: The ID of the image to use for this sprite.
    :param int stage: The index of the texture stage to use, in the range 1 to 7.
    :rtype: None
    """
    pass    


def set_sprite_angle(sprite_id: int, angle: Union[float, int]) -> None:
    """
    Immediately rotates the specified sprite to the given angle in degrees.

    By default sprites rotate around their center, see `set_sprite_offset()` to change this.

    :param int sprite_id: The ID of the sprite to rotate.
    :param Union[float, int] angle: The angle to set the sprite in degrees.
    :rtype: None
    """
    pass    


def set_sprite_angle_rad(sprite_id: int, angle: Union[float, int]) -> None:
    """
    Immediately rotates the specified sprite to the given angle in radians.

    By default sprites rotate around their center, see `set_sprite_offset()` to change this.

    :param int sprite_id: The ID of the sprite to rotate.
    :param Union[float, int] angle: The angle to set the sprite in radians.
    :rtype: None
    """
    pass    


def set_sprite_animation(sprite_id: int, width: int, height: int, count: int) -> None:
    """
    Initialises the sprite animation with frames from its assigned image, based on a frame width and frame height.

    The sprite will use the frame width and frame height to extract images of that size from its assigned image
    beginning in the top left corner and moving from left to right. When it reaches the right hand side of the image it
    will begin again one row down, moving from left to right again until the frame count is reached or it runs out of
    space on the image to look for frames. Storing an animation image on an atlas texture is supported.

    This function is the preferred method of assigning an animation to a sprite as it avoids expensive image changes
    during rendering. However if all your animation frames are separate images you can use the
    `add_sprite_animation_frame()` to add frames from images individually. Using `set_sprite_image()` will clear all
    animation frames you have set here.

    :param int sprite_id: The ID of the sprite to set for animation.
    :param int width: The width of the frames in pixels on the image.
    :param int height: The height of the frames in pixels on the image.
    :param int count: The number of frames the sprite should attempt to retrieve from the image.
    :rtype: None
    """
    pass    


def set_sprite_category_bit(sprite_id: int, category: int, enabled: Union[bool, int],
                            shape_id: Optional[int] = 0) -> None:
    """
    Assigns or removes a sprite from a particular category.

    There are 16 categories that a sprite can belong to, and a sprite can belong to any number at once. This command is
    similar to `set_sprite_category_bits()` except this command sets one category at a time whilst that command sets
    them all at once using a bit mask.

    By default this sets all shapes to the same value, you can set this value on a per shape basis by specifying a
    `shape_id` value greater than 0. Shape IDs start at 1 for the first shape, with `shape_id` 0 meaning apply it to all
    shapes.

    :param int sprite_id: The ID of the sprite to modify.
    :param int category: The category to change, must be between 1 and 16 inclusive.
    :param Union[bool, int] enabled: True to make the sprite a part of this category, False to remove it.
    :param Optional[int] shape_id: The ID of the shape to change, 0 to set all the sprite's shapes to this value.
    :rtype: None
    """
    pass    


def set_sprite_category_bits(sprite_id: int, categories: int, shape_id: Optional[int] = 0) -> None:
    """
    Assigns the sprite to zero or more categories for collision filtering (physics and non physics).

    There are 16 categories, each represented by a single bit in the "categories" parameter, a value of 1 for a bit
    represents that this sprite is a part of that category and 0 that it does not belong to that category. Sprites can
    then be set to collide with certain categories using `set_sprite_collide_bits()` regardless of which categories they
    themselves belong to.

    By default all sprites belong to category 1 (0x0001 the rightmost bit) and collide with all categories (0xffff).

    When the sprite is not setup for physics this test will only apply to the base shape at `shape_id` 1.

    By default this sets all shapes to the same value, you can set this value on a per shape basis by specifying a
    `shape_id` value greater than 0. Shape IDs start at 1 for the first shape, with `shape_id` 0 meaning apply it to all
    shapes.

    :param int sprite_id: The ID of the sprite to modify.
    :param int categories: The bitwise field of categories to assign to this sprite.
    :param Optional[int] shape_id: The ID of the shape to change, 0 to set all the sprite's shapes to this value.
    :rtype: None
    """
    pass    


def set_sprite_collide_bit(sprite_id: int, category: int, enabled: int,
                           shape_id: Optional[int] = 0) -> None:
    """
    Sets or removes a category that this sprite can collide with.

    Sprites are assigned categories using `set_sprite_category_bit()`. There are 16 categories, a value of 1 for that
    category represents that this sprite will collide with sprites from that category and 0 that it will not collide
    with that category, regardless of which category this sprite itself belongs to. By default all sprites belong to
    category 1 and collide with all categories. This command is similar to `set_sprite_category_bits()` except this
    command sets one category at a time whilst that command sets them all at once using a bit mask.

    By default this sets all shapes to the same value, you can set this value on a per shape basis by specifying a
    `shape_id` value greater than 0. Shape IDs start at 1 for the first shape, with `shape_id` 0 meaning apply it to all
    shapes.

    :param int sprite_id: The ID of the sprite to modify.
    :param int category: The category to set collision on or off for this sprite, must be between 1 and 16 inclusive.
    :param int enabled: True to set collision on, False to turn it off for this sprite.
    :param Optional[int] shape_id: The ID of the shape to change, 0 to set all the sprite's shapes to this value.
    :rtype: None
    """
    pass    


def set_sprite_collide_bits(sprite_id: int, categories: int, shape_id: Optional[int] = 0) -> None:
    """
    Uses a bitwise mask to determine which sprite categories this sprite can collide with.

    Sprites are assigned categories using `set_sprite_category_bits()`. There are 16 categories, each represented by a
    single bit in the "mask" parameter, a value of 1 for a bit represents that this sprite will collide with sprites
    from that category and 0 that it will not collide with that category, regardless of which category this sprite
    itself belongs to. By default all sprites belong to category 1 (0x0001 the rightmost bit) and collide with all
    categories (0xffff).

    When the sprite is not setup for physics this test will only apply to the base shape at `shape_id` 1.

    By default this sets all shapes to the same value, you can set this value on a per shape basis by specifying a
    `shape_id` value greater than 0. Shape IDs start at 1 for the first shape, with `shape_id` 0 meaning apply it to all
    shapes.

    :param int sprite_id: The ID of the sprite to modify.
    :param int categories: The bitwise mask of categories this sprite can collide with during physics calculations.
    :param Optional[int] shape_id: The ID of the shape to change, 0 to set all the sprite's shapes to this value.
    :rtype: None
    """
    pass    


def set_sprite_color(sprite_id: int, red: int, green: int, blue: int, alpha: int) -> None:
    """
    Set the color of a sprite.

    :param int sprite_id: The ID of the sprite to modify.
    :param int red: The red component of the color.
    :param int green: The green component of the color.
    :param int blue: The blue component of the color.
    :param int alpha: The alpha component of the color. The acceptable range is from 0 to 255. When a value of 0 is used
        the sprite will be invisible. When a value of 255 is used the sprite will be fully opaque.
    :rtype: None
    """
    pass    


def set_sprite_color_alpha(sprite_id: int, alpha: int) -> None:
    """
    Set the alpha component of a sprite.

    :param int sprite_id: The ID of the sprite to modify.
    :param int alpha: The alpha component of the color. The acceptable range is from 0 to 255. When a value of 0 is used
        the sprite will be invisible. When a value of 255 is used the sprite will be fully opaque.
    :rtype: None
    """
    pass    


def set_sprite_color_blue(sprite_id: int, blue: int) -> None:
    """
    Set the blue component of a sprite.

    :param int sprite_id: The ID of the sprite to modify.
    :param int blue: The blue component of the color. The acceptable range is from 0 to 255.
    :rtype: None
    """
    pass    


def set_sprite_color_green(sprite_id: int, green: int) -> None:
    """
    Set the green component of a sprite.

    :param int sprite_id: The ID of the sprite to modify.
    :param int green: The green component of the color. The acceptable range is from 0 to 255.
    :rtype: None
    """
    pass    


def set_sprite_color_red(sprite_id: int, red: int) -> None:
    """
    Set the red component of a sprite.

    :param int sprite_id: The ID of the sprite to modify.
    :param int red: The red component of the color. The acceptable range is from 0 to 255.
    :rtype: None
    """
    pass    


def set_sprite_depth(sprite_id: int, depth: int) -> None:
    """
    Sets the draw order for the sprite between 0-10000, 0 being the front of the screen, 10000 being the back.

    Anything above 10000 will result in the sprite being clipped from view. By default sprites are at depth 10. If two
    sprites occupy the same depth then the order they are drawn is undefined unless `set_sort_created()` is used to
    true, in which case sprites at the same depth will be drawn in the order they were created. For maximum performance
    it is recommended that every sprite has its own depth value unless the order they are drawn is not important, for
    example physics sprites that won't normally overlap. Note that if you are not using any 3D objects and you are using
    sprite depths greater then 5000 you should use `set_global_3d_depth()` to 10000 to improve performance (essentially
    bringing all sprites to the front of the 3D renderer).

    :param int sprite_id: The ID of the sprite to modify.
    :param int depth: The depth this sprite should be drawn at.
    :rtype: None
    """
    pass    


def set_sprite_flip(sprite_id: int, horizontal: Union[bool, int], vertical: Union[bool,
                    int]) -> None:
    """
    Flips the sprite either horizontally or vertically, (or both).

    This merely modifies the UV coordinates so that the sprite appears flipped, it does not adjust position or angle
    values. Note that flipping in both horizontal and vertical directions at the same time gives the appearance of
    rotation by 180 degrees.

    :param int sprite_id: The ID of the sprite to modify.
    :param Union[bool, int] horizontal: True to flip to sprite horizontally left to right, False to keep the sprite
        normal.
    :param Union[bool, int] vertical: True to flip to sprite vertically top to bottom, False to keep the sprite normal.
    :rtype: None
    """
    pass    


def set_sprite_frame(sprite_id: int, frame: int) -> None:
    """
    Sets the sprite to a specific frame, frames start at 1 and end at `get_sprite_frame_count()`.

    :param int sprite_id: The ID of the sprite to modify.
    :param int frame: The ID of the frame this sprite should change to, has an immediate effect.
    :rtype: None
    """
    pass    


def set_sprite_group(sprite_id: int, group: int, shape_id: Optional[int] = 0) -> None:
    """
    Assigns this sprite to a group for filtering collisions (physics or non physics).

    In physics, sprites of the same positive group ID will always collide, whilst those that share the same negative
    group ID will never collide. Those with a group ID of zero (default), or differing group IDs move on to the category
    filter check.

    When the sprite is not setup for physics this test will only apply to the base shape at `shape_id` 1.

    By default this sets all shapes to the same value, you can set this value on a per shape basis by specifying a
    `shape_id` value greater than 0. Shape IDs start at 1 for the first shape, with `shape_id` 0 meaning apply it to all
    shapes.

    :param int sprite_id: The ID of the sprite to modify.
    :param int group: The group ID to assign to this sprite.
    :param Optional[int] shape_id: The ID of the shape to change, 0 to set all the sprite's shapes to this value.
    :rtype: None
    """
    pass    


def set_sprite_image(sprite_id: int, image_id: int, update_shape: Optional[Union[bool,
                     int]] = None) -> None:
    """
    Change the sprite image to a new loaded image.

    If the new image has a different size or shape from the old image the sprite may look distorted as a result, you can
    fix this by resetting the sprite dimensions using `set_sprite_size()`. If the sprite is animated you may also need
    to call `set_sprite_animation()` again.

    In the case of circle and polygon sprites you may set whether the sprite uses this new image to change its collision
    shape. Box shapes are not affected by image changes. Using this command will clear any animation frames you have set
    with any of the sprite animation commands.

    :param int sprite_id: The ID of the sprite to modify.
    :param int image_id: The ID of the image to use for this sprite.
    :param Optional[Union[bool, int]] update_shape: True to change the collision shape of this sprite to match the new
        image.
    :rtype: None
    """
    pass    


def set_sprite_offset(sprite_id: int, x: Union[float, int], y: Union[float, int]) -> None:
    """
    The offset point is the point that the sprite will rotate around, with (0,0) being the top left corner and
    (width,height) being the bottom right corner.

    The offset can also be used to position the sprite using `set_sprite_position_by_offset()`, whilst
    `set_sprite_position()` will always position the sprite using its top left corner. If the sprite is scaled remember
    to take the scale into account, a sprite created as 10 by 10 units wide scaled by 0.5 will have a bottom right
    corner at 5,5 so to position the offset in the center would mean placing it at 2.5,2.5, when the sprite is scale
    back up the offset point will scale with it to maintain its relative position.

    This command forces the recalculation of the sprite's shape due to a new center point, additional shapes are not
    recalculated so will become distorted from their original definition. It is not recommended calling this command on
    a sprite already setup for physics. Change the offset before applying physics or additional shapes.

    :param int sprite_id: The ID of the sprite to modify.
    :param Union[float, int] x: The X distance from the top left corner to offset the rotation point.
    :param Union[float, int] y: The Y distance from the top left corner to offset the rotation point.
    :rtype: None
    """
    pass    


def set_sprite_physics_allow_sleep(sprite_id: int, sleep: int) -> None:
    """
    Sets whether the sprite is allowed to sleep.

    :param int sprite_id: The ID of the sprite to modify.
    :param int sleep: 0 to disable sleeping, 1 to allow it.
    :rtype: None
    """
    pass    


def set_sprite_physics_angular_damping(sprite_id: int, damping: Union[float, int]) -> None:
    """
    Sets some damping on the sprite's angular movement which may simulate something like wind resistance.

    A value of 0 represents no damping, a value of 0.75 would reduce the angular velocity vector by half every second
    when running at 60 frames per second.

    Higher values will reduce the spin more quickly.

    :param int sprite_id: The ID of the sprite to modify.
    :param Union[float, int] damping: The new damping value.
    :rtype: None
    """
    pass    


def set_sprite_physics_angular_impulse(sprite_id: int, impulse: Union[float, int]) -> None:
    """
    Similar to a torque force, but applied only once.

    Whilst forces are applied continuously over time gradually influencing a sprite's velocity, an impulse simulates the
    sprite being hit suddenly and immediately changes the angular velocity with the equivalent power of a similar torque
    force applied for 1 second.

    If the sprite is constrained by surrounding objects it may not rotate unless the impulse is large enough to move
    those objects as well.

    The reaction to an impulse is relative to the object's size, large objects will rotate slower than small objects
    given the same impulse.

    :param int sprite_id: The ID of the sprite to modify.
    :param Union[float, int] impulse: The size of the force to apply to the sprite's rotation. may be negative.
    :rtype: None
    """
    pass    


def set_sprite_physics_angular_velocity(sprite_id: int, velocity: Union[float, int]) -> None:
    """
    Immediately sets the sprite's rotational velocity to the given direction.

    This is an abrupt change that might not look right during the physics simulation, torque and angular impulses are
    the preferred approach to influencing angular velocity.

    :param int sprite_id: The ID of the sprite to modify.
    :param Union[float, int] velocity: The new angular velocity.
    :rtype: None
    """
    pass    


def set_sprite_physics_can_rotate(sprite_id: int, enabled: Union[bool, int]) -> None:
    """
    Sets whether the physics simulation is allowed to rotate the sprite.

    :param int sprite_id: The ID of the sprite to modify.
    :param Union[bool, int] enabled: True to allow rotation, False to prevent it.
    :rtype: None
    """
    pass    


def set_sprite_physics_com(sprite_id: int, x: Union[float, int], y: Union[float, int]) -> None:
    """
    Sets the center of mass (COM) relative to the sprite's offset.

    By default the AGK calculates the best location for the COM based on the size and location of all shapes attached to
    the sprite. Setting it to 0,0 will put the COM on the sprite's offset point (and center of rotation). If the COM is
    very different from the offset point the sprite may seem unstable as it will behave like an unbalanced spinning top.

    :param int sprite_id: The ID of the sprite to modify.
    :param Union[float, int] x: The x coordinate of the center of mass.
    :param Union[float, int] y: The y coordinate of the center of mass.
    :rtype: None
    """
    pass    


def set_sprite_physics_damping(sprite_id: int, damping: Union[float, int]) -> None:
    """
    Sets some damping on the sprite's linear movement which may simulate something like wind resistance.

    A value of 0 represents no damping, a value of 0.75 would reduce the velocity vector by half every second when
    running at 60 frames per second.

    Higher values will reduce the speed more quickly.

    :param int sprite_id: The ID of the sprite to modify.
    :param Union[float, int] damping: The new damping value.
    :rtype: None
    """
    pass    


def set_sprite_physics_delete(sprite_id: int) -> None:
    """
    Turns off physics for this sprite and deletes all associated physics settings for this sprite.

    You can use this to change the mode or shape of a sprite but doing so regularly can affect the performance of the
    application.

    :param int sprite_id: The ID of the sprite to modify.
    :rtype: None
    """
    pass    


def set_sprite_physics_density(sprite_id: int, density: Union[float, int],
                               shape_id: Optional[int] = 0) -> None:
    """
    Sets the density value to use for the given sprite shape during physics calculations.

    Default value is 1.0. This affects the mass calculation for the given size of the sprite. This command will
    recalculate the mass and center of mass for this sprite. Use a `shape_id` of 0 to apply this density to all shapes
    or specify a shape ID greater than 0 to apply it only to that shape. Shape IDs start at 1 for the first shape.

    :param int sprite_id: The ID of the sprite to modify.
    :param Union[float, int] density: The new density value, default is 1.0.
    :param Optional[int] shape_id: The ID of the shape to change, 0 to apply the value to all shapes.
    :rtype: None
    """
    pass    


def set_sprite_physics_force(sprite_id: int, x: Union[float, int], y: Union[float, int],
                             force_x: Union[float, int], force_y: Union[float, int]) -> None:
    """
    Applies a force to the sprite that will last for this frame only, to continue applying this force you must keep
    calling this function.

    The force consists of a point in world coordinates and a direction, if the point and direction are not in line with
    the sprite's offset point then it will result in a rotation of the sprite as it is moved by the force. The length of
    the force vector determines its strength. If the sprite is constrained by surrounding objects it may not move unless
    the force is large enough to move those objects as well.

    Forces apply acceleration to an object relative to its mass, heavy objects will move less than light objects with
    the same force applied to them.

    :param int sprite_id: The ID of the sprite to modify.
    :param Union[float, int] x: The X coordinate of the force position in world coordinates.
    :param Union[float, int] y: The Y coordinate of the force position in world coordinates.
    :param Union[float, int] force_x: The X component of the force direction.
    :param Union[float, int] force_y: The Y component of the force direction.
    :rtype: None
    """
    pass    


def set_sprite_physics_friction(sprite_id: int, friction: Union[float, int],
                                shape_id: Optional[int] = 0) -> None:
    """
    Sets the friction value to use for this sprite during physics calculations.

    Should be in the range 0 to 1. By default this sets all the shapes assigned to this sprite to the same value, you
    can instead set it on a per shape basis by specifying a `shape_id` greater than 0. Shape IDs start at 1 for the
    first shape, with 0 meaning apply it to all shapes.

    :param int sprite_id: The ID of the sprite to modify.
    :param Union[float, int] friction: The new friction value.
    :param Optional[int] shape_id: The ID of the shape to change, 0 to apply the value to all shapes.
    :rtype: None
    """
    pass    


def set_sprite_physics_gravity_scale(sprite_id: int, scale: Union[float, int]) -> None:
    """
    Sets the gravity scale for the sprite.

    :param int sprite_id: The ID of the sprite to modify.
    :param Union[float, int] scale: scaling value for the gravity.
    :rtype: None
    """
    pass    


def set_sprite_physics_impulse(sprite_id: int, x: Union[float, int], y: Union[float, int],
                               impulse_x: Union[float, int], impulse_y: Union[float, int]) -> None:
    """
    Similar to a force but applied only once.

    Whilst forces are applied continuously over time gradually influencing a sprite's velocity, an impulse simulates the
    sprite being hit suddenly and immediately changes the velocity with the equivalent power of a similar force applied
    for 1 second.

    The impulse consists of a point in world coordinates and a direction, if the point and direction are not in line
    with the sprite's offset point then it will result in a rotation of the sprite as it is moved by the impulse. The
    length of the impulse vector determines it strength. If the sprite is constrained by surrounding objects it will
    impart the impulse onto those objects and may not move itself.

    Impulses apply acceleration to an object relative to its mass, heavy objects will move less than light objects with
    the same impulse applied to them.

    :param int sprite_id: The ID of the sprite to modify.
    :param Union[float, int] x: The X coordinate of the impulse position in world coordinates.
    :param Union[float, int] y: The Y coordinate of the impulse position in world coordinates.
    :param Union[float, int] impulse_x: The X component of the impulse direction.
    :param Union[float, int] impulse_y: The Y component of the impulse direction.
    :rtype: None
    """
    pass    


def set_sprite_physics_initially_awake(sprite_id: int, awake: int) -> None:
    """
    Sets whether the sprite is awake upon creation.

    :param int sprite_id: The ID of the sprite to modify.
    :param int awake: 0 for sleep, 1 for awake.
    :rtype: None
    """
    pass    


def set_sprite_physics_is_bullet(sprite_id: int, enabled: Union[bool, int]) -> None:
    """
    Set this to true if the sprite is likely to be moving very fast, like a bullet, as it will then be checked more
    thoroughly for collision with other dynamic sprites, using this unnecessarily will affect performance.

    This is called Continuous Collision Detection (CCD) and applies automatically to collision checks between this
    sprite and static objects. This command turns CCD on for collision checks between this sprite and dynamic objects.
    This will not work if global CCD is turned off with `set_physics_ccd()`.

    :param int sprite_id: The ID of the sprite to modify.
    :param Union[bool, int] enabled: True to set this sprite as a bullet, False to turn it off.
    :rtype: None
    """
    pass    


def set_sprite_physics_is_sensor(sprite_id: int, enabled: Union[bool, int],
                                 shape_id: Optional[int] = 0) -> None:
    """
    Set this to True to make the sprite a sensor object.

    Physics sensors detect collisions and contacts but do not respond to them, they also do not affect anything that
    hits them. Their only purpose is to detect collisions. If you apply this to a dynamic body it will not collide with
    anything and most likely fall through the floor and continue falling forever, it is still affected by forces.

    By default this sets all shapes to the same value, you can set this value on a per shape basis by specifying a
    `shape_id` value greater than 0. Shape IDs start at 1 for the first shape, with `shape_id` 0 meaning apply it to all
    shapes.

    :param int sprite_id: The ID of the sprite to modify.
    :param Union[bool, int] enabled: True to set this sprite as a sensor, False to make it a normal physics object.
    :param Optional[int] shape_id: The ID of the shape to change, 0 to set all the sprite's shapes to this value.
    :rtype: None
    """
    pass    


def set_sprite_physics_mass(sprite_id: int, mass: Union[float, int]) -> None:
    """
    This command overrides the calculated mass for this sprite and sets it to a value of your choice, in kilograms.

    Setting this too low or too high can cause an unstable simulation, especially if a very light object meets a very
    heavy object. The value range you should use depends on your chosen physics scale.

    Internally a default mass per object is calculated based on its size. A 1m x 1m box would weigh 1 kg, so because of
    the default physics scale of 5, a 5 x 5 box in virtual units weighs 1 kg.

    :param int sprite_id: The ID of the sprite to modify.
    :param Union[float, int] mass: The new mass value.
    :rtype: None
    """
    pass    


def set_sprite_physics_off(sprite_id: int) -> None:
    """
    Temporarily turns off physics for this sprite, it will no longer move or react to collisions or forces.

    Use `set_sprite_physics_on()` to reactivate the sprite.

    :param int sprite_id: The ID of the sprite to modify.
    :rtype: None
    """
    pass    


def set_sprite_physics_on(sprite_id: int, mode: int) -> None:
    """
    Sets the sprite up for automatic collision using the built physics system.

    Once you have set a sprite to be controlled by physics you should use `set_sprite_position()` and
    `set_sprite_angle()` sparingly as these will interrupt the physics motion of the sprite. You can also use the
    `set_sprite_physics_velocity()` and `set_sprite_physics_angular_velocity()` to change the speed and direction of a
    sprite, but again these will interfere with the physics motion of the sprite. If you wish to influence the position
    or rotation of a physics sprite you should use the force and torque (rotational force) functions where possible,
    these will maintain smooth physics motion.

    The mode parameter lets you choose how the sprite should behave in the physics world. Static means it will never
    move or rotate, dynamic means it will respond to all collisions and forces it encounters, including gravity and
    collisions with static objects. Kinematic is a special case which can be thought of as a moving static body, it will
    not respond to collisions or forces and will continue at its specified velocity forever, but dynamic items will
    respond to it and effectively be pushed out of the way.

    The physics shape used is determined by the `set_sprite_shape()` command, which must be called before this command
    and is expensive to change for circle and polygon shapes as they rebuild a shape from the pixels of the sprite's
    image.

    Once you have called this command to determine the mode of the sprite, further calls will ignore the mode values and
    it will only reactivate a sprite that has been turned off, as the mode cannot be changed whilst the sprite is in the
    physics system. If you wish to change the mode of a sprite call `set_sprite_physics_delete()`, which will delete all
    its physics settings, then call `set_sprite_physics_on()` with the new mode. But doing this too often will slow the
    system down.

    All physics sprites should be world sprites (not fixed to the screen), unless `set_view_offset()` is set to 0,0 in
    which case this doesn't matter. Otherwise debug shapes will not line up and sprites from different view spaces will
    not interact properly.

    :param int sprite_id: The ID of the sprite to modify.
    :param int mode: The physics mode to use for this sprite, 1 (PHYSICS_MODE_STATIC)=static, 2
        (PHYSICS_MODE_DYNAMIC)=dynamic, 3 (PHYSICS_MODE_KINEMATIC)=kinematic.
    :rtype: None
    """
    pass    


def set_sprite_physics_restitution(sprite_id: int, restitution: Union[float, int],
                                   shape_id: Optional[int] = 0) -> None:
    """
    Sets the restitution (bounciness) value to use for this sprite during physics calculations.

    Should be in the range 0 to 1. Values greater than 1 will result in the sprite gaining energy from collisions which
    can cause an unstable result. By default this sets all the shapes assigned to this sprite to the same value, you can
    instead set it on a per shape basis by specifying a `shape_id` greater than 0. Shape IDs start at 1 for the first
    shape, with 0 meaning apply it to all shapes.

    :param int sprite_id: The ID of the sprite to modify.
    :param Union[float, int] restitution: The new restitution value.
    :param Optional[int] shape_id: The ID of the shape to change, 0 to apply the value to all shapes.
    :rtype: None
    """
    pass    


def set_sprite_physics_torque(sprite_id: int, torque: Union[float, int]) -> None:
    """
    Applies a torque to the rotation of the sprite, similar to applying a force to its movement.

    If the sprite is constrained by surrounding objects it may not rotate unless the torque is large enough to move
    those objects as well. The torque will last for this frame only, to continue applying this torque you must keep
    calling this function.

    The reaction to a torque force is relative to the object's size, large objects will rotate slower than small objects
    given the same torque.

    :param int sprite_id: The ID of the sprite to modify.
    :param Union[float, int] torque: The size of the force to apply to the sprite's rotation. may be negative.
    :rtype: None
    """
    pass    


def set_sprite_physics_velocity(sprite_id: int, x: Union[float, int], y: Union[float, int]) -> None:
    """
    Immediately sets the sprite's velocity to the given direction.

    This is an abrupt change that might not look right during the physics simulation, forces and impulses are the
    preferred approach to influencing velocity.

    :param int sprite_id: The ID of the sprite to modify.
    :param Union[float, int] x: The x component of the new velocity.
    :param Union[float, int] y: The y component of the new velocity.
    :rtype: None
    """
    pass    


def set_sprite_position(sprite_id: int, x: Union[float, int], y: Union[float, int]) -> None:
    """
    Immediately positions the specified sprite to the given X,Y world coordinates.

    The default world coordinate system has 0,0 as the top left corner, and 100,100 as the bottom right hand corner of
    the screen (this can be changed using `set_virtual_resolution()`). This function always positions the sprite using
    its top left corner, regardless of the current sprite offset. The top left corner used to position the sprite does
    not rotate with the sprite, for example as the sprite rotates around its center the imaginary top left corner
    remains fixed and the sprite's position value does not change.

    :param int sprite_id: The ID of the sprite to position.
    :param Union[float, int] x: The X coordinate to position the sprite, can use decimal values.
    :param Union[float, int] y: The Y coordinate to position the sprite, can use decimal values.
    :rtype: None
    """
    pass    


def set_sprite_position_by_offset(sprite_id: int, x: Union[float, int], y: Union[float,
                                  int]) -> None:
    """
    Immediately positions the specified sprite to the given X,Y world coordinates.

    The default world coordinate system has 0,0 as the top left corner, and 100,100 as the bottom right hand corner of
    the screen (this can be changed using `set_virtual_resolution()`).

    This function always positions the sprite using its current offset. For example if the current offset is the center
    of the sprite this command will place the center of the sprite at the given coordinates.

    :param int sprite_id: The ID of the sprite to position.
    :param Union[float, int] x: The X coordinate to position the sprite, can use decimal values.
    :param Union[float, int] y: The Y coordinate to position the sprite, can use decimal values.
    :rtype: None
    """
    pass    


def set_sprite_scale(sprite_id: int, x: Union[float, int], y: Union[float, int]) -> None:
    """
    Sets the sprite scale as an absolute multiple of its original size.

    For example a scale value of 2 would double the sprite's size whilst a value of 1 will return it to its original
    size. This function scales from the top left corner so any increase in size will keep the top and left sides
    stationary whilst the bottom and right sides move. The sprites center of rotation (its current offset point) will
    scale with the sprite. To scale from the offset point use `set_sprite_scale_by_offset()`.

    :param int sprite_id: The ID of the sprite to modify.
    :param Union[float, int] x: The value to scale the sprite in the X direction.
    :param Union[float, int] y: The value to scale the sprite in the Y direction.
    :rtype: None
    """
    pass    


def set_sprite_scale_by_offset(sprite_id: int, x: Union[float, int], y: Union[float, int]) -> None:
    """
    Sets the sprite scale as an absolute multiple of its original size.

    For example a scale value of 2 would double the sprite's size whilst a value of 1 will return it to its original
    size. This function scales from the sprite's center of rotation (its current offset point) so any increase in size
    will keep the offset point stationary whilst all four sides expand away from it. To scale from the top left corner
    use `set_sprite_scale()`.

    :param int sprite_id: The ID of the sprite to modify.
    :param Union[float, int] x: The value to scale the sprite in the X direction.
    :param Union[float, int] y: The value to scale the sprite in the Y direction.
    :rtype: None
    """
    pass    


def set_sprite_scissor(sprite_id: int, x1: Union[float, int], y1: Union[float, int],
                       x2: Union[float, int], y2: Union[float, int]) -> None:
    """
    Clips the sprite to the specified world coordinates when drawn.

    Use the values 0,0,0,0 to turn off the sprite scissor.

    :param int sprite_id: The ID of the sprite to modify.
    :param Union[float, int] x1: The x coordinate of the top left corner of the box to use as a clip boundary.
    :param Union[float, int] y1: The y coordinate of the top left corner of the box to use as a clip boundary.
    :param Union[float, int] x2: The x coordinate of the bottom right corner of the box to use as a clip boundary.
    :param Union[float, int] y2: The y coordinate of the bottom right corner of the box to use as a clip boundary.
    :rtype: None
    """
    pass    


def set_sprite_shader(sprite_id: int, shader_id: int) -> None:
    """
    Sets the shader used to draw this sprite, loaded with `load_sprite_shader()` or `load_shader()`.

    By default sprites are assigned an internal shader that can handle 1 texture and a color. If you use a shader ID of
    0 the sprite is assigned the internal shader.

    :param int sprite_id: The ID of the sprite to modify.
    :param int shader_id: The ID of the shader to use.
    :rtype: None
    """
    pass    


def set_sprite_shape(sprite_id: int, shape: int, shape_id: Optional[int] = 0) -> None:
    """
    Sets the current shape for use in collision detection, hit testing, and physics.

    A shape can be set without turning physics on, and by default all sprites are set to use the box shape, which is the
    fastest to setup. If you select no shape (0) then any existing shape will be deleted, and hit testing will use the
    sprite dimensions instead. Commands that require a shape such as `get_sprite_collision()` will generate a box shape
    for the sprite if none exists. The shape parameter lets you define what type of bounding box the system should use
    to detect collisions. Circle will create a perfect circle centered on the sprite's rotation point and big enough to
    enclose the sprite's visible pixels. Box will create a box around the edges of the sprite, without regard to whether
    pixels are visible or not. Polygon will create a close fitting convex polygon around the visible pixels of a sprite,
    with a visible pixel being defined as one with an alpha value greater than 128.

    This function will not work on dummy sprites as there is no image to use when calculating a shape, in these cases
    shapes must be specified manually using `set_sprite_shape_box()`, `set_sprite_shape_circle()`, or
    `set_sprite_shape_polygon()`.

    By default, setting a shape removes all other shapes assigned to the sprite and replaces it with this one. You can
    set shapes individually by specifying a `shape_id` greater than 0. Shape IDs start at 1 for the first shape, with 0
    meaning delete all existing shapes before creating a new one at ID 1. This command only changes existing shapes, by
    default all sprites have a base shape at ID 1. You can add additional shapes by using `add_sprite_shape_box()`,
    `add_sprite_shape_chain()`, `add_sprite_shape_circle()`, and `add_sprite_shape_polygon()`.

    :param int sprite_id: The ID of the sprite to modify.
    :param int shape: The shape to use for this sprite, 0 (SHAPE_NONE)=no shape, 1 (SHAPE_CIRCLE)=circle, 2
        (SHAPE_BOX)=box, 3 (SHAPE_POLYGON)=polygon.
    :param Optional[int] shape_id: The ID of the shape to change, first shape is ID 1, 0=delete existing shapes and
        replace them with this new one.
    :rtype: None
    """
    pass    


def set_sprite_shape_box(sprite_id: int, x1: Union[float, int], y1: Union[float, int],
                         x2: Union[float, int], y2: Union[float, int], angle: Union[float, int],
                         shape_id: Optional[int] = 0) -> None:
    """
    Overrides the current auto generated shape for use in collision detection, hit testing, and physics.

    A shape can be set without turning physics on, and by default all sprites are set to use the box shape, which is the
    fastest to setup. The box is defined by specifying its top left and bottom right coordinates in sprite space,
    relative to the offset of the sprite, by default this is the center of the sprite. For example if the current sprite
    offset was 0,0 the top left box corner would be 0,0, but if the sprite offset was the middle of the sprite (default)
    the top left corner would be -width/2,-height/2. You may also specify an angle to offset the box relative to the
    current sprite rotation.

    By default, setting a shape removes all other shapes assigned to the sprite and replaces it with this one. You can
    set shapes individually by specifying a `shape_id` greater than 0. Shape IDs start at 1 for the first shape, with 0
    meaning delete all existing shapes before creating a new one at ID 1. This command only changes existing shapes, by
    default all sprites have a base shape at ID 1. You can add additional shapes by using `add_sprite_shape_box()`,
    `add_sprite_shape_chain()`, `add_sprite_shape_circle()`, and `add_sprite_shape_polygon()`.

    :param int sprite_id: The ID of the sprite to modify.
    :param Union[float, int] x1: The x coordinate of the top left corner of the new box in sprite space.
    :param Union[float, int] y1: The y coordinate of the top left corner of the new box in sprite space.
    :param Union[float, int] x2: The x coordinate of the bottom right corner of the new box in sprite space.
    :param Union[float, int] y2: The Y coordinate of the bottom right corner of the new box in sprite space.
    :param Union[float, int] angle: The angle of the box in radians.
    :param Optional[int] shape_id: The ID of the shape to change, first shape is ID 1, 0=delete existing shapes and
        replace them with this new one.
    :rtype: None
    """
    pass    


def set_sprite_shape_chain(sprite_id: int, total_points: int, point: int, loop: Union[bool, int],
                           x: Union[float, int], y: Union[float, int],
                           shape_id: Optional[int] = 0) -> None:
    """
    Overrides the current auto generated shape for use in physics.  Normal sprite collision and hit testing does not
    work with the chain shape, it is only for physics.

    A shape can be set without turning physics on, and by default all sprites are set to use the box shape, which is the
    fastest to setup. The chain is defined by a set of points (at least 2) relative to the current sprite's offset. For
    example, a point of 0,0 would be centered on the sprite's offset point, any other value will be offset from this
    point. Chains are rigid and can be used to create hollow concave polygons, or 2D terrains. Set the loop parameter to
    True to join to two ends of the chain together creating a hollow polygon. Points are defined one at a time by
    calling this command multiple times, with `index` starting at 0. Once the `index` equals `total_points`-1 then the
    shape will be created using the previously defined points. Once you start defining points you must complete the
    process by reaching `index`=`total_points`-1 before defining points for any other shape.

    Using a `shape_id` of 0 removes all other shapes assigned to the sprite and replaces it with this one. You can set
    shapes individually by specifying a `shape_id` greater than 0. Shape IDs start at 1 for the first shape. This
    command only changes existing shapes, by default all sprites have a base shape at ID 1. You can add additional
    shapes by using `add_sprite_shape_box()`, `add_sprite_shape_chain()`, `add_sprite_shape_circle()`, and
    `add_sprite_shape_polygon()`.

    :param int sprite_id: The ID of the sprite to modify.
    :param int total_points: The number of points to use in the chain, min 2, no maximum.
    :param int point: The index of the point to set, if it equals `total_points`-1 then the shape will be created.
    :param Union[bool, int] loop: True to join the two ends of the chain together, False to leave them unconnected.
    :param Union[float, int] x: X coordinate of the polygon to be added.
    :param Union[float, int] y: Y coordinate of the polygon to be added.
    :param Optional[int] shape_id: The ID of the shape to change, first shape is ID 1, 0=delete existing shapes and
        replace them with this new one.
    :rtype: None
    """
    pass    


def set_sprite_shape_circle(sprite_id: int, x: Union[float, int], y: Union[float, int],
                            radius: Union[float, int], shape_id: Optional[int] = 0) -> None:
    """
    Overrides the current auto generated shape for use in collision detection, hit testing, and physics.

    A shape can be set without turning physics on, and by default all sprites are set to use the box shape, which is the
    fastest to setup. The circle is defined by specifying its center point relative to the sprite's current offset and a
    radius. For example, if the circle was to be centered on the sprite's offset point it would be specified at position
    0,0. Any other value will offset the circle from the sprite. The radius is defined in x coordinates, due to world
    coordinates not necessarily representing the size of items on screen (e.g. 10 units in X may not be the same
    apparent size as 10 units in Y).

    By default, setting a shape removes all other shapes assigned to the sprite and replaces it with this one. You can
    set shapes individually by specifying a `shape_id` greater than 0. Shape IDs start at 1 for the first shape, with 0
    meaning delete all existing shapes before creating a new one at ID 1. This command only changes existing shapes, you
    can add additional shapes by using `add_sprite_shape_box()`, `add_sprite_shape_chain()`,
    `add_sprite_shape_circle()`, and `add_sprite_shape_polygon()`.

    :param int sprite_id: The ID of the sprite to modify.
    :param Union[float, int] x: The x coordinate of the center of the circle in sprite space.
    :param Union[float, int] y: The y coordinate of the center of the circle in sprite space.
    :param Union[float, int] radius: The radius of the circle.
    :param Optional[int] shape_id: The ID of the shape to change, first shape is ID 1, 0=delete existing shapes and
        replace them with this new one.
    :rtype: None
    """
    pass    


def set_sprite_shape_polygon(sprite_id: int, total_points: int, point: int, x: Union[float, int],
                             y: Union[float, int], shape_id: Optional[int] = 0) -> None:
    """
    Overrides the current auto generated shape for use in collision detection, hit testing, and physics.

    A shape can be set without turning physics on, and by default all sprites are set to use the box shape, which is the
    fastest to setup. The polygon is defined by a set of points (between 2 and 12) relative to the current sprite's
    offset. For example, a point of 0,0 would be centered on the sprite's offset point, any other value will be offset
    from this point. Points are defined one at a time by calling this command multiple times, with `index` starting at
    0. Once the `index` equals `total_points`-1 then the shape will be created using the previously defined points. Once
    you start defining points you must complete the process by reaching `index`=`total_points`-1 before defining points
    for any other shape.

    By default, setting a shape removes all other shapes assigned to the sprite and replaces it with this one. You can
    set shapes individually by specifying a `shape_id` greater than 0. Shape IDs start at 1 for the first shape, with 0
    meaning delete all existing shapes before creating a new one at ID 1. This command only changes existing shapes, by
    default all sprites have a base shape at ID 1. You can add additional shapes by using `add_sprite_shape_box()`,
    `add_sprite_shape_chain()`, `add_sprite_shape_circle()`, and `add_sprite_shape_polygon()`.

    :param int sprite_id: The ID of the sprite to modify.
    :param int total_points: The number of points to use in the polygon, min 2, max 12.
    :param int point: The index of the point to set, if it equals `total_points`-1 then the shape will be created.
    :param Union[float, int] x: X coordinate of the polygon to be added.
    :param Union[float, int] y: Y coordinate of the polygon to be added.
    :param Optional[int] shape_id: The ID of the shape to change, first shape is ID 1, 0=delete existing shapes and
        replace them with this new one.
    :rtype: None
    """
    pass    


def set_sprite_size(sprite_id: int, width: Union[float, int], height: Union[float, int]) -> None:
    """
    Sets the sprite to a new width and height.

    In the default coordinate system a width and height of 100,100 would fill the entire drawable screen (this can be
    changed using `set_virtual_resolution()`). If either width or height is set, with the other set to -1, the -1 value
    will be recalculated to maintain the image's aspect ratio so it doesn't look stretched. If both width AND height are
    set to -1, then the sprite will take on the width of the assigned image and calculate its height so it isn't
    stretched. This function recalculates the sprite's collision shape, which can be a costly process for circle and
    polygon shapes. A more efficient way to change the size of a sprite is to scale it using the `set_sprite_scale()`
    function. This function resets the scale of the sprite.

    :param int sprite_id: The ID of the sprite to retrieve.
    :param Union[float, int] width: The width to use for the sprite, use -1 to have this value calculated.
    :param Union[float, int] height: The height to use for the sprite, use -1 to have this value calculated.
    :rtype: None
    """
    pass    


def set_sprite_snap(sprite_id: int, enabled: Union[bool, int]) -> None:
    """
    Turns on a special render mode that keeps the sprite on whole pixels only so it does not draw itself across pixel
    boundaries which may cause flickering as the sprite moves across the screen.

    As a consequence this may make the sprite appear to jump from the one pixel to the next as it moves instead of
    smoothly moving across the screen. If the sprite has alpha blended pixels along its edge then snapping is not
    required and can be turned off. By default this is turned off.

    :param int sprite_id: The ID of the sprite to modify.
    :param Union[bool, int] enabled: True to turn snapping on, False to turn it off.
    :rtype: None
    """
    pass    


def set_sprite_speed(sprite_id: int, fps: Union[float, int]) -> None:
    """
    Sets the sprite animation to a specified speed, can be used whilst the animation is running.

    Can be set to 0 to temporarily pause the animation.

    :param int sprite_id: The ID of the sprite to modify.
    :param Union[float, int] fps: The rate at which the sprite should update, sprite frames will be skipped if the
        sprite frame rate is too high compared to the game frame rate.
    :rtype: None
    """
    pass    


def set_sprite_transparency(sprite_id: int, mode: int) -> None:
    """
    Set the sprite transparency to a particular setting, with a choice of no transparency, alpha transparency, and
    additive blending.

    By default sprites are created with alpha transparency, but if you do not need this it is recommended that you turn
    transparency off to improve performance.

    :param int sprite_id: The ID of the sprite to modify.
    :param int mode: The transparency mode for this sprite, 0 (TRANSPARENCY_NONE)=off, 1 (TRANSPARENCY_ALPHA)=alpha
        transparency, 2 (TRANSPARENCY_ADDITIVE)=additive blending.
    :rtype: None
    """
    pass    


def set_sprite_uv(sprite_id: int, u1: Union[float, int], v1: Union[float, int], u2: Union[float,
                  int], v2: Union[float, int], u3: Union[float, int], v3: Union[float, int],
                  u4: Union[float, int], v4: Union[float, int]) -> None:
    """
    This command overrides the normal UV calculations of the sprites and allows you to set them directly for each
    vertex.

    Note that animation using sprite sheets or atlas textures will not function when using this command, and the UV
    offset and zoom functions will have no effect. You have complete control over the UV coordinates. To undo this use
    `reset_sprite_uv()` to return to calculated UV coordinates.

    :param int sprite_id: The ID of the sprite to modify.
    :param Union[float, int] u1: The U coordinate of the top left vertex.
    :param Union[float, int] v1: The V coordinate of the top left vertex.
    :param Union[float, int] u2: The U coordinate of the bottom left vertex.
    :param Union[float, int] v2: The V coordinate of the bottom left vertex.
    :param Union[float, int] u3: The U coordinate of the top right vertex.
    :param Union[float, int] v3: The V coordinate of the top right vertex.
    :param Union[float, int] u4: The U coordinate of the bottom right vertex.
    :param Union[float, int] v4: The V coordinate of the bottom right vertex.
    :rtype: None
    """
    pass    


def set_sprite_uv_border(sprite_id: int, border: Union[float, int]) -> None:
    """
    Adjusts the UV coordinates of the sprite to create a border that moves the edge of the sprite inwards, away from the
    edge of the image applied to it.

    This can be useful for sub images loaded from an atlas texture where images might be packed very closely together.
    Using a border makes sure that the sprite doesn't accidentally sample from a neighbouring image, you could also fix
    this by adding space between the images on an atlas texture. By default a sprite uses a border of 0.5 pixels when
    its image is a sub image, and a border of 0 pixels when its has a normal image. If you have compensated for this
    yourself by adding spacing to the atlas image then setting the border to 0 removes the default offset and creates a
    pixel perfect reproduction of the sub image. You may also increase this border by setting the border greater than
    0.5 pixels.

    :param int sprite_id: The ID of the sprite to modify.
    :param Union[float, int] border: 0=no border, 0.5=half pixel offset, 1=one pixel offset, etc.
    :rtype: None
    """
    pass    


def set_sprite_uv_offset(sprite_id: int, u: Union[float, int], v: Union[float, int]) -> None:
    """
    Offsets the sprites UV coordinates by the given amount.

    For example, offsetting by 0.5 in the U direction will make the sprite begin sampling the texture halfway across the
    top of the texture instead of the top left corner as normal. UV values outside the range of 0,0 (top left) and 1,1
    (bottom right) can either wrap around or clamp the texture, which is decided by the image assigned to the sprite
    using `set_image_wrap_u()` and `set_image_wrap_v()`. Clamping or wrapping cannot be set on a per-sprite basis.

    By default a sprite is set to use the UV coordinates 0,0 to 1,1 using the full image available to it. However there
    are several cases where this is changed by the AGK to hide certain limitations. If the texture assigned to the
    sprite is not a power of 2 width or height the image is increased in size until it is a power of 2 size and the UV
    coordinates for the sprite reduced so that the sprite only uses the portion of the texture containing the original
    image. This is because most mobile platforms do not support textures that are not a power of 2 width or height.
    Therefore offsetting the sprite's UV coordinates in this case will shift the sprite's usage of the texture into the
    undefined portion which is being used as padding.

    Additionally if the sprite is using an image that belongs to an atlas texture the sprite's UV coordinates will be
    set so that it only uses the portion of the texture containing its assigned image. Offsetting the UV coordinates in
    this case will shift the sprite's usage of the texture into other images that are part of the atlas texture. The
    same can be said of sprites using an animation contained within a single texture using `set_sprite_animation()`.

    Due to these possibilities it is recommended that UV coordinates only be modified on sprites that are using whole
    images (not atlas textures) and which are a power of 2 size in both width and height. With these constraints it is
    possible to use UV values outside 0-1 to clamp or repeat the texture successfully.

    :param int sprite_id: The ID of the sprite to modify.
    :param Union[float, int] u: The amount to offset the UV coordinates in the U direction.
    :param Union[float, int] v: The amount to offset the UV coordinates in the V direction.
    :rtype: None
    """
    pass    


def set_sprite_uv_scale(sprite_id: int, u: Union[float, int], v: Union[float, int]) -> None:
    """
    Scales the sprites UV coordinates by the given amount.

    A sprite with UV scaled by 2 will make its texture look twice as big as normal. The UV scale does not affect the UV
    offset chosen using `set_sprite_uv_offset()`, so that an offset of 0.5 in the U direction will always begin sampling
    halfway across the texture, the scale defines how far the sprite continues sampling. So with an offset of 0.5, a
    scale of 2 will make the sprite sample from 0.5 to 1 instead of 0.5 to 1.5.

    By default a sprite is set to use the UV coordinates 0,0 to 1,1 using the full image available to it. However there
    are several cases where this is changed by the AGK to hide certain limitations. If the texture assigned to the
    sprite is not a power of 2 width or height the image is increased in size until it is a power of 2 size and the UV
    coordinates for the sprite reduced so that the sprite only uses the portion of the texture containing the original
    image. This is because most mobile platforms do not support textures that are not a power of 2 width or height.
    Therefore offsetting the sprite's UV coordinates in this case will shift the sprite's usage of the texture into the
    undefined portion which is being used as padding.

    Additionally if the sprite is using an image that belongs to an atlas texture the sprite's UV coordinates will be
    set so that it only uses the portion of the texture containing its assigned image. Offsetting the UV coordinates in
    this case will shift the sprite's usage of the texture into other images that are part of the atlas texture. The
    same can be said of sprites using an animation contained within a single texture using `set_sprite_animation()`.

    Due to these possibilities it is recommended that UV coordinates only be modified on sprites that are using whole
    images (not atlas textures) and which are a power of 2 size in both width and height. With these constraints it is
    possible to use UV values outside 0-1 to clamp or repeat the texture successfully.

    :param int sprite_id: The ID of the sprite to modify.
    :param Union[float, int] u: The amount to scale in the U direction.
    :param Union[float, int] v: The amount to scale in the V direction.
    :rtype: None
    """
    pass    


def set_sprite_visible(sprite_id: int, visible: Union[bool, int]) -> None:
    """
    Sets whether this sprite is visible during drawing.

    It may still update its animation and physics, which are controlled by `set_sprite_active()`.

    :param int sprite_id: The ID of the sprite to modify.
    :param Union[bool, int] visible: The visibility of this sprite, True for visible, False for not visible.
    :rtype: None
    """
    pass    


def set_sprite_x(sprite_id: int, x: Union[float, int]) -> None:
    """
    Immediately positions the specified sprite to the given X world coordinates.

    The default world coordinate system has 0,0 as the top left corner, and 100,100 as the bottom right hand corner of
    the screen (this can be changed using `set_virtual_resolution()`).

    This command positions the sprite by its top left corner.

    :param int sprite_id: The ID of the sprite to position.
    :param Union[float, int] x: The X coordinate to position the sprite, can use decimal values.
    :rtype: None
    """
    pass    


def set_sprite_y(sprite_id: int, y: Union[float, int]) -> None:
    """
    Immediately positions the specified sprite to the given Y world coordinates.

    The default world coordinate system has 0,0 as the top left corner, and 100,100 as the bottom right hand corner of
    the screen (this can be changed using `set_virtual_resolution()`).

    This command positions the sprite by its top left corner.

    :param int sprite_id: The ID of the sprite to position.
    :param Union[float, int] y: The Y coordinate to position the sprite, can use decimal values.
    :rtype: None
    """
    pass    


def stop_sprite(sprite_id: int) -> None:
    """
    Stops the animation of a sprite, maintaining the values used to set it up.

    :param int sprite_id: The ID of the sprite to stop animating.
    :rtype: None
    """
    pass    


def create_text(text: str) -> int:
    """
    Creates a text object for displaying text on the screen using a blank ID, returns the ID used.

    By default text is drawn at depth 9 above the default depth of sprites (10). Any sprites set to a depth of 8 or less
    will appear above the text. You can override this using `set_text_depth()` to set your own draw order.

    :param str text: The initial string to use in this text object, can be an empty string.
    :rtype: int
    """
    pass    


def create_text_id(text_id: int, text: str) -> None:
    """
    Creates a text object for displaying text on the screen using a blank ID, returns the ID used.

    By default text is drawn at depth 9 above the default depth of sprites (10). Any sprites set to a depth of 8 or less
    will appear above the text. You can override this using `set_text_depth()` to set your own draw order.

    :param int text_id: The text ID to use to reference this text later (separate from image and sprite IDs, so there
        can be both a sprite 1 and a text 1).
    :param str text: The initial string to use in this text object, can be an empty string.
    :rtype: None
    """
    pass    


def delete_all_text() -> None:
    """
    Deletes all text objects create by `create_text()`.

    This also resets the auto text ID to 10000.

    :rtype: None
    """
    pass    


def delete_text(text_id: int) -> None:
    """
    Deletes a text object.

    :param int text_id: The ID of the text object to delete.
    :rtype: None
    """
    pass    


def draw_text(text_id: int) -> None:
    """
    Immediately draws the text to the backbuffer at its current position, size, and rotation.

    This is useful if you want to setup a scene for `get_image()` to capture. Remember to use `clear_screen()` to clear
    any of your own drawing before calling `sync()` or `render()` for the actual frame otherwise your drawing may appear
    twice in the final render.

    :param int text_id: The ID of the text to draw.
    :rtype: None
    """
    pass    


def fix_text_to_screen(text_id: int, fixed: Union[bool, int]) -> None:
    """
    By default text objects are created in world coordinates and `set_view_offset()` can be used to move around the
    world.

    Use this command to instead fix the text to the screen so it will move with the viewport when the viewport is moved
    around. You can still reposition a text that is fixed to the screen, it only affects what happens when the viewport
    is moved.

    :param int text_id: The ID of the text to change.
    :param Union[bool, int] fixed: True for screen text, False for world text.
    :rtype: None
    """
    pass    


def get_text_alignment(text_id: int) -> int:
    """
    Returns the current alignment of the text object set with `set_text_alignment()`.

    :param int text_id: The ID of the text object to check.
    :rtype: int
    """
    pass    


def get_text_char_angle(text_id: int, char_index: int) -> float:
    """
    Returns the current angle in degrees of the specified character.

    :param int text_id: The ID of the text object to check.
    :param int char_index: The index of the character to check, indexes start at 0, if the index is out of range it will
        be ignored.
    :rtype: float
    """
    pass    


def get_text_char_angle_rad(text_id: int, char_index: int) -> float:
    """
    Returns the current angle in radians of the specified character.

    :param int text_id: The ID of the text object to check.
    :param int char_index: The index of the character to check, indexes start at 0, if the index is out of range it will
        be ignored.
    :rtype: float
    """
    pass    


def get_text_char_color_alpha(text_id: int, char_index: int) -> int:
    """
    Returns the alpha component of the given character color.

    The value will be in the range 0-255.

    :param int text_id: The ID of the text object to check.
    :param int char_index: The index of the character to check, indexes start at 0, if the index is out of range it will
        be ignored.
    :rtype: int
    """
    pass    


def get_text_char_color_blue(text_id: int, char_index: int) -> int:
    """
    Returns the blue component of the given character color.

    The value will be in the range 0-255.

    :param int text_id: The ID of the text object to check.
    :param int char_index: The index of the character to check, indexes start at 0, if the index is out of range it will
        be ignored.
    :rtype: int
    """
    pass    


def get_text_char_color_green(text_id: int, char_index: int) -> int:
    """
    Returns the green component of the given character color.

    The value will be in the range 0-255.

    :param int text_id: The ID of the text object to check.
    :param int char_index: The index of the character to check, indexes start at 0, if the index is out of range it will
        be ignored.
    :rtype: int
    """
    pass    


def get_text_char_color_red(text_id: int, char_index: int) -> int:
    """
    Returns the red component of the given character color.

    The value will be in the range 0-255.

    :param int text_id: The ID of the text object to check.
    :param int char_index: The index of the character to check, indexes start at 0, if the index is out of range it will
        be ignored.
    :rtype: int
    """
    pass    


def get_text_char_x(text_id: int, char_index: int) -> float:
    """
    Returns the current X position of the specified character relative to the text object.

    :param int text_id: The ID of the text object to check.
    :param int char_index: The index of the character to check, indexes start at 0, if the index is out of range it will
        be ignored.
    :rtype: float
    """
    pass    


def get_text_char_y(text_id: int, char_index: int) -> float:
    """
    Returns the current Y position of the specified character relative to the text object.

    :param int text_id: The ID of the text object to check.
    :param int char_index: The index of the character to check, indexes start at 0, if the index is out of range it will
        be ignored.
    :rtype: float
    """
    pass    


def get_text_color_alpha(text_id: int) -> int:
    """
    Get the alpha component of the text color.

    The value will be in the range 0-255.

    :param int text_id: The ID of the text to check.
    :rtype: int
    """
    pass    


def get_text_color_blue(text_id: int) -> int:
    """
    Get the blue component of the text color.

    The value will be in the range 0-255.

    :param int text_id: The ID of the text to check.
    :rtype: int
    """
    pass    


def get_text_color_green(text_id: int) -> int:
    """
    Get the green component of the text color.

    The value will be in the range 0-255.

    :param int text_id: The ID of the text to check.
    :rtype: int
    """
    pass    


def get_text_color_red(text_id: int) -> int:
    """
    Get the red component of the text color.

    The value will be in the range 0-255.

    :param int text_id: The ID of the text to check.
    :rtype: int
    """
    pass    


def get_text_depth(text_id: int) -> int:
    """
    Returns the current depth of the text object, with 0 being the front of the screen and 10000 being the back.

    :param int text_id: The ID of the text object to check.
    :rtype: int
    """
    pass    


def get_text_exists(text_id: int) -> bool:
    """
    Returns True if the text exists, False if not.

    :param int text_id: The ID of the text to check.
    :rtype: bool
    """
    pass    


def get_text_hit_test(text_id: int, x: Union[float, int], y: Union[float, int]) -> bool:
    """
    Returns True if the given point in world coordinates is inside the bounding box of the text.

    If you are testing a mouse or touch coordinate, remember to convert it to world coordinates using
    `screen_to_world_x()` and `screen_to_world_y()`.

    This does not take into account individual character positions, for example if you have positioned a character using
    `set_text_char_x()` or similar. Only the bounding box created by drawing the characters in their default positions
    is checked.

    :param int text_id: The ID of the text object to check.
    :param Union[float, int] x: The x coordinate of the point to check in world coordinates.
    :param Union[float, int] y: The y coordinate of the point to check in world coordinates.
    :rtype: bool
    """
    pass    


def get_text_length(text_id: int) -> int:
    """
    Returns the current length of the string the text object is displaying.

    :param int text_id: The ID of the text object to return.
    :rtype: int
    """
    pass    


def get_text_line_spacing(text_id: int) -> float:
    """
    Returns the current line spacing of the text object set with `set_text_line_spacing()`.

    :param int text_id: The ID of the text object to check.
    :rtype: float
    """
    pass    


def get_text_size(text_id: int) -> float:
    """
    Returns the current size of the text object set with `set_text_size()`.

    :param int text_id: The ID of the text object to check.
    :rtype: float
    """
    pass    


def get_text_spacing(text_id: int) -> float:
    """
    Returns the current spacing of the text object set with `set_text_spacing()`.

    :param int text_id: The ID of the text object to check.
    :rtype: float
    """
    pass    


def get_text_string(text_id: int) -> str:
    """
    Returns the current string being displayed by the text object.

    :param int text_id: The ID of the text object to check.
    :rtype: str
    """
    pass    


def get_text_total_height(text_id: int) -> float:
    """
    Returns the current height of the text object in world units.

    This does not take into account the individual offsets of characters, if you have used `set_text_char_y()` or
    similar to move a character. The returned value is the height used by the default drawing position of the text
    characters. Note that if the string of the text is empty then this value will return 0.

    :param int text_id: The ID of the text object to return.
    :rtype: float
    """
    pass    


def get_text_total_width(text_id: int) -> float:
    """
    Returns the current width of the text object in world units.

    If the text object is displaying text over multiple lines it will return the width of the longest line. This does
    not take into account the individual offsets of characters, if you have used `set_text_char_x()` or similar to move
    a character. The returned value is the width used by the default drawing position of the text characters.

    :param int text_id: The ID of the text object to return.
    :rtype: float
    """
    pass    


def get_text_visible(text_id: int) -> bool:
    """
    Returns False if the current text has been set as invisible using `set_text_visible()`, True if it is set as visible
    (default). This does not check if the text is currently positioned withing the visible viewport.

    :param int text_id: The ID of the text object to check.
    :rtype: bool
    """
    pass    


def get_text_x(text_id: int) -> float:
    """
    Returns the current X position of a text object in world coordinates, the text is positioned using its top left
    corner.

    :param int text_id: The ID of the text object to return.
    :rtype: float
    """
    pass    


def get_text_y(text_id: int) -> float:
    """
    Returns the current Y position of a text object in world coordinates, the text is positioned using its top left
    corner.

    :param int text_id: The ID of the text object to return.
    :rtype: float
    """
    pass    


def print_value(value: object, newline: Union[bool, int] = True) -> None:
    """
    Prints the string representation of the given value to the screen and optionally adds a new line character so that
    the next `print_value` call will be one line down.

    :param object value: The object to print.
    :param Union[bool, int] newline: When True, adds a new line character so the next call will be one line down.
    :rtype: None
    """
    pass    


def set_print_color(red: int, green: int, blue: int, alpha: int = 255) -> None:
    """
    Sets the color used by `print_value()`.

    This is a global command and will affect all printed text in the next call to `sync()`. To control color on a per
    string basis use the Text commands. This version sets the alpha to 255, fully opaque.

    :param int red: The red component of the color.
    :param int green: The green component of the color.
    :param int blue: The blue component of the color.
    :param int alpha: The alpha component of the color.
    :rtype: None
    """
    pass    


def set_print_font(font_id: int) -> None:
    """
    Sets the font used by `print_value()`, the font must have been previously loaded with `load_font()`.

    Use a font ID of 0 to use the AGK default font.

    :param int font_id: The font ID to use for `print_value()` text.
    :rtype: None
    """
    pass    


def set_print_size(size: Union[float, int]) -> None:
    """
    Sets the size used by `print_value()`.

    This is a global command and will affect all printed text in the next call to `sync()`. To control size on a per
    string basis use the Text commands.

    :param Union[float, int] size: The size in virtual resolution pixels for the text.
    :rtype: None
    """
    pass    


def set_print_spacing(spacing: Union[float, int]) -> None:
    """
    Sets the spacing used by `print_value()`.

    A value of 0 puts no gap between the letter bounding boxes, a positive value increases this gap, a negative value
    overlaps the letters. This is a global command and will affect all printed text in the next call to `sync()`. To
    control spacing on a per string basis use the Text commands.

    :param Union[float, int] spacing: The letter spacing to use.
    :rtype: None
    """
    pass    


def set_text_alignment(text_id: int, align: int) -> None:
    """
    Sets how the text should be positioned on screen.

    Left alignment positions the text using its top left corner, right alignment positions it using its top right
    corner, and center positions it using a point halfway along its top edge.

    :param int text_id: The ID of the text object to update.
    :param int align: The alignment mode to use. 0 (ALIGN_LEFT)=left, 1 (ALIGN_CENTER)=center, 2 (ALIGN_RIGHT)=right.
    :rtype: None
    """
    pass    


def set_text_angle(text_id: int, angle: Union[float, int]) -> None:
    """
    Updates the angle of the text.

    If the text is aligned to the left then it will rotate around its top left corner. When using center alignment it
    will rotate around a point halfway along its top edge. When using right alignment it will rotate around its top
    eight corner.

    :param int text_id: The ID of the text object to update.
    :param Union[float, int] angle: The new angle in degrees.
    :rtype: None
    """
    pass    


def set_text_angle_rad(text_id: int, angle: Union[float, int]) -> None:
    """
    Updates the angle of the text.

    If the text is aligned to the left then it will rotate around its top left corner. When using center alignment it
    will rotate around a point halfway along its top edge. When using right alignment it will rotate around its top
    eight corner.

    :param int text_id: The ID of the text object to update.
    :param Union[float, int] angle: The new angle in radians.
    :rtype: None
    """
    pass    


def set_text_bold(text_id: int, bold: Union[bool, int]) -> None:
    """
    Sets all characters in the text to bold regardless of the current `set_text_char_bold()` state.

    This setting will remain active until it is changed, setting a new text string will not change it.

    :param int text_id: The ID of the text to modify.
    :param Union[bool, int] bold: True to use bold, False to use normal weight (default).
    :rtype: None
    """
    pass    


def set_text_char_angle(text_id: int, char_index: int, angle: Union[float, int]) -> None:
    """
    Set the angle of an individual character in degrees, clockwise.

    The character will rotate around its center. If any of the following commands are called the rotation of all
    characters will be reset: `set_text_position()`, `set_text_x()`, `set_text_y()`, `set_text_size()`,
    `set_text_spacing()`, `set_text_alignment()`.

    :param int text_id: The ID of the text to modify.
    :param int char_index: The index of the character to modify, indexes start at 0, if the index is out of range it
        will be ignored.
    :param Union[float, int] angle: The new angle in degrees.
    :rtype: None
    """
    pass    


def set_text_char_angle_rad(text_id: int, char_index: int, angle: Union[float, int]) -> None:
    """
    Set the angle of an individual character in radians, clockwise.

    The character will rotate around its center. If any of the following commands are called the rotation of all
    characters will be reset: `set_text_position()`, `set_text_x()`, `set_text_y()`, `set_text_size()`,
    `set_text_spacing()`, `set_text_alignment()`.

    :param int text_id: The ID of the text to modify.
    :param int char_index: The index of the character to modify, indexes start at 0, if the index is out of range it
        will be ignored.
    :param Union[float, int] angle: The new angle in radians.
    :rtype: None
    """
    pass    


def set_text_char_bold(text_id: int, char_index: int, bold: Union[bool, int]) -> None:
    """
    Sets the character to have the bold style.

    This only applies if the text is using a TrueType font set with `set_text_font()`. If you use `set_text_string()`
    then this setting will be reset to 0. You can use `set_text_bold()` to set the entire string to bold.

    :param int text_id: The ID of the text object to set.
    :param int char_index: The index of the character to set, indexes start at 0, if the index is out of range it will
        be ignored.
    :param Union[bool, int] bold: True to set the character as bold, False to set it as normal weight (default).
    :rtype: None
    """
    pass    


def set_text_char_color(text_id: int, char_index: int, red: int, green: int, blue: int,
                        alpha: int) -> None:
    """
    Sets the color of the specified character.

    Using the `set_text_color()` command will override this. Values should be in the range 0-255.

    :param int text_id: The ID of the text object to set.
    :param int char_index: The index of the character to set, indexes start at 0, if the index is out of range it will
        be ignored.
    :param int red: The red component of the new color.
    :param int green: The green component of the new color.
    :param int blue: The blue component of the new color.
    :param int alpha: The alpha component of the new color.
    :rtype: None
    """
    pass    


def set_text_char_color_alpha(text_id: int, char_index: int, alpha: int) -> None:
    """
    Sets the alpha component of the specified character's color.

    Using the `set_text_color()` command will override this. Values should be in the range 0-255.

    :param int text_id: The ID of the text object to set.
    :param int char_index: The index of the character to set, indexes start at 0, if the index is out of range it will
        be ignored.
    :param int alpha: The new alpha value to use.
    :rtype: None
    """
    pass    


def set_text_char_color_blue(text_id: int, char_index: int, blue: int) -> None:
    """
    Sets the blue component of the specified character's color.

    Using the `set_text_color()` command will override this. Values should be in the range 0-255.

    :param int text_id: The ID of the text object to set.
    :param int char_index: The index of the character to set, indexes start at 0, if the index is out of range it will
        be ignored.
    :param int blue: The new blue value to use.
    :rtype: None
    """
    pass    


def set_text_char_color_green(text_id: int, char_index: int, green: int) -> None:
    """
    Sets the green component of the specified character's color.

    Using the `set_text_color()` command will override this. Values should be in the range 0-255.

    :param int text_id: The ID of the text object to set.
    :param int char_index: The index of the character to set, indexes start at 0, if the index is out of range it will
        be ignored.
    :param int green: The new green value to use.
    :rtype: None
    """
    pass    


def set_text_char_color_red(text_id: int, char_index: int, red: int) -> None:
    """
    Sets the red component of the specified characters color.

    Using the `set_text_color()` command will override this. Values should be in the range 0-255.

    :param int text_id: The ID of the text object to set.
    :param int char_index: The index of the character to set, indexes start at 0, if the index is out of range it will
        be ignored.
    :param int red: The new red value to use.
    :rtype: None
    """
    pass    


def set_text_char_position(text_id: int, char_index: int, x: Union[float, int], y: Union[float,
                           int]) -> None:
    """
    Set the position of an individual character relative to the text position set earlier.

    The character will be positioned using its top left corner. If any of the following commands are called the position
    of all characters will be reset to a straight line: `set_text_position()`, `set_text_x()`, `set_text_y()`,
    `set_text_size()`, `set_text_spacing()`, `set_text_alignment()`. Positioning characters within a text object is more
    efficient than positioning lots of small text objects each containing a character as all the characters can be drawn
    in a single draw call.

    :param int text_id: The ID of the text to modify.
    :param int char_index: The index of the character to modify, indexes start at 0, if the index is out of range it
        will be ignored.
    :param Union[float, int] x: The new X position of the character, relative to the current text position.
    :param Union[float, int] y: The new Y position of the character, relative to the current text position.
    :rtype: None
    """
    pass    


def set_text_char_x(text_id: int, char_index: int, x: Union[float, int]) -> None:
    """
    Set the X position of an individual character relative to the text position set earlier.

    The character will be positioned using its top left corner. If any of the following commands are called the position
    of all characters will be reset to a straight line: `set_text_position()`, `set_text_x()`, `set_text_y()`,
    `set_text_size()`, `set_text_spacing()`, `set_text_alignment()`. Positioning characters within a text object is more
    efficient than positioning lots of small text objects each containing a character as all the characters can be drawn
    in a single draw call.

    :param int text_id: The ID of the text to modify.
    :param int char_index: The index of the character to modify, indexes start at 0, if the index is out of range it
        will be ignored.
    :param Union[float, int] x: The new X position of the character, relative to the current text position.
    :rtype: None
    """
    pass    


def set_text_char_y(text_id: int, char_index: int, y: Union[float, int]) -> None:
    """
    Set the Y position of an individual character relative to the text position set earlier.

    The character will be positioned using its top left corner. If any of the following commands are called the position
    of all characters will be reset to a straight line: `set_text_position()`, `set_text_x()`, `set_text_y()`,
    `set_text_size()`, `set_text_spacing()`, `set_text_alignment()`. Positioning characters within a text object is more
    efficient than positioning lots of small text objects each containing a character as all the characters can be drawn
    in a single draw call.

    :param int text_id: The ID of the text to modify.
    :param int char_index: The index of the character to modify, indexes start at 0, if the index is out of range it
        will be ignored.
    :param Union[float, int] y: The new Y position of the character, relative to the current text position.
    :rtype: None
    """
    pass    


def set_text_color(text_id: int, red: int, green: int, blue: int, alpha: int) -> None:
    """
    Set the color of the text, the values should be in the range 0-255.

    This will set all characters in the text to be this color. You can set individual characters using
    `set_text_char_color()`.

    :param int text_id: The ID of the text to modify.
    :param int red: The red component of the color.
    :param int green: The green component of the color.
    :param int blue: The blue component of the color.
    :param int alpha: The alpha component of the color.
    :rtype: None
    """
    pass    


def set_text_color_alpha(text_id: int, alpha: int) -> None:
    """
    Set the alpha component of the text color.

    The value should be in the range 0-255.

    :param int text_id: The ID of the text to modify.
    :param int alpha: The alpha component of the color.
    :rtype: None
    """
    pass    


def set_text_color_blue(text_id: int, blue: int) -> None:
    """
    Set the blue component of the text color.

    The value should be in the range 0-255.

    :param int text_id: The ID of the text to modify.
    :param int blue: The blue component of the color.
    :rtype: None
    """
    pass    


def set_text_color_green(text_id: int, green: int) -> None:
    """
    Set the green component of the text color.

    The value should be in the range 0-255.

    :param int text_id: The ID of the text to modify.
    :param int green: The green component of the color.
    :rtype: None
    """
    pass    


def set_text_color_red(text_id: int, red: int) -> None:
    """
    Set the red component of the text color.

    The value should be in the range 0-255.

    :param int text_id: The ID of the text to modify.
    :param int red: The red component of the color.
    :rtype: None
    """
    pass    


def set_text_default_extended_font_image(image_id: int) -> None:
    """
    Sets the default extended font to use for text objects.

    The extended font is for non standard characters above ascii value 127 and can be set separately to the standard
    characters so you can have multiple images for the extended set and a base image for the normal font characters.

    The AGK has a built in extended font for characters 128 to 255 that it uses for text objects, this allows you to
    override it. If you do choose to override it you must do so before creating any text objects. You can set the font
    on a per text basis using `set_text_extended_font_image()`. The image should contain all white characters surrounded
    by a transparent alpha channel. Fully transparent pixels should also contain white in their RGB components.

    The extended font image may either be fixed width or variable width. For fixed width the font image must be laid out
    in a grid of 16 characters across and 8 characters down, starting with the ascii character 128 in the top left and
    proceeding left to right, top to bottom, ending with ascii character 255 in the bottom right. The image width must
    be divisible by 16 and the image height must be divisible by 8. For variable width the image must be an atlas
    texture accompanied by a subimages.txt file that states the location of each character on the image. The AGK will
    look for images "128" up to and including "255" in the subimages file and any not found will default to the space
    character (32).

    :param int image_id: The image containing the new font.
    :rtype: None
    """
    pass    


def set_text_default_font_image(image_id: int) -> None:
    """
    Sets the default font to use for text objects.

    The AGK has a built in font that it uses for text objects, this allows you to override it. If you do choose to
    override it you must do so before creating any text objects. You can set the font on a per text basis using
    `set_text_font_image()`. The image should contain all white characters surrounded by a transparent alpha channel.
    Fully transparent pixels should also contain white in their RGB components.

    The font image may either be fixed width or variable width. For fixed width the font image must be laid out in a
    grid of 16 characters across and 6 characters down, starting with the ascii character 32 (space) in the top left and
    proceeding left to right, top to bottom, ending with ascii character 127 (DEL) in the bottom right. The image width
    must be divisible by 16 and the image height must be divisible by 6. For variable width the image must be an atlas
    texture accompanied by a subimages.txt file that states the location of each character on the image. The AGK will
    look for images "32" up to and including "127" in the subimages file and any not found will default to the space
    character (32).

    :param int image_id: The image containing the new font.
    :rtype: None
    """
    pass    


def set_text_default_mag_filter(mode: int) -> None:
    """
    Sets the image filter for all text objects and print functions that are using the default font when the text image
    is larger than the screen space it occupies.

    Nearest filtering chooses the closest pixel to display and can look blocky. Linear filtering blends the 4 closest
    pixels and can look blurry.

    :param int mode: The filtering mode to use, 0 (FILTER_NEAREST)=nearest, 1 (FILTER_LINEAR)=linear.
    :rtype: None
    """
    pass    


def set_text_default_min_filter(mode: int) -> None:
    """
    Sets the image filter for all text objects and print functions that are using the default font when the text image
    is smaller than the screen space it occupies.

    Nearest filtering chooses the closest pixel to display and can look blocky. Linear filtering blends the 4 closest
    pixels and can look blurry.

    :param int mode: The filtering mode to use, 0 (FILTER_NEAREST)=nearest, 1 (FILTER_LINEAR)=linear.
    :rtype: None
    """
    pass    


def set_text_depth(text_id: int, depth: int) -> None:
    """
    Sets the draw order for the text between 0-10000, 0 being the front of the screen, 10000 being the back.

    Anything more than 10000 will result in the text being clipped from view.

    By default text is set to depth 9 and appears above all other sprites in the scene, setting a greater depth will
    cause the text to be sorted into the transparent draw order list which may decrease performance. Use depth 0 for
    best performance.

    :param int text_id: The ID of the text to modify.
    :param int depth: The depth this text should be drawn at.
    :rtype: None
    """
    pass    


def set_text_extended_font_image(text_id: int, image_id: int) -> None:
    """
    Sets the extended font to use for this text object.

    The extended font is for non standard characters above ascii value 127 and can be set separately to the standard
    characters so you can have multiple images for the extended set and a base image for the normal font characters. AGK
    has a built in extended font that it uses for text objects with characters 128 to 255, this command allows you to
    override it. If you are setting all your text objects to the same extended font you should use
    `set_text_default_extended_font_image()` instead as this will save some processing time.

    The image should contain all white characters surrounded by a transparent alpha channel. Fully transparent pixels
    should also contain white in their RGB components.

    The font image may either be fixed width or variable width. For fixed width the font image must be laid out in a
    grid of 16 characters across and 8 characters down, starting with the ascii character 32 (space) in the top left and
    proceeding left to right, top to bottom, ending with ascii character 127 (DEL) in the bottom right. The image width
    must be divisible by 16 and the image height must be divisible by 6. For variable width the image must be an atlas
    texture accompanied by a subimages.txt file that states the location of each character on the image. The AGK will
    look for images "32" up to and including "127" in the subimages file and any not found will default to the space
    character (32). Variable height characters are not supported and all characters must be the same height with any
    necessary padding included in the font image.

    If this text object is using a TrueType font then this command has no affect, the TrueType font handles both normal
    and extended (unicode) characters.

    :param int text_id: The ID of the text object to modify.
    :param int image_id: The image containing the new font.
    :rtype: None
    """
    pass    


def set_text_font(text_id: int, font_id: int) -> None:
    """
    Sets the TrueType font to use for this text object.

    The font must have been loaded with `load_font()` from a TrueType font file. This is different from the old bitmap
    fonts in that it supports unicode characters and the characters will usually appear sharper on screen at all sizes.

    Note that resizing a text object that is using a TrueType font will redraw all the characters from the font file
    onto an image for drawing, for large text sizes using hundreds of different unicode characters this could be a slow
    process but in normal use it is usually not noticeable.

    Recently used sizes are kept for a short period of time so if you are frequently switching between two or three text
    sizes then no redrawing will need to be done and it will be faster.

    Use a font ID of 0 to use the built in TrueType font that supports a wide range of unicode characters.

    :param int text_id: The ID of the text object to change.
    :param int font_id: The ID of the font to use.
    :rtype: None
    """
    pass    


def set_text_font_image(text_id: int, image_id: int) -> None:
    """
    Sets the font to use for this text object.

    AGK has a built in font that it uses for text objects, this allows you to override it. If you are setting all your
    text objects to the same font you should use `set_text_default_font_image()` instead as this will save some
    processing time.

    The image should contain all white characters surrounded by a transparent alpha channel. Fully transparent pixels
    should also contain white in their RGB components.

    The font image may either be fixed width or variable width. For fixed width the font image must be laid out in a
    grid of 16 characters across and 6 characters down, starting with the ascii character 32 (space) in the top left and
    proceeding left to right, top to bottom, ending with ascii character 127 (DEL) in the bottom right. The image width
    must be divisible by 16 and the image height must be divisible by 6. For variable width the image must be an atlas
    texture accompanied by a subimages.txt file that states the location of each character on the image. The AGK will
    look for images "32" up to and including "127" in the subimages file and any not found will default to the space
    character (32). Variable height characters are not supported and all characters must be the same height with any
    necessary padding included in the font image.

    As of version 2.0.20 you can use `set_text_font()` to use TrueType fonts instead of bitmap fonts. You must choose
    one or the other, setting a bitmap font will remove the Truetype font, and setting a TrueType font will remove the
    bitmap font.

    :param int text_id: The ID of the text object to modify.
    :param int image_id: The image containing the new font.
    :rtype: None
    """
    pass    


def set_text_line_spacing(text_id: int, spacing: Union[float, int]) -> None:
    """
    Sets the spacing between text lines.

    A value of 0 puts no gap between the lines, a positive value increases this gap, a negative value overlaps the
    lines. If each character is built with some space above and below it in the font image then that is the default
    amount of spacing and this command will increase or decrease the spacing from that.

    :param int text_id: The ID of the text object to update.
    :param Union[float, int] spacing: The new spacing to use.
    :rtype: None
    """
    pass    


def set_text_max_width(text_id: int, width: Union[float, int]) -> None:
    """
    Sets the maximum width the text object will use to draw, any characters that extend beyond this value will wrap onto
    a new line.

    :param int text_id: The ID of the text object to modify.
    :param Union[float, int] width: The maximum width the text will use.
    :rtype: None
    """
    pass    


def set_text_position(text_id: int, x: Union[float, int], y: Union[float, int]) -> None:
    """
    Updates the position of a text object in world coordinates, by default the text is positioned using its top left
    corner.

    When using right alignment the text is positioned using its top right corner. When using center alignment the text
    is positioned using a point halfway along its top edge.

    :param int text_id: The ID of the text object to update.
    :param Union[float, int] x: The new X position.
    :param Union[float, int] y: The new Y position.
    :rtype: None
    """
    pass    


def set_text_scissor(text_id: int, x1: Union[float, int], y1: Union[float, int], x2: Union[float,
                     int], y2: Union[float, int]) -> None:
    """
    Clips the text to the specified world coordinates when drawn.

    Use the values 0,0,0,0 to turn off the text scissor.

    :param int text_id: The ID of the text to modify.
    :param Union[float, int] x1: The x coordinate of the top left corner of the box to use as a clip boundary.
    :param Union[float, int] y1: The y coordinate of the top left corner of the box to use as a clip boundary.
    :param Union[float, int] x2: The x coordinate of the bottom right corner of the box to use as a clip boundary.
    :param Union[float, int] y2: The y coordinate of the bottom right corner of the box to use as a clip boundary.
    :rtype: None
    """
    pass    


def set_text_shader(text_id: int, shader_id: int) -> None:
    """
    Sets the shader used to draw this Text, loaded with Loadshader. By default Text objects are assigned an internal
    shader that can handle 1 texture and a color. If you use a shader ID of 0 the Text is assigned the internal shader.

    :param int text_id: The ID of the text to modify.
    :param int shader_id: The ID of the shader to use.
    :rtype: None
    """
    pass    


def set_text_shader_constant_array_by_name(text_id: int, name: str, array_index: int,
                                           value1: Union[float, int], value2: Union[float, int],
                                           value3: Union[float, int], value4: Union[float,
                                           int]) -> None:
    """
    Sets a shader constant array index by name, the constant must be marked as "uniform" in the shader source. Array
    indices start at 0, if the array index is out of bounds then it will be ignored and no changes will be made. This
    will affect only the specified text this shader. All shader values have 1 to 4 components, this command accepts 4
    values and discards any that are not used by the named variable.

    :param int text_id: The ID of the text to modify.
    :param str name: The name of the constant to change, as defined in the shader source file.
    :param int array_index: The element of the array to modify.
    :param Union[float, int] value1: The X or R component of the new value, this value will always be used.
    :param Union[float, int] value2: The Y or G component of the new value, if the constant only uses 1 component this
        value is discarded.
    :param Union[float, int] value3: The Z or B component of the new value, if the constant only uses 2 components this
        value is discarded.
    :param Union[float, int] value4: The W or A component of the new value, if the constant only uses 3 components this
        value is discarded.
    :rtype: None
    """
    pass    


def set_text_shader_constant_by_name(text_id: int, name: str, value1: Union[float, int],
                                     value2: Union[float, int], value3: Union[float, int],
                                     value4: Union[float, int]) -> None:
    """
    Sets a shader constant for a text by name, the constant must be marked as "uniform" in the shader source. The Text
    will set the specified constant to this value for any shader that it is applied to it. All shader values have 1 to 4
    components, this command accepts 4 values and discards any that are not used by the named variable.

    :param int text_id: The ID of the text to modify.
    :param str name: The name of the constant to change, as defined in the shader source file.
    :param Union[float, int] value1: The X or R component of the new value, this value will always be used.
    :param Union[float, int] value2: The Y or G component of the new value, if the constant only uses 1 component this
        value is discarded.
    :param Union[float, int] value3: The Z or B component of the new value, if the constant only uses 2 components this
        value is discarded.
    :param Union[float, int] value4: The W or A component of the new value, if the constant only uses 3 components this
        value is discarded.
    :rtype: None
    """
    pass    


def set_text_shader_constant_default(text_id: int, name: str) -> None:
    """
    Stops a text setting the given constant name in its shaders and uses the shader's default value from now on.

    :param int text_id: The ID of the text to modify.
    :param str name: The name of the constant to stop changing.
    :rtype: None
    """
    pass    


def set_text_size(text_id: int, size: Union[float, int]) -> None:
    """
    Sets the size of the text object, default is 4.

    This value represents the height of each character in world units. The width of each character is dependant on the
    font and is calculated to match the given size.

    :param int text_id: The ID of the text object to update.
    :param Union[float, int] size: The new size of the text.
    :rtype: None
    """
    pass    


def set_text_spacing(text_id: int, spacing: Union[float, int]) -> None:
    """
    Sets the spacing between letters.

    A value of 0 puts no gap between the letter bounding boxes, a positive value increases this gap, a negative value
    overlaps the letters. If each character is built with some space either side of it in the font image then that is
    the default amount of spacing and this command will increase or decrease the spacing from that.

    :param int text_id: The ID of the text object to update.
    :param Union[float, int] spacing: The new spacing to use.
    :rtype: None
    """
    pass    


def set_text_string(text_id: int, text: str) -> None:
    """
    Updates the string of a text object, the new text will be displayed on the next screen refresh.

    :param int text_id: The ID of the text object to update.
    :param str text: The new string to use.
    :rtype: None
    """
    pass    


def set_text_transparency(text_id: int, mode: int) -> None:
    """
    Set the text transparency to a particular setting, with a choice of no transparency, alpha transparency, and
    additive blending.

    By default text is created with alpha transparency.

    :param int text_id: The ID of the text to modify.
    :param int mode: The transparency mode for this text, 0 (TRANSPARENCY_NONE)=off, 1 (TRANSPARENCY_ALPHA)=alpha
        transparency, 2 (TRANSPARENCY_ADDITIVE)=additive blending.
    :rtype: None
    """
    pass    


def set_text_visible(text_id: int, visible: Union[bool, int]) -> None:
    """
    Sets whether the text is drawn during screen refreshes.

    :param int text_id: The ID of the text to modify.
    :param Union[bool, int] visible: True to draw this text, False to hide it.
    :rtype: None
    """
    pass    


def set_text_x(text_id: int, x: Union[float, int]) -> None:
    """
    Updates the X position of a text object in world coordinates, by default the text is positioned using its top left
    corner.

    When using right alignment the text is positioned using its top right corner. When using center alignment the text
    is positioned using a point halfway along its top edge.

    :param int text_id: The ID of the text object to update.
    :param Union[float, int] x: The new X position.
    :rtype: None
    """
    pass    


def set_text_y(text_id: int, y: Union[float, int]) -> None:
    """
    Updates the Y position of a text object in world coordinates, by default the text is positioned using its top left
    corner.

    When using right alignment the text is positioned using its top right corner. When using center alignment the text
    is positioned using a point halfway along its top edge.

    :param int text_id: The ID of the text object to update.
    :param Union[float, int] y: The new Y position.
    :rtype: None
    """
    pass    


def use_new_default_fonts(active: Union[bool, int]) -> None:
    """
    Since version 2.0.20 AGK has a new font system that can display more characters and render characters more smoothly,
    however to preserve backwards compatibility this is turned off by default.

    To use the new system set this command to 1. This only affects the default font where you haven't set one yourself.

    :param Union[bool, int] active: When True, the new font system is used; otherwise the older font system is used.
    :rtype: None
    """
    pass    


def get_current_date() -> str:
    """
    Returns a string representing the current date in the format YYYY-MM-DD, for example 2012-01-09.

    :rtype: str
    """
    pass    


def get_current_time() -> str:
    """
    Returns a string representing the current time in the format HH-MM-SS, for example 15:23:04.

    :rtype: str
    """
    pass    


def get_day_of_week() -> int:
    """
    Returns an integer representing the current day of the week in the range 0-6 with 0 as Sunday, 1 as Monday, etc.

    :rtype: int
    """
    pass    


def get_days_from_unix(unix_time: int) -> int:
    """
    Returns the days of a given unix time value (1 to 31).

    Unix time is represented as the number of seconds since the 1st Jan 1970, it may also be negative.

    :param int unix_time: A unix time value.
    :rtype: int
    """
    pass    


def get_hours_from_unix(unix_time: int) -> int:
    """
    Returns the hours of a given unix time value (0 to 23).

    Unix time is represented as the number of seconds since the 1st Jan 1970, it may also be negative.

    :param int unix_time: A unix time value.
    :rtype: int
    """
    pass    


def get_leap_year(year: int) -> bool:
    """
    Returns True if the given year is a leap year, otherwise False.

    :param int year: The year to check.
    :rtype: bool
    """
    pass    


def get_minutes_from_unix(unix_time: int) -> int:
    """
    Returns the minutes of a given unix time value (0 to 59).

    Unix time is represented as the number of seconds since the 1st Jan 1970, it may also be negative.

    :param int unix_time: A unix time value.
    :rtype: int
    """
    pass    


def get_month_from_unix(unix_time: int) -> int:
    """
    Returns the month of a given unix time value (1 to 12).

    Unix time is represented as the number of seconds since the 1st Jan 1970, it may also be negative.

    :param int unix_time: A unix time value.
    :rtype: int
    """
    pass    


def get_seconds_from_unix(unix_time: int) -> int:
    """
    Returns the seconds of a given unix time value (0 to 59).

    Unix time is represented as the number of seconds since the 1st Jan 1970, it may also be negative.

    :param int unix_time: A unix time value.
    :rtype: int
    """
    pass    


def get_unix_from_date(year: int, month: int, day: int, hour: int, minute: int, second: int) -> int:
    """
    Converts a given date and time into its unix time equivalent, unix time is the number of seconds since 1st Jan 1970.

    If not using 64 bit values then the unix time value is limited to 1901 to 2038 for the year.

    :param int year: The year portion of the date.
    :param int month: The month portion of the date, in the range 1 to 12.
    :param int day: The day portion of the date, in the range 1 to 31.
    :param int hour: The hours portion of the date, in the range 0 to 23.
    :param int minute: The minutes portion of the date, in the range 0 to 59.
    :param int second: The seconds portion of the date, in the range 0 to 59.
    :rtype: int
    """
    pass    


def get_unix_time() -> int:
    """
    Returns the current date and time in unix time format, which is measured as seconds from 1st Jan 1970.

    It can be negative for dates before 1970.

    :rtype: int
    """
    pass    


def get_year_from_unix(unix_time: int) -> int:
    """
    Returns the year of a given unix time value.

    Unix time is represented as the number of seconds since the 1st Jan 1970, it may also be negative. If not using 64
    bit values then the unix time value is limited to 1901 to 2038 for the year.

    :param int unix_time: A unix time value.
    :rtype: int
    """
    pass    


def add_tween_chain_camera(chain_id: int, tween_id: int, camera_id: int,
                           delay: Optional[Union[float, int]] = 0) -> None:
    """
    Applies the given tween ID to a given camera ID with an optional delay and adds it to the end of the chain.

    A tween can be added to multiple cameras at the same time, simply call this command again with a different camera
    ID. The camera will not be modified until all preceding tweens in this chain have finished and the delay time has
    passed, at which point the tween will start at the begin values and move towards the end values over the tween
    duration. If a tween end value is modified whilst the tween is playing on a camera the camera will adjust its
    interpolation accordingly. Modifying the duration whilst playing is undefined and not compatible with chains.

    :param int chain_id: ID of the chain to add to.
    :param int tween_id: ID of the tween to add.
    :param int camera_id: ID of the camera to modify.
    :param Optional[Union[float, int]] delay: Number of seconds to wait before playing this tween when it is triggered.
    :rtype: None
    """
    pass    


def add_tween_chain_char(chain_id: int, tween_id: int, text_id: int, char_index: int,
                         delay: Optional[Union[float, int]] = 0) -> None:
    """
    Applies the given tween ID to a given character in a text object with an optional delay and adds it to the end of
    the chain.

    A tween can be added to multiple characters at the same time, simply call this command again with a different
    character or text ID. The character will not be modified until all preceding tweens in this chain have finished and
    the delay time has passed, at which point the tween will start at the begin values and move towards the end values
    over the tween duration. If a tween end value is modified whilst the tween is playing on a character the character
    will adjust its interpolation accordingly. Modifying the duration whilst playing is undefined and not compatible
    with chains.

    :param int chain_id: ID of the chain to add to.
    :param int tween_id: ID of the tween to add.
    :param int text_id: ID of the text object containing the character.
    :param int char_index: Index of the character to modify, indices start at 0.
    :param Optional[Union[float, int]] delay: Number of seconds to wait before playing this tween when it is triggered.
    :rtype: None
    """
    pass    


def add_tween_chain_custom(chain_id: int, tween_id: int, delay: Optional[Union[float,
                           int]] = 0) -> None:
    """
    Adds the given custom tween ID to the end of the chain with an optional delay.

    The tween will not start until all preceding tweens in this chain have finished and the delay time has passed, at
    which point the tween will start at the begin values and move towards the end values over the tween duration. If a
    tween end value is modified whilst the tween is playing it will adjust its interpolation accordingly. Modifying the
    duration whilst playing is undefined and not compatible with chains.

    :param int chain_id: ID of the chain to add to.
    :param int tween_id: ID of the tween to add.
    :param Optional[Union[float, int]] delay: Number of seconds to wait before playing this tween when it is triggered.
    :rtype: None
    """
    pass    


def add_tween_chain_object(chain_id: int, tween_id: int, object_id: int,
                           delay: Optional[Union[float, int]] = 0) -> None:
    """
    Applies the given tween ID to a given object ID with an optional delay and adds it to the end of the chain.

    A tween can be added to multiple objects at the same time, simply call this command again with a different object
    ID. The object will not be modified until all preceding tweens in this chain have finished and the delay time has
    passed, at which point the tween will start at the begin values and move towards the end values over the tween
    duration. If a tween end value is modified whilst the tween is playing on an object the object will adjust its
    interpolation accordingly. Modifying the duration whilst playing is undefined and not compatible with chains.

    :param int chain_id: ID of the chain to add to.
    :param int tween_id: ID of the tween to add.
    :param int object_id: ID of the object to modify.
    :param Optional[Union[float, int]] delay: Number of seconds to wait before playing this tween when it is triggered.
    :rtype: None
    """
    pass    


def add_tween_chain_sprite(chain_id: int, tween_id: int, sprite_id: int,
                           delay: Optional[Union[float, int]] = 0) -> None:
    """
    Applies the given tween ID to a given sprite ID with an optional delay and adds it to the end of the chain.

    A tween can be added to multiple sprites at the same time, simply call this command again with a different sprite
    ID. The sprite will not be modified until all preceding tweens in this chain have finished and the delay time has
    passed, at which point the tween will start at the begin values and move towards the end values over the tween
    duration. If a tween end value is modified whilst the tween is playing on a sprite the sprite will adjust its
    interpolation accordingly. Modifying the duration whilst playing is undefined and not compatible with chains.

    :param int chain_id: ID of the chain to add to.
    :param int tween_id: ID of the tween to add.
    :param int sprite_id: ID of the sprite to modify.
    :param Optional[Union[float, int]] delay: Number of seconds to wait before playing this tween when it is triggered.
    :rtype: None
    """
    pass    


def add_tween_chain_text(chain_id: int, tween_id: int, text_id: int, delay: Optional[Union[float,
                         int]] = 0) -> None:
    """
    Applies the given tween ID to a given text object ID with an optional delay and adds it to the end of the chain.

    A tween can be added to multiple text objects at the same time, simply call this command again with a different text
    object ID. The text object will not be modified until all preceding tweens in this chain have finished and the delay
    time has passed, at which point the tween will start at the begin values and move towards the end values over the
    tween duration. If a tween end value is modified whilst the tween is playing on a text object the text will adjust
    its interpolation accordingly. Modifying the duration whilst playing is undefined and not compatible with chains.

    :param int chain_id: ID of the chain to add to.
    :param int tween_id: ID of the tween to add.
    :param int text_id: ID of the text to modify.
    :param Optional[Union[float, int]] delay: Number of seconds to wait before playing this tween when it is triggered.
    :rtype: None
    """
    pass    


def clear_tween_camera(tween_id: int) -> None:
    """
    Clears all tweens for the camera tween.

    :param int tween_id: ID of the tween.
    :rtype: None
    """
    pass    


def clear_tween_chain(chain_id: int) -> None:
    """
    Empties a chain of all tweens and stops any that were running.

    Any tweens that were added to it are unaffected and can be used in future chains.

    :param int chain_id: ID of the tween chain to clear.
    :rtype: None
    """
    pass    


def clear_tween_char(tween_id: int) -> None:
    """
    Clears all tweens for the char tween.

    :param int tween_id: ID of the tween.
    :rtype: None
    """
    pass    


def clear_tween_custom(tween_id: int) -> None:
    """
    Clears all tweens for the custom tween.

    :param int tween_id: ID of the tween.
    :rtype: None
    """
    pass    


def clear_tween_object(tween_id: int) -> None:
    """
    Clears all tweens for the object tween.

    :param int tween_id: ID of the tween.
    :rtype: None
    """
    pass    


def clear_tween_sprite(tween_id: int) -> None:
    """
    Clears all tweens for the sprite tween.

    :param int tween_id: ID of the tween.
    :rtype: None
    """
    pass    


def clear_tween_text(tween_id: int) -> None:
    """
    Clears all tweens for the text tween.

    :param int tween_id: ID of the tween.
    :rtype: None
    """
    pass    


def create_tween_camera(duration: Union[float, int]) -> int:
    """
    Creates an camera tween with a given duration and returns an ID for it.

    This tween is merely a template that can be applied to multiple cameras or chains at the same time. All tween types
    share the same ID space, so a camera tween of ID 1 cannot exist at the same time as an object tween with ID 1. You
    can set multiple parameters for this tween, such as X position and Angle, that will all move from their start values
    to their end values over the given duration.

    :param Union[float, int] duration: The duration of the tween in seconds.
    :rtype: int
    """
    pass    


def create_tween_id_camera(tween_id: int, duration: Union[float, int]) -> None:
    """
    Creates an camera tween with a given duration and returns an ID for it.

    This tween is merely a template that can be applied to multiple cameras or chains at the same time. All tween types
    share the same ID space, so a camera tween of ID 1 cannot exist at the same time as an object tween with ID 1. You
    can set multiple parameters for this tween, such as X position and Angle, that will all move from their start values
    to their end values over the given duration.

    :param int tween_id: ID of the tween.
    :param Union[float, int] duration: The duration of the tween in seconds.
    :rtype: None
    """
    pass    


def create_tween_chain() -> int:
    """
    Creates a tween chain that can be used to order tweens so they play one after the other.

    A tween chain can contain multiple sprites, characters, objects, etc, so that a camera tween can be triggered after
    a sprite tween has finished or vice versa. Multiple chains can be applied to the same sprites, objects, or others as
    long as the chains do not modify the same parameter at the same time. For example if chain 1 starts by modifying a
    sprites X value, and is played at the same time as chain 2 which also starts modifying the X value of the same
    sprite one chain will overwrite the changes of the other. Otherwise multiple chains on the same sprite will work
    correctly.

    :rtype: int
    """
    pass    


def create_tween_id_chain(chain_id: int) -> None:
    """
    Creates a tween chain that can be used to order tweens so they play one after the other.

    A tween chain can contain multiple sprites, characters, objects, etc, so that a camera tween can be triggered after
    a sprite tween has finished or vice versa. Multiple chains can be applied to the same sprites, objects, or others as
    long as the chains do not modify the same parameter at the same time. For example if chain 1 starts by modifying a
    sprites X value, and is played at the same time as chain 2 which also starts modifying the X value of the same
    sprite one chain will overwrite the changes of the other. Otherwise multiple chains on the same sprite will work
    correctly.

    :param int chain_id: ID of the chain.
    :rtype: None
    """
    pass    


def create_tween_char(duration: Union[float, int]) -> int:
    """
    Creates a char tween with a given duration and returns an ID for it.

    This can be applied to individual characters of a text object. This tween is merely a template that can be applied
    to multiple text characters or chains at the same time. All tween types share the same ID space, so a sprite tween
    of ID 1 cannot exist at the same time as a char tween with ID 1. You can set multiple parameters for this tween,
    such as X position and Angle, that will all move from their start values to their end values over the given
    duration.

    :param Union[float, int] duration: The duration of the tween in seconds.
    :rtype: int
    """
    pass    


def create_tween_id_char(tween_id: int, duration: Union[float, int]) -> None:
    """
    Creates a char tween with a given duration and returns an ID for it.

    This can be applied to individual characters of a text object. This tween is merely a template that can be applied
    to multiple text characters or chains at the same time. All tween types share the same ID space, so a sprite tween
    of ID 1 cannot exist at the same time as a char tween with ID 1. You can set multiple parameters for this tween,
    such as X position and Angle, that will all move from their start values to their end values over the given
    duration.

    :param int tween_id: ID of the tween.
    :param Union[float, int] duration: The duration of the tween in seconds.
    :rtype: None
    """
    pass    


def create_tween_custom(duration: Union[float, int]) -> int:
    """
    Creates a custom tween with a given duration and returns an ID for it.

    This tween is not associated with any item and its values can be read whilst it is running. This makes it useful for
    controlling values that are not covered by any of the other tween templates. All tween types share the same ID
    space, so a custom tween of ID 1 cannot exist at the same time as a sprite tween with ID 1. You can set multiple
    parameters for this tween, up to 4 float values and 4 integer values, that will all move from their start values to
    their end values over the given duration.

    :param Union[float, int] duration: The duration of the tween in seconds.
    :rtype: int
    """
    pass    


def create_tween_id_custom(tween_id: int, duration: Union[float, int]) -> None:
    """
    Creates a custom tween with a given duration and returns an ID for it.

    This tween is not associated with any item and its values can be read whilst it is running. This makes it useful for
    controlling values that are not covered by any of the other tween templates. All tween types share the same ID
    space, so a custom tween of ID 1 cannot exist at the same time as a sprite tween with ID 1. You can set multiple
    parameters for this tween, up to 4 float values and 4 integer values, that will all move from their start values to
    their end values over the given duration.

    :param int tween_id: ID of the tween.
    :param Union[float, int] duration: The duration of the tween in seconds.
    :rtype: None
    """
    pass    


def create_tween_id_object(tween_id: int, duration: Union[float, int]) -> None:
    """
    Creates an object tween with a given duration and returns an ID for it.

    This tween is merely a template that can be applied to multiple objects or chains at the same time. All tween types
    share the same ID space, so a sprite tween of ID 1 cannot exist at the same time as an object tween with ID 1. You
    can set multiple parameters for this tween, such as X position and Angle, that will all move from their start values
    to their end values over the given duration.

    :param int tween_id: ID of the tween.
    :param Union[float, int] duration: The duration of the tween in seconds.
    :rtype: None
    """
    pass    


def create_tween_object(duration: Union[float, int]) -> int:
    """
    Creates an object tween with a given duration and returns an ID for it.

    This tween is merely a template that can be applied to multiple objects or chains at the same time. All tween types
    share the same ID space, so a sprite tween of ID 1 cannot exist at the same time as an object tween with ID 1. You
    can set multiple parameters for this tween, such as X position and Angle, that will all move from their start values
    to their end values over the given duration.

    :param Union[float, int] duration: The duration of the tween in seconds.
    :rtype: int
    """
    pass    


def create_tween_id_sprite(tween_id: int, duration: Union[float, int]) -> None:
    """
    Creates a sprite tween with a given duration and returns an ID for it.

    This tween is merely a template that can be applied to multiple sprites or chains at the same time. All tween types
    share the same ID space, so a sprite tween of ID 1 cannot exist at the same time as a text tween with ID 1. You can
    set multiple parameters for this tween, such as X position and Angle, that will all move from their start values to
    their end values over the given duration.

    :param int tween_id: ID of the tween.
    :param Union[float, int] duration: The duration of the tween in seconds.
    :rtype: None
    """
    pass    


def create_tween_sprite(duration: Union[float, int]) -> int:
    """
    Creates a sprite tween with a given duration and returns an ID for it.

    This tween is merely a template that can be applied to multiple sprites or chains at the same time. All tween types
    share the same ID space, so a sprite tween of ID 1 cannot exist at the same time as a text tween with ID 1. You can
    set multiple parameters for this tween, such as X position and Angle, that will all move from their start values to
    their end values over the given duration.

    :param Union[float, int] duration: The duration of the tween in seconds.
    :rtype: int
    """
    pass    


def create_tween_id_text(tween_id: int, duration: Union[float, int]) -> None:
    """
    Creates a text tween with a given duration and returns an ID for it.

    This tween is merely a template that can be applied to multiple text objects or chains at the same time. All tween
    types share the same ID space, so a sprite tween of ID 1 cannot exist at the same time as a text tween with ID 1.
    You can set multiple parameters for this tween, such as X position and Angle, that will all move from their start
    values to their end values over the given duration.

    :param int tween_id: ID of the tween.
    :param Union[float, int] duration: The duration of the tween in seconds.
    :rtype: None
    """
    pass    


def create_tween_text(duration: Union[float, int]) -> int:
    """
    Creates a text tween with a given duration and returns an ID for it.

    This tween is merely a template that can be applied to multiple text objects or chains at the same time. All tween
    types share the same ID space, so a sprite tween of ID 1 cannot exist at the same time as a text tween with ID 1.
    You can set multiple parameters for this tween, such as X position and Angle, that will all move from their start
    values to their end values over the given duration.

    :param Union[float, int] duration: The duration of the tween in seconds.
    :rtype: int
    """
    pass    


def delete_tween(tween_id: int) -> None:
    """
    Delete a given tween ID.

    This can be used for all types of tween, sprite, text, object, etc.

    :param int tween_id: ID of the tween to delete.
    :rtype: None
    """
    pass    


def delete_tween_chain(chain_id: int) -> None:
    """
    Deletes a chain and stops any tweens that were associated with it.

    Any tweens that were added to it are unaffected and can be used in future chains.

    :param int chain_id: ID of the chain to delete.
    :rtype: None
    """
    pass    


def get_tween_camera_exists(tween_id: int) -> bool:
    """
    Returns True if a tween exists at the given ID and it is a camera tween, otherwise False.

    :param int tween_id: ID of the tween to check.
    :rtype: bool
    """
    pass    


def get_tween_camera_playing(tween_id: int, camera_id: int) -> bool:
    """
    Returns True if the given tween ID is currently playing on the given camera, otherwise False.

    This will still return True if the tween is currently paused.

    :param int tween_id: ID of the tween to check.
    :param int camera_id: ID of the camera to check.
    :rtype: bool
    """
    pass    


def get_tween_chain_end_time(chain_id: int) -> float:
    """
    Returns the total length of the tween chain in seconds.

    :param int chain_id: ID of the chain to check.
    :rtype: float
    """
    pass    


def get_tween_chain_playing(chain_id: int) -> bool:
    """
    Returns True if the chain is currently working through its list of tweens.

    If the last tween has finished or the chain has yet to be started it will return False.

    :param int chain_id: ID of the chain to check.
    :rtype: bool
    """
    pass    


def get_tween_char_end_time(tween_id: int, text_id: int, char_id: int) -> float:
    """
    Returns the end time of the tween char.

    :param int tween_id: ID of the tween.
    :param int text_id: ID of the text.
    :param int char_id: Index of the character to check, indices start at 0, if out of range it is ignored.
    :rtype: float
    """
    pass    


def get_tween_char_exists(tween_id: int) -> bool:
    """
    Returns True if a tween with the given ID exists and it is a char tween, otherwise False.

    :param int tween_id: ID of the tween to check.
    :rtype: bool
    """
    pass    


def get_tween_char_playing(tween_id: int, text_id: int, char_index: int) -> bool:
    """
    Returns True if the given tween ID is currently playing on the given character and text object, otherwise False.

    This will still return True if the tween is currently paused.

    :param int tween_id: ID of the tween to check.
    :param int text_id: ID of the text to check.
    :param int char_index: Index of the character to check, indices start at 0, if out of range it is ignored.
    :rtype: bool
    """
    pass    


def get_tween_char_time(tween_id: int, text_id: int, char_id: int) -> float:
    """
    Returns the current time of the tween char.

    :param int tween_id: ID of the tween.
    :param int text_id: ID of the text.
    :param int char_id: Index of the character to check, indices start at 0, if out of range it is ignored.
    :rtype: float
    """
    pass    


def get_tween_custom_end_time(tween_id: int) -> float:
    """
    Returns the end time of the custom tween.

    :param int tween_id: ID of the tween.
    :rtype: float
    """
    pass    


def get_tween_custom_exists(tween_id: int) -> bool:
    """
    Returns True if a tween with the given ID exists and it is a custom tween, otherwise False.

    :param int tween_id: ID of the tween to check.
    :rtype: bool
    """
    pass    


def get_tween_custom_float1(tween_id: int) -> float:
    """
    Returns the current value of the first float of the custom tween.

    :param int tween_id: ID of the tween to check.
    :rtype: float
    """
    pass    


def get_tween_custom_float2(tween_id: int) -> float:
    """
    Returns the current value of the second float of the custom tween.

    :param int tween_id: ID of the tween to check.
    :rtype: float
    """
    pass    


def get_tween_custom_float3(tween_id: int) -> float:
    """
    Returns the current value of the third float of the custom tween.

    :param int tween_id: ID of the tween to check.
    :rtype: float
    """
    pass    


def get_tween_custom_float4(tween_id: int) -> float:
    """
    Returns the current value of the fourth float of the custom tween.

    :param int tween_id: ID of the tween to check.
    :rtype: float
    """
    pass    


def get_tween_custom_integer1(tween_id: int) -> int:
    """
    Returns the current value of the first integer of the custom tween.

    :param int tween_id: ID of the tween to check.
    :rtype: int
    """
    pass    


def get_tween_custom_integer2(tween_id: int) -> int:
    """
    Returns the current value of the second integer of the custom tween.

    :param int tween_id: ID of the tween to check.
    :rtype: int
    """
    pass    


def get_tween_custom_integer3(tween_id: int) -> int:
    """
    Returns the current value of the third integer of the custom tween.

    :param int tween_id: ID of the tween to check.
    :rtype: int
    """
    pass    


def get_tween_custom_integer4(tween_id: int) -> int:
    """
    Returns the current value of the fourth integer of the custom tween.

    :param int tween_id: ID of the tween to check.
    :rtype: int
    """
    pass    


def get_tween_custom_playing(tween_id: int) -> bool:
    """
    Returns True if the given custom tween ID is currently playing, otherwise False.

    This will still return True if the tween is currently paused.

    :param int tween_id: ID of the tween to check.
    :rtype: bool
    """
    pass    


def get_tween_custom_time(tween_id: int) -> float:
    """
    Returns the current time of the custom tween.

    :param int tween_id: ID of the tween.
    :rtype: float
    """
    pass    


def get_tween_exists(tween_id: int) -> bool:
    """
    Returns True if a tween of any type exists at the given ID, False otherwise.

    :param int tween_id: ID of the tween to check.
    :rtype: bool
    """
    pass    


def get_tween_object_end_time(tween_id: int, object_id: int) -> float:
    """
    Returns the current end of the tween object.

    :param int tween_id: ID of the tween.
    :param int object_id: ID of the object.
    :rtype: float
    """
    pass    


def get_tween_object_exists(tween_id: int) -> bool:
    """
    Returns True if a tween exists at the given ID and it is an object tween, otherwise False.

    :param int tween_id: ID of the tween to check.
    :rtype: bool
    """
    pass    


def get_tween_object_playing(tween_id: int, object_id: int) -> bool:
    """
    Returns True if the given tween ID is currently playing on the given object, otherwise False.

    This will still return True if the tween is currently paused.

    :param int tween_id: ID of the tween to check.
    :param int object_id: ID of the object to check.
    :rtype: bool
    """
    pass    


def get_tween_object_time(tween_id: int, object_id: int) -> float:
    """
    Returns the current time of the tween object.

    :param int tween_id: ID of the tween.
    :param int object_id: ID of the object.
    :rtype: float
    """
    pass    


def get_tween_sprite_end_time(tween_id: int, sprite_id: int) -> float:
    """
    Returns the end time of the tween sprite.

    :param int tween_id: ID of the tween.
    :param int sprite_id: ID of the sprite.
    :rtype: float
    """
    pass    


def get_tween_sprite_exists(tween_id: int) -> bool:
    """
    Returns True if a tween with the given ID exists and it is a sprite tween, otherwise False.

    :param int tween_id: ID of the tween to check.
    :rtype: bool
    """
    pass    


def get_tween_sprite_playing(tween_id: int, sprite_id: int) -> bool:
    """
    Returns True if the given tween ID is currently playing on the given sprite, otherwise False.

    This will still return True if the tween is currently paused.

    :param int tween_id: ID of the tween to check.
    :param int sprite_id: ID of the sprite to check.
    :rtype: bool
    """
    pass    


def get_tween_sprite_time(tween_id: int, sprite_id: int) -> float:
    """
    Returns the current time of the tween sprite.

    :param int tween_id: ID of the tween.
    :param int sprite_id: ID of the sprite.
    :rtype: float
    """
    pass    


def get_tween_text_end_time(tween_id: int, text_id: int) -> float:
    """
    Returns the end time of the tween text.

    :param int tween_id: ID of the tween.
    :param int text_id: ID of the text.
    :rtype: float
    """
    pass    


def get_tween_text_exists(tween_id: int) -> bool:
    """
    Returns True if a tween with the given ID exists and it is a text tween, otherwise False.

    :param int tween_id: ID of the tween to check.
    :rtype: bool
    """
    pass    


def get_tween_text_playing(tween_id: int, text_id: int) -> bool:
    """
    Returns True if the given tween ID is currently playing on the given text object, otherwise False.

    This will still return True if the tween is currently paused.

    :param int tween_id: ID of the tween to check.
    :param int text_id: ID of the text to check.
    :rtype: bool
    """
    pass    


def get_tween_text_time(tween_id: int, text_id: int) -> float:
    """
    Returns the current time of the tween text.

    :param int tween_id: ID of the tween.
    :param int text_id: ID of the text.
    :rtype: float
    """
    pass    


def pause_tween_camera(tween_id: int, camera_id: int) -> None:
    """
    Pauses the given tween at its current point.

    It will not update again until `resume_tween_camera()` is called. If the tween has already stopped or doesn't exist
    then this does nothing.

    :param int tween_id: ID of the tween to pause.
    :param int camera_id: ID of the camera to pause.
    :rtype: None
    """
    pass    


def pause_tween_chain(chain_id: int) -> None:
    """
    Pauses the given chain that has started playing, it can be resumed with `play_tween_chain()`.

    :param int chain_id: ID of the chain to modify.
    :rtype: None
    """
    pass    


def pause_tween_char(tween_id: int, text_id: int, char_index: int) -> None:
    """
    Pauses the given tween at its current point.

    It will not update again until `resume_tween_char()` is called. If the tween has already stopped or doesn't exist
    then this does nothing.

    :param int tween_id: ID of the tween to pause.
    :param int text_id: ID of the text to pause.
    :param int char_index: Index of the character to pause.
    :rtype: None
    """
    pass    


def pause_tween_custom(tween_id: int) -> None:
    """
    Pauses the given tween at its current point.

    It will not update again until `resume_tween_custom()` is called. If the tween has already stopped or doesn't exist
    then this does nothing.

    :param int tween_id: ID of the tween to pause.
    :rtype: None
    """
    pass    


def pause_tween_object(tween_id: int, object_id: int) -> None:
    """
    Pauses the given tween at its current point.

    It will not update again until `resume_tween_object()` is called. If the tween has already stopped or doesn't exist
    then this does nothing.

    :param int tween_id: ID of the tween to pause.
    :param int object_id: ID of the object to pause.
    :rtype: None
    """
    pass    


def pause_tween_sprite(tween_id: int, sprite_id: int) -> None:
    """
    Pauses the given tween at its current point.

    It will not update again until `resume_tween_sprite()` is called. If the tween has already stopped or doesn't exist
    then this does nothing.

    :param int tween_id: ID of the tween to pause.
    :param int sprite_id: ID of the sprite to pause.
    :rtype: None
    """
    pass    


def pause_tween_text(tween_id: int, text_id: int) -> None:
    """
    Pauses the given tween at its current point.

    It will not update again until `resume_tween_text()` is called. If the tween has already stopped or doesn't exist
    then this does nothing.

    :param int tween_id: ID of the tween to pause.
    :param int text_id: ID of the text to pause.
    :rtype: None
    """
    pass    


def play_tween_camera(tween_id: int, camera_id: int, delay: Optional[Union[float,
                      int]] = 0) -> None:
    """
    Applies the given tween ID to a given camera ID with an optional delay and starts playing it.

    A tween can be played on multiple cameras at the same time, simply call this command again with a different camera
    ID. The camera will not be modified until the delay time has passed, at which point the tween will start at the
    begin values and move towards the end values over the tween duration. If A tween end value is modified whilst the
    tween is playing on a camera the camera will adjust its interpolation accordingly. Modifying the duration whilst
    playing is undefined and not compatible with chains.

    :param int tween_id: ID of the tween to use.
    :param int camera_id: ID of the camera to modify.
    :param Optional[Union[float, int]] delay: Number of seconds before the tween should start playing.
    :rtype: None
    """
    pass    


def play_tween_chain(chain_id: int) -> None:
    """
    Starts playing the given chain from the beginning or resumes it if it was paused.

    :param int chain_id: ID of the chain to modify.
    :rtype: None
    """
    pass    


def play_tween_char(tween_id: int, text_id: int, char_index: int, delay: Optional[Union[float,
                    int]] = 0) -> None:
    """
    Applies the given tween ID to a given character in a text object with an optional delay and starts playing it.

    A tween can be played on multiple characters across multiple text objects at the same time, simply call this command
    again with a different text or character ID. The character will not be modified until the delay time has passed, at
    which point the tween will start at the begin values and move towards the end values over the tween duration. If a
    tween end value is modified whilst the tween is playing on a character the character will adjust its interpolation
    accordingly. Modifying the duration whilst playing is undefined and not compatible with chains.

    :param int tween_id: ID of the tween to use.
    :param int text_id: ID of the text object to modify.
    :param int char_index: The index of the character, indices start at 0, if out of range it will be ignored.
    :param Optional[Union[float, int]] delay: Number of seconds before the tween should start playing.
    :rtype: None
    """
    pass    


def play_tween_custom(tween_id: int, delay: Optional[Union[float, int]] = 0) -> None:
    """
    Plays the given custom tween ID with an optional delay and starts playing it.

    Unlike other tweens this is not applied to any specific item or object and cannot have multiple copies running at
    the same time, you will have to create a separate custom tween for each copy you want to run simultaneously. The
    tween values will not be modified until the delay time has passed, at which point the tween will start at the begin
    values and move towards the end values over the tween duration. If a tween end value is modified whilst the tween is
    playing the tween will adjust its interpolation accordingly. Modifying the duration whilst playing is undefined and
    not compatible with chains.

    :param int tween_id: ID of the tween to use.
    :param Optional[Union[float, int]] delay: Number of seconds before the tween should start playing.
    :rtype: None
    """
    pass    


def play_tween_object(tween_id: int, object_id: int, delay: Optional[Union[float,
                      int]] = 0) -> None:
    """
    Applies the given tween ID to a given object ID with an optional delay and starts playing it.

    A tween can be played on multiple objects at the same time, simply call this command again with a different object
    ID. The object will not be modified until the delay time has passed, at which point the tween will start at the
    begin values and move towards the end values over the tween duration. If A tween end value is modified whilst the
    tween is playing on a object the object will adjust its interpolation accordingly. Modifying the duration whilst
    playing is undefined and not compatible with chains.

    :param int tween_id: ID of the tween to use.
    :param int object_id: ID of the object to modify.
    :param Optional[Union[float, int]] delay: Number of seconds before the tween should start playing.
    :rtype: None
    """
    pass    


def play_tween_sprite(tween_id: int, sprite_id: int, delay: Optional[Union[float,
                      int]] = 0) -> None:
    """
    Applies the given tween ID to a given sprite ID with an optional delay and starts playing it.

    A tween can be played on multiple sprites at the same time, simply call this command again with a different sprite
    ID. The sprite will not be modified until the delay time has passed, at which point the tween will start at the
    begin values and move towards the end values over the tween duration. If A tween end value is modified whilst the
    tween is playing on a sprite the sprite will adjust its interpolation accordingly. Modifying the duration whilst
    playing is undefined and not compatible with chains.

    :param int tween_id: ID of the tween to use.
    :param int sprite_id: ID of the sprite to modify.
    :param Optional[Union[float, int]] delay: Number of seconds before the tween should start playing.
    :rtype: None
    """
    pass    


def play_tween_text(tween_id: int, text_id: int, delay: Optional[Union[float, int]] = 0) -> None:
    """
    Applies the given tween ID to a given text ID with an optional delay and starts playing it.

    A tween can be played on multiple text objects at the same time, simply call this command again with a different
    text ID. The text will not be modified until the delay time has passed, at which point the tween will start at the
    begin values and move towards the end values over the tween duration. If A tween end value is modified whilst the
    tween is playing on a text object the text will adjust its interpolation accordingly. Modifying the duration whilst
    playing is undefined and not compatible with chains.

    :param int tween_id: ID of the tween to use.
    :param int text_id: ID of the text object to modify.
    :param Optional[Union[float, int]] delay: Number of seconds before the tween should start playing.
    :rtype: None
    """
    pass    


def resume_tween_camera(tween_id: int, camera_id: int) -> None:
    """
    Resumes the given tween from the point it was paused with `pause_tween_camera()`.

    If the tween is already resumed or doesn't exist then this does nothing.

    :param int tween_id: ID of the tween to resume.
    :param int camera_id: ID of the camera to resume.
    :rtype: None
    """
    pass    


def resume_tween_char(tween_id: int, text_id: int, char_index: int) -> None:
    """
    Resumes the given tween from the point it was paused with `pause_tween_char()`.

    If the tween is already resumed or doesn't exist then this does nothing.

    :param int tween_id: ID of the tween to resume.
    :param int text_id: ID of the text to resume.
    :param int char_index: Index of the character to resume.
    :rtype: None
    """
    pass    


def resume_tween_custom(tween_id: int) -> None:
    """
    Resumes the given tween from the point it was paused with `pause_tween_custom()`.

    If the tween is already resumed or doesn't exist then this does nothing.

    :param int tween_id: ID of the tween to resume.
    :rtype: None
    """
    pass    


def resume_tween_object(tween_id: int, object_id: int) -> None:
    """
    Resumes the given tween from the point it was paused with `pause_tween_object()`.

    If the tween is already resumed or doesn't exist then this does nothing.

    :param int tween_id: ID of the tween to resume.
    :param int object_id: ID of the object to resume.
    :rtype: None
    """
    pass    


def resume_tween_sprite(tween_id: int, sprite_id: int) -> None:
    """
    Resumes the given tween from the point it was paused with `pause_tween_sprite()`.

    If the tween is already resumed or doesn't exist then this does nothing.

    :param int tween_id: ID of the tween to resume.
    :param int sprite_id: ID of the sprite to resume.
    :rtype: None
    """
    pass    


def resume_tween_text(tween_id: int, text_id: int) -> None:
    """
    Resumes the given tween from the point it was paused with `pause_tween_text()`.

    If the tween is already resumed or doesn't exist then this does nothing.

    :param int tween_id: ID of the tween to resume.
    :param int text_id: ID of the text to resume.
    :rtype: None
    """
    pass    


def set_tween_camera_angle_x(tween_id: int, begin: Union[float, int], end: Union[float, int],
                             interpolation: int) -> None:
    """
    Sets the Euler AngleX parameter of the given tween ID.

    A tween can modify several parameters of a camera at the same time. Set the begin value and the end value and an
    interpolation method. A tween is just a template that can be applied to many cameras or chains at the same time with
    `play_tween_camera()` or `add_tween_chain_camera()`.

    Available interpolation methods are `tween_linear()`, `tween_smooth1()`, `tween_smooth2()`, `tween_ease_in1()`,
    `tween_ease_in2()`, `tween_ease_out1()`, `tween_ease_out2()`, `tween_bounce()`, `tween_overshoot()`. Use an
    interpolation method of -1 to turn off interpolation on this value.

    These constants within the module can also be used: TWEEN_OFF, TWEEN_LINEAR, TWEEN_SMOOTH1, TWEEN_SMOOTH2,
    TWEEN_EASE_IN1, TWEEN_EASE_IN2, TWEEN_EASE_OUT1, TWEEN_EASE_OUT2, TWEEN_BOUNCE, and TWEEN_OVERSHOOT.

    :param int tween_id: ID of the tween to modify.
    :param Union[float, int] begin: The starting Euler AngleX value for the camera, the camera will be rotated to this
        angle when playing starts.
    :param Union[float, int] end: The end Euler AngleX value for the camera, the camera will be rotated to this angle
        when playing ends.
    :param int interpolation: The interpolation method whilst the camera is moving from `begin` to `end`.
    :rtype: None
    """
    pass    


def set_tween_camera_angle_y(tween_id: int, begin: Union[float, int], end: Union[float, int],
                             interpolation: int) -> None:
    """
    Sets the Euler AngleY parameter of the given tween ID.

    A tween can modify several parameters of a camera at the same time. Set the begin value and the end value and an
    interpolation method. A tween is just a template that can be applied to many cameras or chains at the same time with
    `play_tween_camera()` or `add_tween_chain_camera()`.

    Available interpolation methods are `tween_linear()`, `tween_smooth1()`, `tween_smooth2()`, `tween_ease_in1()`,
    `tween_ease_in2()`, `tween_ease_out1()`, `tween_ease_out2()`, `tween_bounce()`, `tween_overshoot()`. Use an
    interpolation method of -1 to turn off interpolation on this value.

    These constants within the module can also be used: TWEEN_OFF, TWEEN_LINEAR, TWEEN_SMOOTH1, TWEEN_SMOOTH2,
    TWEEN_EASE_IN1, TWEEN_EASE_IN2, TWEEN_EASE_OUT1, TWEEN_EASE_OUT2, TWEEN_BOUNCE, and TWEEN_OVERSHOOT.

    :param int tween_id: ID of the tween to modify.
    :param Union[float, int] begin: The starting Euler AngleY value for the camera, the camera will be rotated to this
        angle when playing starts.
    :param Union[float, int] end: The end Euler AngleY value for the camera, the camera will be rotated to this angle
        when playing ends.
    :param int interpolation: The interpolation method whilst the camera is moving from `begin` to `end`.
    :rtype: None
    """
    pass    


def set_tween_camera_angle_z(tween_id: int, begin: Union[float, int], end: Union[float, int],
                             interpolation: int) -> None:
    """
    Sets the Euler AngleZ parameter of the given tween ID.

    A tween can modify several parameters of a camera at the same time. Set the begin value and the end value and an
    interpolation method. A tween is just a template that can be applied to many cameras or chains at the same time with
    `play_tween_camera()` or `add_tween_chain_camera()`.

    Available interpolation methods are `tween_linear()`, `tween_smooth1()`, `tween_smooth2()`, `tween_ease_in1()`,
    `tween_ease_in2()`, `tween_ease_out1()`, `tween_ease_out2()`, `tween_bounce()`, `tween_overshoot()`. Use an
    interpolation method of -1 to turn off interpolation on this value.

    These constants within the module can also be used: TWEEN_OFF, TWEEN_LINEAR, TWEEN_SMOOTH1, TWEEN_SMOOTH2,
    TWEEN_EASE_IN1, TWEEN_EASE_IN2, TWEEN_EASE_OUT1, TWEEN_EASE_OUT2, TWEEN_BOUNCE, and TWEEN_OVERSHOOT.

    :param int tween_id: ID of the tween to modify.
    :param Union[float, int] begin: The starting Euler AngleZ value for the camera, the camera will be rotated to this
        angle when playing starts.
    :param Union[float, int] end: The end Euler AngleZ value for the camera, the camera will be rotated to this angle
        when playing ends.
    :param int interpolation: The interpolation method whilst the camera is moving from `begin` to `end`.
    :rtype: None
    """
    pass    


def set_tween_camera_fov(tween_id: int, begin: Union[float, int], end: Union[float, int],
                         interpolation: int) -> None:
    """
    Sets the Field Of View parameter of the given tween ID.

    A tween can modify several parameters of a camera at the same time. Set the begin value and the end value and an
    interpolation method. A tween is just a template that can be applied to many cameras or chains at the same time with
    `play_tween_camera()` or `add_tween_chain_camera()`.

    Available interpolation methods are `tween_linear()`, `tween_smooth1()`, `tween_smooth2()`, `tween_ease_in1()`,
    `tween_ease_in2()`, `tween_ease_out1()`, `tween_ease_out2()`, `tween_bounce()`, `tween_overshoot()`. Use an
    interpolation method of -1 to turn off interpolation on this value.

    These constants within the module can also be used: TWEEN_OFF, TWEEN_LINEAR, TWEEN_SMOOTH1, TWEEN_SMOOTH2,
    TWEEN_EASE_IN1, TWEEN_EASE_IN2, TWEEN_EASE_OUT1, TWEEN_EASE_OUT2, TWEEN_BOUNCE, and TWEEN_OVERSHOOT.

    :param int tween_id: ID of the tween to modify.
    :param Union[float, int] begin: The starting FOV value for the camera, the camera will have this FOV value when
        playing starts.
    :param Union[float, int] end: The end FOV value for the camera, the camera will have this FOV value when playing
        ends.
    :param int interpolation: The interpolation method whilst the camera is moving from `begin` to `end`.
    :rtype: None
    """
    pass    


def set_tween_camera_x(tween_id: int, begin: Union[float, int], end: Union[float, int],
                       interpolation: int) -> None:
    """
    Sets the X parameter of the given tween ID.

    A tween can modify several parameters of a camera at the same time. Set the begin value and the end value and an
    interpolation method. A tween is just a template that can be applied to many cameras or chains at the same time with
    `play_tween_camera()` or `add_tween_chain_camera()`.

    Available interpolation methods are `tween_linear()`, `tween_smooth1()`, `tween_smooth2()`, `tween_ease_in1()`,
    `tween_ease_in2()`, `tween_ease_out1()`, `tween_ease_out2()`, `tween_bounce()`, `tween_overshoot()`. Use an
    interpolation method of -1 to turn off interpolation on this value.

    These constants within the module can also be used: TWEEN_OFF, TWEEN_LINEAR, TWEEN_SMOOTH1, TWEEN_SMOOTH2,
    TWEEN_EASE_IN1, TWEEN_EASE_IN2, TWEEN_EASE_OUT1, TWEEN_EASE_OUT2, TWEEN_BOUNCE, and TWEEN_OVERSHOOT.

    :param int tween_id: ID of the tween to modify.
    :param Union[float, int] begin: The starting X value for the camera, the camera will be positioned here when playing
        starts.
    :param Union[float, int] end: The end X value for the camera, the camera will be positioned here when playing ends.
    :param int interpolation: The interpolation method whilst the camera is moving from `begin` to `end`.
    :rtype: None
    """
    pass    


def set_tween_camera_y(tween_id: int, begin: Union[float, int], end: Union[float, int],
                       interpolation: int) -> None:
    """
    Sets the Y parameter of the given tween ID.

    A tween can modify several parameters of a camera at the same time. Set the begin value and the end value and an
    interpolation method. A tween is just a template that can be applied to many cameras or chains at the same time with
    `play_tween_camera()` or `add_tween_chain_camera()`.

    Available interpolation methods are `tween_linear()`, `tween_smooth1()`, `tween_smooth2()`, `tween_ease_in1()`,
    `tween_ease_in2()`, `tween_ease_out1()`, `tween_ease_out2()`, `tween_bounce()`, `tween_overshoot()`. Use an
    interpolation method of -1 to turn off interpolation on this value.

    These constants within the module can also be used: TWEEN_OFF, TWEEN_LINEAR, TWEEN_SMOOTH1, TWEEN_SMOOTH2,
    TWEEN_EASE_IN1, TWEEN_EASE_IN2, TWEEN_EASE_OUT1, TWEEN_EASE_OUT2, TWEEN_BOUNCE, and TWEEN_OVERSHOOT.

    :param int tween_id: ID of the tween to modify.
    :param Union[float, int] begin: The starting Y value for the camera, the camera will be positioned here when playing
        starts.
    :param Union[float, int] end: The end Y value for the camera, the camera will be positioned here when playing ends.
    :param int interpolation: The interpolation method whilst the camera is moving from `begin` to `end`.
    :rtype: None
    """
    pass    


def set_tween_camera_z(tween_id: int, begin: Union[float, int], end: Union[float, int],
                       interpolation: int) -> None:
    """
    Sets the Z parameter of the given tween ID.

    A tween can modify several parameters of a camera at the same time. Set the begin value and the end value and an
    interpolation method. A tween is just a template that can be applied to many cameras or chains at the same time with
    `play_tween_camera()` or `add_tween_chain_camera()`.

    Available interpolation methods are `tween_linear()`, `tween_smooth1()`, `tween_smooth2()`, `tween_ease_in1()`,
    `tween_ease_in2()`, `tween_ease_out1()`, `tween_ease_out2()`, `tween_bounce()`, `tween_overshoot()`. Use an
    interpolation method of -1 to turn off interpolation on this value.

    These constants within the module can also be used: TWEEN_OFF, TWEEN_LINEAR, TWEEN_SMOOTH1, TWEEN_SMOOTH2,
    TWEEN_EASE_IN1, TWEEN_EASE_IN2, TWEEN_EASE_OUT1, TWEEN_EASE_OUT2, TWEEN_BOUNCE, and TWEEN_OVERSHOOT.

    :param int tween_id: ID of the tween to modify.
    :param Union[float, int] begin: The starting Z value for the camera, the camera will be positioned here when playing
        starts.
    :param Union[float, int] end: The end Z value for the camera, the camera will be positioned here when playing ends.
    :param int interpolation: The interpolation method whilst the camera is moving from `begin` to `end`.
    :rtype: None
    """
    pass    


def set_tween_chain_time(chain_id: int, time: Union[float, int]) -> None:
    """
    Jumps a tween chain to the specified position in its time line.

    If the tween chain is currently playing then the interpolation will evaluate the given time value and update the
    necessary objects. If the tween chain is not playing then this command has no effect as calling `play_tween_chain()`
    resets the time to 0. If the time happens to fall on a delay between tweens then the interpolation will remain
    unchanged until the delay is passed.

    :param int chain_id: ID of the chain to modify.
    :param Union[float, int] time: The time in seconds to jump to in the tween chain.
    :rtype: None
    """
    pass    


def set_tween_char_alpha(tween_id: int, begin: int, end: int, interpolation: int) -> None:
    """
    Sets the alpha parameter of the given tween ID.

    A tween can modify several parameters of a character at the same time. Set the begin value and the end value and an
    interpolation method. A tween is just a template that can be applied to many characters or chains at the same time,
    including from different text objects, with `play_tween_char()` or `add_tween_chain_char()`.

    Available interpolation methods are `tween_linear()`, `tween_smooth1()`, `tween_smooth2()`, `tween_ease_in1()`,
    `tween_ease_in2()`, `tween_ease_out1()`, `tween_ease_out2()`, `tween_bounce()`, `tween_overshoot()`. Use an
    interpolation method of -1 to turn off interpolation on this value.

    These constants within the module can also be used: TWEEN_OFF, TWEEN_LINEAR, TWEEN_SMOOTH1, TWEEN_SMOOTH2,
    TWEEN_EASE_IN1, TWEEN_EASE_IN2, TWEEN_EASE_OUT1, TWEEN_EASE_OUT2, TWEEN_BOUNCE, and TWEEN_OVERSHOOT.

    :param int tween_id: ID of the tween to modify.
    :param int begin: The starting alpha value for the character, the character will be this color when playing starts.
    :param int end: The end alpha value for the character, the character will be this color when playing ends.
    :param int interpolation: The interpolation method whilst the character is moving from `begin` to `end`.
    :rtype: None
    """
    pass    


def set_tween_char_angle(tween_id: int, begin: Union[float, int], end: Union[float, int],
                         interpolation: int) -> None:
    """
    Sets the angle parameter of the given tween ID.

    A tween can modify several parameters of a character at the same time. Set the begin value and the end value and an
    interpolation method. A tween is just a template that can be applied to many characters or chains at the same time,
    including from different text objects, with `play_tween_char()` or `add_tween_chain_char()`.

    Available interpolation methods are `tween_linear()`, `tween_smooth1()`, `tween_smooth2()`, `tween_ease_in1()`,
    `tween_ease_in2()`, `tween_ease_out1()`, `tween_ease_out2()`, `tween_bounce()`, `tween_overshoot()`. Use an
    interpolation method of -1 to turn off interpolation on this value.

    These constants within the module can also be used: TWEEN_OFF, TWEEN_LINEAR, TWEEN_SMOOTH1, TWEEN_SMOOTH2,
    TWEEN_EASE_IN1, TWEEN_EASE_IN2, TWEEN_EASE_OUT1, TWEEN_EASE_OUT2, TWEEN_BOUNCE, and TWEEN_OVERSHOOT.

    :param int tween_id: ID of the tween to modify.
    :param Union[float, int] begin: The starting angle value for the character, the character will be rotated at this
        angle when playing starts.
    :param Union[float, int] end: The end angle value for the character, the character will be rotated at this angle
        when playing ends.
    :param int interpolation: The interpolation method whilst the character is moving from `begin` to `end`.
    :rtype: None
    """
    pass    


def set_tween_char_blue(tween_id: int, begin: int, end: int, interpolation: int) -> None:
    """
    Sets the blue parameter of the given tween ID.

    A tween can modify several parameters of a character at the same time. Set the begin value and the end value and an
    interpolation method. A tween is just a template that can be applied to many characters or chains at the same time,
    including from different text objects, with `play_tween_char()` or `add_tween_chain_char()`.

    Available interpolation methods are `tween_linear()`, `tween_smooth1()`, `tween_smooth2()`, `tween_ease_in1()`,
    `tween_ease_in2()`, `tween_ease_out1()`, `tween_ease_out2()`, `tween_bounce()`, `tween_overshoot()`. Use an
    interpolation method of -1 to turn off interpolation on this value.

    These constants within the module can also be used: TWEEN_OFF, TWEEN_LINEAR, TWEEN_SMOOTH1, TWEEN_SMOOTH2,
    TWEEN_EASE_IN1, TWEEN_EASE_IN2, TWEEN_EASE_OUT1, TWEEN_EASE_OUT2, TWEEN_BOUNCE, and TWEEN_OVERSHOOT.

    :param int tween_id: ID of the tween to modify.
    :param int begin: The starting blue value for the character, the character will be this color when playing starts.
    :param int end: The end blue value for the character, the character will be this color when playing ends.
    :param int interpolation: The interpolation method whilst the character is moving from `begin` to `end`.
    :rtype: None
    """
    pass    


def set_tween_char_green(tween_id: int, begin: int, end: int, interpolation: int) -> None:
    """
    Sets the green parameter of the given tween ID.

    A tween can modify several parameters of a character at the same time. Set the begin value and the end value and an
    interpolation method. A tween is just a template that can be applied to many characters or chains at the same time,
    including from different text objects, with `play_tween_char()` or `add_tween_chain_char()`.

    Available interpolation methods are `tween_linear()`, `tween_smooth1()`, `tween_smooth2()`, `tween_ease_in1()`,
    `tween_ease_in2()`, `tween_ease_out1()`, `tween_ease_out2()`, `tween_bounce()`, `tween_overshoot()`. Use an
    interpolation method of -1 to turn off interpolation on this value.

    These constants within the module can also be used: TWEEN_OFF, TWEEN_LINEAR, TWEEN_SMOOTH1, TWEEN_SMOOTH2,
    TWEEN_EASE_IN1, TWEEN_EASE_IN2, TWEEN_EASE_OUT1, TWEEN_EASE_OUT2, TWEEN_BOUNCE, and TWEEN_OVERSHOOT.

    :param int tween_id: ID of the tween to modify.
    :param int begin: The starting green value for the character, the character will be this color when playing starts.
    :param int end: The end green value for the character, the character will be this color when playing ends.
    :param int interpolation: The interpolation method whilst the character is moving from `begin` to `end`.
    :rtype: None
    """
    pass    


def set_tween_char_red(tween_id: int, begin: int, end: int, interpolation: int) -> None:
    """
    Sets the red parameter of the given tween ID.

    A tween can modify several parameters of a character at the same time. Set the begin value and the end value and an
    interpolation method. A tween is just a template that can be applied to many characters or chains at the same time,
    including from different text objects, with `play_tween_char()` or `add_tween_chain_char()`.

    Available interpolation methods are `tween_linear()`, `tween_smooth1()`, `tween_smooth2()`, `tween_ease_in1()`,
    `tween_ease_in2()`, `tween_ease_out1()`, `tween_ease_out2()`, `tween_bounce()`, `tween_overshoot()`. Use an
    interpolation method of -1 to turn off interpolation on this value.

    These constants within the module can also be used: TWEEN_OFF, TWEEN_LINEAR, TWEEN_SMOOTH1, TWEEN_SMOOTH2,
    TWEEN_EASE_IN1, TWEEN_EASE_IN2, TWEEN_EASE_OUT1, TWEEN_EASE_OUT2, TWEEN_BOUNCE, and TWEEN_OVERSHOOT.

    :param int tween_id: ID of the tween to modify.
    :param int begin: The starting red value for the character, the character will be this color when playing starts.
    :param int end: The end red value for the character, the character will be this color when playing ends.
    :param int interpolation: The interpolation method whilst the character is moving from `begin` to `end`.
    :rtype: None
    """
    pass    


def set_tween_char_x(tween_id: int, begin: Union[float, int], end: Union[float, int],
                     interpolation: int) -> None:
    """
    Sets the X parameter of the given tween ID.

    A tween can modify several parameters of a character at the same time. Set the begin value and the end value and an
    interpolation method. Character positions ar relative to the parent text object. A tween is just a template that can
    be applied to many characters or chains at the same time, including from different text objects, with
    `play_tween_char()` or `add_tween_chain_char()`.

    Available interpolation methods are `tween_linear()`, `tween_smooth1()`, `tween_smooth2()`, `tween_ease_in1()`,
    `tween_ease_in2()`, `tween_ease_out1()`, `tween_ease_out2()`, `tween_bounce()`, `tween_overshoot()`. Use an
    interpolation method of -1 to turn off interpolation on this value.

    These constants within the module can also be used: TWEEN_OFF, TWEEN_LINEAR, TWEEN_SMOOTH1, TWEEN_SMOOTH2,
    TWEEN_EASE_IN1, TWEEN_EASE_IN2, TWEEN_EASE_OUT1, TWEEN_EASE_OUT2, TWEEN_BOUNCE, and TWEEN_OVERSHOOT.

    :param int tween_id: ID of the tween to modify.
    :param Union[float, int] begin: The starting X value for the character, the character will be positioned here when
        playing starts.
    :param Union[float, int] end: The end X value for the character, the character will be positioned here when playing
        ends.
    :param int interpolation: The interpolation method whilst the character is moving from `begin` to `end`.
    :rtype: None
    """
    pass    


def set_tween_char_y(tween_id: int, begin: Union[float, int], end: Union[float, int],
                     interpolation: int) -> None:
    """
    Sets the Y parameter of the given tween ID.

    A tween can modify several parameters of a character at the same time. Set the begin value and the end value and an
    interpolation method. Character positions ar relative to the parent text object. A tween is just a template that can
    be applied to many characters or chains at the same time, including from different text objects, with
    `play_tween_char()` or `add_tween_chain_char()`.

    Available interpolation methods are `tween_linear()`, `tween_smooth1()`, `tween_smooth2()`, `tween_ease_in1()`,
    `tween_ease_in2()`, `tween_ease_out1()`, `tween_ease_out2()`, `tween_bounce()`, `tween_overshoot()`. Use an
    interpolation method of -1 to turn off interpolation on this value.

    These constants within the module can also be used: TWEEN_OFF, TWEEN_LINEAR, TWEEN_SMOOTH1, TWEEN_SMOOTH2,
    TWEEN_EASE_IN1, TWEEN_EASE_IN2, TWEEN_EASE_OUT1, TWEEN_EASE_OUT2, TWEEN_BOUNCE, and TWEEN_OVERSHOOT.

    :param int tween_id: ID of the tween to modify.
    :param Union[float, int] begin: The starting Y value for the character, the character will be positioned here when
        playing starts.
    :param Union[float, int] end: The end Y value for the character, the character will be positioned here when playing
        ends.
    :param int interpolation: The interpolation method whilst the character is moving from `begin` to `end`.
    :rtype: None
    """
    pass    


def set_tween_custom_float1(tween_id: int, begin: Union[float, int], end: Union[float, int],
                            interpolation: int) -> None:
    """
    Sets the first float value of the given custom tween ID.

    A tween can modify several parameters at the same time. Set the begin value and the end value and an interpolation
    method.

    Available interpolation methods are `tween_linear()`, `tween_smooth1()`, `tween_smooth2()`, `tween_ease_in1()`,
    `tween_ease_in2()`, `tween_ease_out1()`, `tween_ease_out2()`, `tween_bounce()`, `tween_overshoot()`. Use an
    interpolation method of -1 to turn off interpolation on this value.

    These constants within the module can also be used: TWEEN_OFF, TWEEN_LINEAR, TWEEN_SMOOTH1, TWEEN_SMOOTH2,
    TWEEN_EASE_IN1, TWEEN_EASE_IN2, TWEEN_EASE_OUT1, TWEEN_EASE_OUT2, TWEEN_BOUNCE, and TWEEN_OVERSHOOT.

    :param int tween_id: ID of the tween to modify.
    :param Union[float, int] begin: The starting point for this value.
    :param Union[float, int] end: The end point for this value.
    :param int interpolation: The interpolation method whilst the value is moving from begin to end.
    :rtype: None
    """
    pass    


def set_tween_custom_float2(tween_id: int, begin: Union[float, int], end: Union[float, int],
                            interpolation: int) -> None:
    """
    Sets the second float value of the given custom tween ID.

    A tween can modify several parameters at the same time. Set the begin value and the end value and an interpolation
    method.

    Available interpolation methods are `tween_linear()`, `tween_smooth1()`, `tween_smooth2()`, `tween_ease_in1()`,
    `tween_ease_in2()`, `tween_ease_out1()`, `tween_ease_out2()`, `tween_bounce()`, `tween_overshoot()`. Use an
    interpolation method of -1 to turn off interpolation on this value.

    These constants within the module can also be used: TWEEN_OFF, TWEEN_LINEAR, TWEEN_SMOOTH1, TWEEN_SMOOTH2,
    TWEEN_EASE_IN1, TWEEN_EASE_IN2, TWEEN_EASE_OUT1, TWEEN_EASE_OUT2, TWEEN_BOUNCE, and TWEEN_OVERSHOOT.

    :param int tween_id: ID of the tween to modify.
    :param Union[float, int] begin: The starting point for this value.
    :param Union[float, int] end: The end point for this value.
    :param int interpolation: The interpolation method whilst the value is moving from begin to end.
    :rtype: None
    """
    pass    


def set_tween_custom_float3(tween_id: int, begin: Union[float, int], end: Union[float, int],
                            interpolation: int) -> None:
    """
    Sets the third float value of the given custom tween ID.

    A tween can modify several parameters at the same time. Set the begin value and the end value and an interpolation
    method.

    Available interpolation methods are `tween_linear()`, `tween_smooth1()`, `tween_smooth2()`, `tween_ease_in1()`,
    `tween_ease_in2()`, `tween_ease_out1()`, `tween_ease_out2()`, `tween_bounce()`, `tween_overshoot()`. Use an
    interpolation method of -1 to turn off interpolation on this value.

    These constants within the module can also be used: TWEEN_OFF, TWEEN_LINEAR, TWEEN_SMOOTH1, TWEEN_SMOOTH2,
    TWEEN_EASE_IN1, TWEEN_EASE_IN2, TWEEN_EASE_OUT1, TWEEN_EASE_OUT2, TWEEN_BOUNCE, and TWEEN_OVERSHOOT.

    :param int tween_id: ID of the tween to modify.
    :param Union[float, int] begin: The starting point for this value.
    :param Union[float, int] end: The end point for this value.
    :param int interpolation: The interpolation method whilst the value is moving from begin to end.
    :rtype: None
    """
    pass    


def set_tween_custom_float4(tween_id: int, begin: Union[float, int], end: Union[float, int],
                            interpolation: int) -> None:
    """
    Sets the fourth float value of the given custom tween ID.

    A tween can modify several parameters at the same time. Set the begin value and the end value and an interpolation
    method.

    Available interpolation methods are `tween_linear()`, `tween_smooth1()`, `tween_smooth2()`, `tween_ease_in1()`,
    `tween_ease_in2()`, `tween_ease_out1()`, `tween_ease_out2()`, `tween_bounce()`, `tween_overshoot()`. Use an
    interpolation method of -1 to turn off interpolation on this value.

    These constants within the module can also be used: TWEEN_OFF, TWEEN_LINEAR, TWEEN_SMOOTH1, TWEEN_SMOOTH2,
    TWEEN_EASE_IN1, TWEEN_EASE_IN2, TWEEN_EASE_OUT1, TWEEN_EASE_OUT2, TWEEN_BOUNCE, and TWEEN_OVERSHOOT.

    :param int tween_id: ID of the tween to modify.
    :param Union[float, int] begin: The starting point for this value.
    :param Union[float, int] end: The end point for this value.
    :param int interpolation: The interpolation method whilst the value is moving from begin to end.
    :rtype: None
    """
    pass    


def set_tween_custom_integer1(tween_id: int, begin: int, end: int, interpolation: int) -> None:
    """
    Sets the first integer value of the given custom tween ID.

    A tween can modify several parameters at the same time. Set the begin value and the end value and an interpolation
    method.

    Available interpolation methods are `tween_linear()`, `tween_smooth1()`, `tween_smooth2()`, `tween_ease_in1()`,
    `tween_ease_in2()`, `tween_ease_out1()`, `tween_ease_out2()`, `tween_bounce()`, `tween_overshoot()`. Use an
    interpolation method of -1 to turn off interpolation on this value.

    These constants within the module can also be used: TWEEN_OFF, TWEEN_LINEAR, TWEEN_SMOOTH1, TWEEN_SMOOTH2,
    TWEEN_EASE_IN1, TWEEN_EASE_IN2, TWEEN_EASE_OUT1, TWEEN_EASE_OUT2, TWEEN_BOUNCE, and TWEEN_OVERSHOOT.

    :param int tween_id: ID of the tween to modify.
    :param int begin: The starting point for this value.
    :param int end: The end point for this value.
    :param int interpolation: The interpolation method whilst the value is moving from begin to end.
    :rtype: None
    """
    pass    


def set_tween_custom_integer2(tween_id: int, begin: int, end: int, interpolation: int) -> None:
    """
    Sets the second integer value of the given custom tween ID.

    A tween can modify several parameters at the same time. Set the begin value and the end value and an interpolation
    method.

    Available interpolation methods are `tween_linear()`, `tween_smooth1()`, `tween_smooth2()`, `tween_ease_in1()`,
    `tween_ease_in2()`, `tween_ease_out1()`, `tween_ease_out2()`, `tween_bounce()`, `tween_overshoot()`. Use an
    interpolation method of -1 to turn off interpolation on this value.

    These constants within the module can also be used: TWEEN_OFF, TWEEN_LINEAR, TWEEN_SMOOTH1, TWEEN_SMOOTH2,
    TWEEN_EASE_IN1, TWEEN_EASE_IN2, TWEEN_EASE_OUT1, TWEEN_EASE_OUT2, TWEEN_BOUNCE, and TWEEN_OVERSHOOT.

    :param int tween_id: ID of the tween to modify.
    :param int begin: The starting point for this value.
    :param int end: The end point for this value.
    :param int interpolation: The interpolation method whilst the value is moving from begin to end.
    :rtype: None
    """
    pass    


def set_tween_custom_integer3(tween_id: int, begin: int, end: int, interpolation: int) -> None:
    """
    Sets the third integer value of the given custom tween ID.

    A tween can modify several parameters at the same time. Set the begin value and the end value and an interpolation
    method.

    Available interpolation methods are `tween_linear()`, `tween_smooth1()`, `tween_smooth2()`, `tween_ease_in1()`,
    `tween_ease_in2()`, `tween_ease_out1()`, `tween_ease_out2()`, `tween_bounce()`, `tween_overshoot()`. Use an
    interpolation method of -1 to turn off interpolation on this value.

    These constants within the module can also be used: TWEEN_OFF, TWEEN_LINEAR, TWEEN_SMOOTH1, TWEEN_SMOOTH2,
    TWEEN_EASE_IN1, TWEEN_EASE_IN2, TWEEN_EASE_OUT1, TWEEN_EASE_OUT2, TWEEN_BOUNCE, and TWEEN_OVERSHOOT.

    :param int tween_id: ID of the tween to modify.
    :param int begin: The starting point for this value.
    :param int end: The end point for this value.
    :param int interpolation: The interpolation method whilst the value is moving from begin to end.
    :rtype: None
    """
    pass    


def set_tween_custom_integer4(tween_id: int, begin: int, end: int, interpolation: int) -> None:
    """
    Sets the fourth integer value of the given custom tween ID.

    A tween can modify several parameters at the same time. Set the begin value and the end value and an interpolation
    method.

    Available interpolation methods are `tween_linear()`, `tween_smooth1()`, `tween_smooth2()`, `tween_ease_in1()`,
    `tween_ease_in2()`, `tween_ease_out1()`, `tween_ease_out2()`, `tween_bounce()`, `tween_overshoot()`. Use an
    interpolation method of -1 to turn off interpolation on this value.

    These constants within the module can also be used: TWEEN_OFF, TWEEN_LINEAR, TWEEN_SMOOTH1, TWEEN_SMOOTH2,
    TWEEN_EASE_IN1, TWEEN_EASE_IN2, TWEEN_EASE_OUT1, TWEEN_EASE_OUT2, TWEEN_BOUNCE, and TWEEN_OVERSHOOT.

    :param int tween_id: ID of the tween to modify.
    :param int begin: The starting point for this value.
    :param int end: The end point for this value.
    :param int interpolation: The interpolation method whilst the value is moving from begin to end.
    :rtype: None
    """
    pass    


def set_tween_duration(tween_id: int, duration: Union[float, int]) -> None:
    """
    Changes a tween's duration after it has been created.

    If the tween is currently running or is part of a chain that is currently running, then changing its duration may
    produce unexpected results.

    :param int tween_id: ID of the tween to change, can be any type of tween.
    :param Union[float, int] duration: The new duration to use in seconds.
    :rtype: None
    """
    pass    


def set_tween_object_alpha(tween_id: int, begin: int, end: int, interpolation: int) -> None:
    """
    Sets the alpha parameter of the given tween ID in the range 0 to 255.

    A tween can modify several parameters of an object at the same time. Set the begin value and the end value and an
    interpolation method. A tween is just a template that can be applied to many objects or chains at the same time with
    `play_tween_object()` or `add_tween_chain_object()`.

    Available interpolation methods are `tween_linear()`, `tween_smooth1()`, `tween_smooth2()`, `tween_ease_in1()`,
    `tween_ease_in2()`, `tween_ease_out1()`, `tween_ease_out2()`, `tween_bounce()`, `tween_overshoot()`. Use an
    interpolation method of -1 to turn off interpolation on this value.

    These constants within the module can also be used: TWEEN_OFF, TWEEN_LINEAR, TWEEN_SMOOTH1, TWEEN_SMOOTH2,
    TWEEN_EASE_IN1, TWEEN_EASE_IN2, TWEEN_EASE_OUT1, TWEEN_EASE_OUT2, TWEEN_BOUNCE, and TWEEN_OVERSHOOT.

    :param int tween_id: ID of the tween to modify.
    :param int begin: The starting alpha color for the object, the object will be this color when playing starts.
    :param int end: The end alpha color for the object, the object will be this color when playing ends.
    :param int interpolation: The interpolation method whilst the object is moving from `begin` to `end`.
    :rtype: None
    """
    pass    


def set_tween_object_angle_x(tween_id: int, begin: Union[float, int], end: Union[float, int],
                             interpolation: int) -> None:
    """
    Sets the Euler AngleX parameter of the given tween ID.

    A tween can modify several parameters of an object at the same time. Set the begin value and the end value and an
    interpolation method. A tween is just a template that can be applied to many objects or chains at the same time with
    `play_tween_object()` or `add_tween_chain_object()`.

    Available interpolation methods are `tween_linear()`, `tween_smooth1()`, `tween_smooth2()`, `tween_ease_in1()`,
    `tween_ease_in2()`, `tween_ease_out1()`, `tween_ease_out2()`, `tween_bounce()`, `tween_overshoot()`. Use an
    interpolation method of -1 to turn off interpolation on this value.

    These constants within the module can also be used: TWEEN_OFF, TWEEN_LINEAR, TWEEN_SMOOTH1, TWEEN_SMOOTH2,
    TWEEN_EASE_IN1, TWEEN_EASE_IN2, TWEEN_EASE_OUT1, TWEEN_EASE_OUT2, TWEEN_BOUNCE, and TWEEN_OVERSHOOT.

    :param int tween_id: ID of the tween to modify.
    :param Union[float, int] begin: The starting AngleX value for the object, the object will be rotated to this angle
        when playing starts.
    :param Union[float, int] end: The end AngleX value for the object, the object will be rotated to this angle when
        playing ends.
    :param int interpolation: The interpolation method whilst the object is moving from `begin` to `end`.
    :rtype: None
    """
    pass    


def set_tween_object_angle_y(tween_id: int, begin: Union[float, int], end: Union[float, int],
                             interpolation: int) -> None:
    """
    Sets the Euler AngleY parameter of the given tween ID.

    A tween can modify several parameters of an object at the same time. Set the begin value and the end value and an
    interpolation method. A tween is just a template that can be applied to many objects or chains at the same time with
    `play_tween_object()` or `add_tween_chain_object()`.

    Available interpolation methods are `tween_linear()`, `tween_smooth1()`, `tween_smooth2()`, `tween_ease_in1()`,
    `tween_ease_in2()`, `tween_ease_out1()`, `tween_ease_out2()`, `tween_bounce()`, `tween_overshoot()`. Use an
    interpolation method of -1 to turn off interpolation on this value.

    These constants within the module can also be used: TWEEN_OFF, TWEEN_LINEAR, TWEEN_SMOOTH1, TWEEN_SMOOTH2,
    TWEEN_EASE_IN1, TWEEN_EASE_IN2, TWEEN_EASE_OUT1, TWEEN_EASE_OUT2, TWEEN_BOUNCE, and TWEEN_OVERSHOOT.

    :param int tween_id: ID of the tween to modify.
    :param Union[float, int] begin: The starting AngleY value for the object, the object will be rotated to this angle
        when playing starts.
    :param Union[float, int] end: The end AngleY value for the object, the object will be rotated to this angle when
        playing ends.
    :param int interpolation: The interpolation method whilst the object is moving from `begin` to `end`.
    :rtype: None
    """
    pass    


def set_tween_object_angle_z(tween_id: int, begin: Union[float, int], end: Union[float, int],
                             interpolation: int) -> None:
    """
    Sets the Euler AngleZ parameter of the given tween ID.

    A tween can modify several parameters of an object at the same time. Set the begin value and the end value and an
    interpolation method. A tween is just a template that can be applied to many objects or chains at the same time with
    `play_tween_object()` or `add_tween_chain_object()`.

    Available interpolation methods are `tween_linear()`, `tween_smooth1()`, `tween_smooth2()`, `tween_ease_in1()`,
    `tween_ease_in2()`, `tween_ease_out1()`, `tween_ease_out2()`, `tween_bounce()`, `tween_overshoot()`. Use an
    interpolation method of -1 to turn off interpolation on this value.

    These constants within the module can also be used: TWEEN_OFF, TWEEN_LINEAR, TWEEN_SMOOTH1, TWEEN_SMOOTH2,
    TWEEN_EASE_IN1, TWEEN_EASE_IN2, TWEEN_EASE_OUT1, TWEEN_EASE_OUT2, TWEEN_BOUNCE, and TWEEN_OVERSHOOT.

    :param int tween_id: ID of the tween to modify.
    :param Union[float, int] begin: The starting AngleZ value for the object, the object will be rotated to this angle
        when playing starts.
    :param Union[float, int] end: The end AngleZ value for the object, the object will be rotated to this angle when
        playing ends.
    :param int interpolation: The interpolation method whilst the object is moving from `begin` to `end`.
    :rtype: None
    """
    pass    


def set_tween_object_blue(tween_id: int, begin: int, end: int, interpolation: int) -> None:
    """
    Sets the blue parameter of the given tween ID in the range 0 to 255.

    A tween can modify several parameters of an object at the same time. Set the begin value and the end value and an
    interpolation method. A tween is just a template that can be applied to many objects or chains at the same time with
    `play_tween_object()` or `add_tween_chain_object()`.

    Available interpolation methods are `tween_linear()`, `tween_smooth1()`, `tween_smooth2()`, `tween_ease_in1()`,
    `tween_ease_in2()`, `tween_ease_out1()`, `tween_ease_out2()`, `tween_bounce()`, `tween_overshoot()`. Use an
    interpolation method of -1 to turn off interpolation on this value.

    These constants within the module can also be used: TWEEN_OFF, TWEEN_LINEAR, TWEEN_SMOOTH1, TWEEN_SMOOTH2,
    TWEEN_EASE_IN1, TWEEN_EASE_IN2, TWEEN_EASE_OUT1, TWEEN_EASE_OUT2, TWEEN_BOUNCE, and TWEEN_OVERSHOOT.

    :param int tween_id: ID of the tween to modify.
    :param int begin: The starting blue color for the object, the object will be this color when playing starts.
    :param int end: The end blue color for the object, the object will be this color when playing ends.
    :param int interpolation: The interpolation method whilst the object is moving from `begin` to `end`.
    :rtype: None
    """
    pass    


def set_tween_object_green(tween_id: int, begin: int, end: int, interpolation: int) -> None:
    """
    Sets the green parameter of the given tween ID in the range 0 to 255.

    A tween can modify several parameters of an object at the same time. Set the begin value and the end value and an
    interpolation method. A tween is just a template that can be applied to many objects or chains at the same time with
    `play_tween_object()` or `add_tween_chain_object()`.

    Available interpolation methods are `tween_linear()`, `tween_smooth1()`, `tween_smooth2()`, `tween_ease_in1()`,
    `tween_ease_in2()`, `tween_ease_out1()`, `tween_ease_out2()`, `tween_bounce()`, `tween_overshoot()`. Use an
    interpolation method of -1 to turn off interpolation on this value.

    These constants within the module can also be used: TWEEN_OFF, TWEEN_LINEAR, TWEEN_SMOOTH1, TWEEN_SMOOTH2,
    TWEEN_EASE_IN1, TWEEN_EASE_IN2, TWEEN_EASE_OUT1, TWEEN_EASE_OUT2, TWEEN_BOUNCE, and TWEEN_OVERSHOOT.

    :param int tween_id: ID of the tween to modify.
    :param int begin: The starting green color for the object, the object will be this color when playing starts.
    :param int end: The end green color for the object, the object will be this color when playing ends.
    :param int interpolation: The interpolation method whilst the object is moving from `begin` to `end`.
    :rtype: None
    """
    pass    


def set_tween_object_red(tween_id: int, begin: int, end: int, interpolation: int) -> None:
    """
    Sets the red parameter of the given tween ID in the range 0 to 255.

    A tween can modify several parameters of an object at the same time. Set the begin value and the end value and an
    interpolation method. A tween is just a template that can be applied to many objects or chains at the same time with
    `play_tween_object()` or `add_tween_chain_object()`.

    Available interpolation methods are `tween_linear()`, `tween_smooth1()`, `tween_smooth2()`, `tween_ease_in1()`,
    `tween_ease_in2()`, `tween_ease_out1()`, `tween_ease_out2()`, `tween_bounce()`, `tween_overshoot()`. Use an
    interpolation method of -1 to turn off interpolation on this value.

    These constants within the module can also be used: TWEEN_OFF, TWEEN_LINEAR, TWEEN_SMOOTH1, TWEEN_SMOOTH2,
    TWEEN_EASE_IN1, TWEEN_EASE_IN2, TWEEN_EASE_OUT1, TWEEN_EASE_OUT2, TWEEN_BOUNCE, and TWEEN_OVERSHOOT.

    :param int tween_id: ID of the tween to modify.
    :param int begin: The starting red color for the object, the object will be this color when playing starts.
    :param int end: The end red color for the object, the object will be this color when playing ends.
    :param int interpolation: The interpolation method whilst the object is moving from `begin` to `end`.
    :rtype: None
    """
    pass    


def set_tween_object_scale_x(tween_id: int, begin: Union[float, int], end: Union[float, int],
                             interpolation: int) -> None:
    """
    Sets the ScaleX parameter of the given tween ID.

    The scale is absolute so a value of 1.0 will be normal size, whilst 2.0 would be two times bigger. A Tween can
    modify several parameters of an object at the same time. Set the begin value and the end value and an interpolation
    method. A tween is just a template that can be applied to many objects or chains at the same time with
    `play_tween_object()` or `add_tween_chain_object()`.

    Available interpolation methods are `tween_linear()`, `tween_smooth1()`, `tween_smooth2()`, `tween_ease_in1()`,
    `tween_ease_in2()`, `tween_ease_out1()`, `tween_ease_out2()`, `tween_bounce()`, `tween_overshoot()`. Use an
    interpolation method of -1 to turn off interpolation on this value.

    These constants within the module can also be used: TWEEN_OFF, TWEEN_LINEAR, TWEEN_SMOOTH1, TWEEN_SMOOTH2,
    TWEEN_EASE_IN1, TWEEN_EASE_IN2, TWEEN_EASE_OUT1, TWEEN_EASE_OUT2, TWEEN_BOUNCE, and TWEEN_OVERSHOOT.

    :param int tween_id: ID of the tween to modify.
    :param Union[float, int] begin: The starting ScaleX value for the object, the object will be rotated to this angle
        when playing starts.
    :param Union[float, int] end: The end ScaleX value for the object, the object will be rotated to this angle when
        playing ends.
    :param int interpolation: The interpolation method whilst the object is moving from `begin` to `end`.
    :rtype: None
    """
    pass    


def set_tween_object_scale_y(tween_id: int, begin: Union[float, int], end: Union[float, int],
                             interpolation: int) -> None:
    """
    Sets the ScaleY parameter of the given tween ID.

    The scale is absolute so a value of 1.0 will be normal size, whilst 2.0 would be two times bigger. A Tween can
    modify several parameters of an object at the same time. Set the begin value and the end value and an interpolation
    method. A tween is just a template that can be applied to many objects or chains at the same time with
    `play_tween_object()` or `add_tween_chain_object()`.

    Available interpolation methods are `tween_linear()`, `tween_smooth1()`, `tween_smooth2()`, `tween_ease_in1()`,
    `tween_ease_in2()`, `tween_ease_out1()`, `tween_ease_out2()`, `tween_bounce()`, `tween_overshoot()`. Use an
    interpolation method of -1 to turn off interpolation on this value.

    These constants within the module can also be used: TWEEN_OFF, TWEEN_LINEAR, TWEEN_SMOOTH1, TWEEN_SMOOTH2,
    TWEEN_EASE_IN1, TWEEN_EASE_IN2, TWEEN_EASE_OUT1, TWEEN_EASE_OUT2, TWEEN_BOUNCE, and TWEEN_OVERSHOOT.

    :param int tween_id: ID of the tween to modify.
    :param Union[float, int] begin: The starting ScaleY value for the object, the object will be rotated to this angle
        when playing starts.
    :param Union[float, int] end: The end ScaleY value for the object, the object will be rotated to this angle when
        playing ends.
    :param int interpolation: The interpolation method whilst the object is moving from `begin` to `end`.
    :rtype: None
    """
    pass    


def set_tween_object_scale_z(tween_id: int, begin: Union[float, int], end: Union[float, int],
                             interpolation: int) -> None:
    """
    Sets the ScaleZ parameter of the given tween ID.

    The scale is absolute so a value of 1.0 will be normal size, whilst 2.0 would be two times bigger. A Tween can
    modify several parameters of an object at the same time. Set the begin value and the end value and an interpolation
    method. A tween is just a template that can be applied to many objects or chains at the same time with
    `play_tween_object()` or `add_tween_chain_object()`.

    Available interpolation methods are `tween_linear()`, `tween_smooth1()`, `tween_smooth2()`, `tween_ease_in1()`,
    `tween_ease_in2()`, `tween_ease_out1()`, `tween_ease_out2()`, `tween_bounce()`, `tween_overshoot()`. Use an
    interpolation method of -1 to turn off interpolation on this value.

    These constants within the module can also be used: TWEEN_OFF, TWEEN_LINEAR, TWEEN_SMOOTH1, TWEEN_SMOOTH2,
    TWEEN_EASE_IN1, TWEEN_EASE_IN2, TWEEN_EASE_OUT1, TWEEN_EASE_OUT2, TWEEN_BOUNCE, and TWEEN_OVERSHOOT.

    :param int tween_id: ID of the tween to modify.
    :param Union[float, int] begin: The starting ScaleY value for the object, the object will be rotated to this angle
        when playing starts.
    :param Union[float, int] end: The end ScaleY value for the object, the object will be rotated to this angle when
        playing ends.
    :param int interpolation: The interpolation method whilst the object is moving from `begin` to `end`.
    :rtype: None
    """
    pass    


def set_tween_object_x(tween_id: int, begin: Union[float, int], end: Union[float, int],
                       interpolation: int) -> None:
    """
    Sets the X parameter of the given tween ID.

    A tween can modify several parameters of an object at the same time. Set the begin value and the end value and an
    interpolation method. A tween is just a template that can be applied to many objects or chains at the same time with
    `play_tween_object()` or `add_tween_chain_object()`.

    Available interpolation methods are `tween_linear()`, `tween_smooth1()`, `tween_smooth2()`, `tween_ease_in1()`,
    `tween_ease_in2()`, `tween_ease_out1()`, `tween_ease_out2()`, `tween_bounce()`, `tween_overshoot()`. Use an
    interpolation method of -1 to turn off interpolation on this value.

    These constants within the module can also be used: TWEEN_OFF, TWEEN_LINEAR, TWEEN_SMOOTH1, TWEEN_SMOOTH2,
    TWEEN_EASE_IN1, TWEEN_EASE_IN2, TWEEN_EASE_OUT1, TWEEN_EASE_OUT2, TWEEN_BOUNCE, and TWEEN_OVERSHOOT.

    :param int tween_id: ID of the tween to modify.
    :param Union[float, int] begin: The starting X value for the object, the object will be positioned here when playing
        starts.
    :param Union[float, int] end: The end X value for the object, the object will be positioned here when playing ends.
    :param int interpolation: The interpolation method whilst the object is moving from `begin` to `end`.
    :rtype: None
    """
    pass    


def set_tween_object_y(tween_id: int, begin: Union[float, int], end: Union[float, int],
                       interpolation: int) -> None:
    """
    Sets the Y parameter of the given tween ID.

    A tween can modify several parameters of an object at the same time. Set the begin value and the end value and an
    interpolation method. A tween is just a template that can be applied to many objects or chains at the same time with
    `play_tween_object()` or `add_tween_chain_object()`.

    Available interpolation methods are `tween_linear()`, `tween_smooth1()`, `tween_smooth2()`, `tween_ease_in1()`,
    `tween_ease_in2()`, `tween_ease_out1()`, `tween_ease_out2()`, `tween_bounce()`, `tween_overshoot()`. Use an
    interpolation method of -1 to turn off interpolation on this value.

    These constants within the module can also be used: TWEEN_OFF, TWEEN_LINEAR, TWEEN_SMOOTH1, TWEEN_SMOOTH2,
    TWEEN_EASE_IN1, TWEEN_EASE_IN2, TWEEN_EASE_OUT1, TWEEN_EASE_OUT2, TWEEN_BOUNCE, and TWEEN_OVERSHOOT.

    :param int tween_id: ID of the tween to modify.
    :param Union[float, int] begin: The starting Y value for the object, the object will be positioned here when playing
        starts.
    :param Union[float, int] end: The end Y value for the object, the object will be positioned here when playing ends.
    :param int interpolation: The interpolation method whilst the object is moving from `begin` to `end`.
    :rtype: None
    """
    pass    


def set_tween_object_z(tween_id: int, begin: Union[float, int], end: Union[float, int],
                       interpolation: int) -> None:
    """
    Sets the Z parameter of the given tween ID.

    A tween can modify several parameters of an object at the same time. Set the begin value and the end value and an
    interpolation method. A tween is just a template that can be applied to many objects or chains at the same time with
    `play_tween_object()` or `add_tween_chain_object()`.

    Available interpolation methods are `tween_linear()`, `tween_smooth1()`, `tween_smooth2()`, `tween_ease_in1()`,
    `tween_ease_in2()`, `tween_ease_out1()`, `tween_ease_out2()`, `tween_bounce()`, `tween_overshoot()`. Use an
    interpolation method of -1 to turn off interpolation on this value.

    These constants within the module can also be used: TWEEN_OFF, TWEEN_LINEAR, TWEEN_SMOOTH1, TWEEN_SMOOTH2,
    TWEEN_EASE_IN1, TWEEN_EASE_IN2, TWEEN_EASE_OUT1, TWEEN_EASE_OUT2, TWEEN_BOUNCE, and TWEEN_OVERSHOOT.

    :param int tween_id: ID of the tween to modify.
    :param Union[float, int] begin: The starting Z value for the object, the object will be positioned here when playing
        starts.
    :param Union[float, int] end: The end Z value for the object, the object will be positioned here when playing ends.
    :param int interpolation: The interpolation method whilst the object is moving from `begin` to `end`.
    :rtype: None
    """
    pass    


def set_tween_sprite_alpha(tween_id: int, begin: int, end: int, interpolation: int) -> None:
    """
    Sets the alpha parameter of the given tween ID.

    A tween can modify several parameters of a sprite at the same time. Set the begin value and the end value and an
    interpolation method. A tween is just a template that can be applied to many sprites or chains at the same time with
    `play_tween_sprite()` or `add_tween_chain_sprite()`.

    Available interpolation methods are `tween_linear()`, `tween_smooth1()`, `tween_smooth2()`, `tween_ease_in1()`,
    `tween_ease_in2()`, `tween_ease_out1()`, `tween_ease_out2()`, `tween_bounce()`, `tween_overshoot()`. Use an
    interpolation method of -1 to turn off interpolation on this value.

    These constants within the module can also be used: TWEEN_OFF, TWEEN_LINEAR, TWEEN_SMOOTH1, TWEEN_SMOOTH2,
    TWEEN_EASE_IN1, TWEEN_EASE_IN2, TWEEN_EASE_OUT1, TWEEN_EASE_OUT2, TWEEN_BOUNCE, and TWEEN_OVERSHOOT.

    :param int tween_id: ID of the tween to modify.
    :param int begin: The starting alpha color for the sprite (0 to 255), the sprite will be this color when playing
        starts.
    :param int end: The end alpha color for the sprite (0 to 255), the sprite will be this color when playing ends.
    :param int interpolation: The interpolation method whilst the sprite is moving from `begin` to `end`.
    :rtype: None
    """
    pass    


def set_tween_sprite_angle(tween_id: int, begin: Union[float, int], end: Union[float, int],
                           interpolation: int) -> None:
    """
    Sets the angle parameter of the given tween ID.

    A tween can modify several parameters of a sprite at the same time. Set the begin value and the end value and an
    interpolation method. A tween is just a template that can be applied to many sprites or chains at the same time with
    `play_tween_sprite()` or `add_tween_chain_sprite()`.

    Available interpolation methods are `tween_linear()`, `tween_smooth1()`, `tween_smooth2()`, `tween_ease_in1()`,
    `tween_ease_in2()`, `tween_ease_out1()`, `tween_ease_out2()`, `tween_bounce()`, `tween_overshoot()`. Use an
    interpolation method of -1 to turn off interpolation on this value.

    These constants within the module can also be used: TWEEN_OFF, TWEEN_LINEAR, TWEEN_SMOOTH1, TWEEN_SMOOTH2,
    TWEEN_EASE_IN1, TWEEN_EASE_IN2, TWEEN_EASE_OUT1, TWEEN_EASE_OUT2, TWEEN_BOUNCE, and TWEEN_OVERSHOOT.

    :param int tween_id: ID of the tween to modify.
    :param Union[float, int] begin: The starting angle value for the sprite, the sprite will be rotated at this angle
        when playing starts.
    :param Union[float, int] end: The end angle value for the sprite, the sprite will be rotated at this angle when
        playing ends.
    :param int interpolation: The interpolation method whilst the sprite is rotating from `begin` to `end`.
    :rtype: None
    """
    pass    


def set_tween_sprite_blue(tween_id: int, begin: int, end: int, interpolation: int) -> None:
    """
    Sets the blue parameter of the given tween ID.

    A tween can modify several parameters of a sprite at the same time. Set the begin value and the end value and an
    interpolation method. A tween is just a template that can be applied to many sprites or chains at the same time with
    `play_tween_sprite()` or `add_tween_chain_sprite()`.

    Available interpolation methods are `tween_linear()`, `tween_smooth1()`, `tween_smooth2()`, `tween_ease_in1()`,
    `tween_ease_in2()`, `tween_ease_out1()`, `tween_ease_out2()`, `tween_bounce()`, `tween_overshoot()`. Use an
    interpolation method of -1 to turn off interpolation on this value.

    These constants within the module can also be used: TWEEN_OFF, TWEEN_LINEAR, TWEEN_SMOOTH1, TWEEN_SMOOTH2,
    TWEEN_EASE_IN1, TWEEN_EASE_IN2, TWEEN_EASE_OUT1, TWEEN_EASE_OUT2, TWEEN_BOUNCE, and TWEEN_OVERSHOOT.

    :param int tween_id: ID of the tween to modify.
    :param int begin: The starting blue color for the sprite (0 to 255), the sprite will be this color when playing
        starts.
    :param int end: The end blue color for the sprite (0 to 255), the sprite will be this color when playing ends.
    :param int interpolation: The interpolation method whilst the sprite is moving from `begin` to `end`.
    :rtype: None
    """
    pass    


def set_tween_sprite_green(tween_id: int, begin: int, end: int, interpolation: int) -> None:
    """
    Sets the green parameter of the given tween ID.

    A tween can modify several parameters of a sprite at the same time. Set the begin value and the end value and an
    interpolation method. A tween is just a template that can be applied to many sprites or chains at the same time with
    `play_tween_sprite()` or `add_tween_chain_sprite()`.

    Available interpolation methods are `tween_linear()`, `tween_smooth1()`, `tween_smooth2()`, `tween_ease_in1()`,
    `tween_ease_in2()`, `tween_ease_out1()`, `tween_ease_out2()`, `tween_bounce()`, `tween_overshoot()`. Use an
    interpolation method of -1 to turn off interpolation on this value.

    These constants within the module can also be used: TWEEN_OFF, TWEEN_LINEAR, TWEEN_SMOOTH1, TWEEN_SMOOTH2,
    TWEEN_EASE_IN1, TWEEN_EASE_IN2, TWEEN_EASE_OUT1, TWEEN_EASE_OUT2, TWEEN_BOUNCE, and TWEEN_OVERSHOOT.

    :param int tween_id: ID of the tween to modify.
    :param int begin: The starting green color for the sprite (0 to 255), the sprite will be this color when playing
        starts.
    :param int end: The end green color for the sprite (0 to 255), the sprite will be this color when playing ends.
    :param int interpolation: The interpolation method whilst the sprite is moving from `begin` to `end`.
    :rtype: None
    """
    pass    


def set_tween_sprite_red(tween_id: int, begin: int, end: int, interpolation: int) -> None:
    """
    Sets the red parameter of the given tween ID.

    A tween can modify several parameters of a sprite at the same time. Set the begin value and the end value and an
    interpolation method. A tween is just a template that can be applied to many sprites or chains at the same time with
    `play_tween_sprite()` or `add_tween_chain_sprite()`.

    Available interpolation methods are `tween_linear()`, `tween_smooth1()`, `tween_smooth2()`, `tween_ease_in1()`,
    `tween_ease_in2()`, `tween_ease_out1()`, `tween_ease_out2()`, `tween_bounce()`, `tween_overshoot()`. Use an
    interpolation method of -1 to turn off interpolation on this value.

    These constants within the module can also be used: TWEEN_OFF, TWEEN_LINEAR, TWEEN_SMOOTH1, TWEEN_SMOOTH2,
    TWEEN_EASE_IN1, TWEEN_EASE_IN2, TWEEN_EASE_OUT1, TWEEN_EASE_OUT2, TWEEN_BOUNCE, and TWEEN_OVERSHOOT.

    :param int tween_id: ID of the tween to modify.
    :param int begin: The starting red color for the sprite (0 to 255), the sprite will be this color when playing
        starts.
    :param int end: The end red color for the sprite (0 to 255), the sprite will be this color when playing ends.
    :param int interpolation: The interpolation method whilst the sprite is moving from `begin` to `end`.
    :rtype: None
    """
    pass    


def set_tween_sprite_size_x(tween_id: int, begin: Union[float, int], end: Union[float, int],
                            interpolation: int) -> None:
    """
    Sets the SizeX parameter of the given tween ID.

    A tween can modify several parameters of a sprite at the same time. Set the begin value and the end value and an
    interpolation method. A tween is just a template that can be applied to many sprites or chains at the same time with
    `play_tween_sprite()` or `add_tween_chain_sprite()`.

    Available interpolation methods are `tween_linear()`, `tween_smooth1()`, `tween_smooth2()`, `tween_ease_in1()`,
    `tween_ease_in2()`, `tween_ease_out1()`, `tween_ease_out2()`, `tween_bounce()`, `tween_overshoot()`. Use an
    interpolation method of -1 to turn off interpolation on this value.

    These constants within the module can also be used: TWEEN_OFF, TWEEN_LINEAR, TWEEN_SMOOTH1, TWEEN_SMOOTH2,
    TWEEN_EASE_IN1, TWEEN_EASE_IN2, TWEEN_EASE_OUT1, TWEEN_EASE_OUT2, TWEEN_BOUNCE, and TWEEN_OVERSHOOT.

    :param int tween_id: ID of the tween to modify.
    :param Union[float, int] begin: The starting SizeX value for the sprite, the sprite will be this size when playing
        starts.
    :param Union[float, int] end: The end SizeX value for the sprite, the sprite will be this size when playing ends.
    :param int interpolation: The interpolation method whilst the sprite is moving from `begin` to `end`.
    :rtype: None
    """
    pass    


def set_tween_sprite_size_y(tween_id: int, begin: Union[float, int], end: Union[float, int],
                            interpolation: int) -> None:
    """
    Sets the SizeY parameter of the given tween ID.

    A tween can modify several parameters of a sprite at the same time. Set the begin value and the end value and an
    interpolation method. A tween is just a template that can be applied to many sprites or chains at the same time with
    `play_tween_sprite()` or `add_tween_chain_sprite()`.

    Available interpolation methods are `tween_linear()`, `tween_smooth1()`, `tween_smooth2()`, `tween_ease_in1()`,
    `tween_ease_in2()`, `tween_ease_out1()`, `tween_ease_out2()`, `tween_bounce()`, `tween_overshoot()`. Use an
    interpolation method of -1 to turn off interpolation on this value.

    These constants within the module can also be used: TWEEN_OFF, TWEEN_LINEAR, TWEEN_SMOOTH1, TWEEN_SMOOTH2,
    TWEEN_EASE_IN1, TWEEN_EASE_IN2, TWEEN_EASE_OUT1, TWEEN_EASE_OUT2, TWEEN_BOUNCE, and TWEEN_OVERSHOOT.

    :param int tween_id: ID of the tween to modify.
    :param Union[float, int] begin: The starting SizeY value for the sprite, the sprite will be this size when playing
        starts.
    :param Union[float, int] end: The end SizeY value for the sprite, the sprite will be this size when playing ends.
    :param int interpolation: The interpolation method whilst the sprite is moving from beginSX to endSX.
    :rtype: None
    """
    pass    


def set_tween_sprite_x(tween_id: int, begin: Union[float, int], end: Union[float, int],
                       interpolation: int) -> None:
    """
    Sets the X parameter of the given tween ID.

    A tween can modify several parameters of a sprite at the same time. Set the begin value and the end value and an
    interpolation method. A tween is just a template that can be applied to many sprites or chains at the same time with
    `play_tween_sprite()` or `add_tween_chain_sprite()`. This modifies the position of the sprite using its top left
    corner.

    Available interpolation methods are `tween_linear()`, `tween_smooth1()`, `tween_smooth2()`, `tween_ease_in1()`,
    `tween_ease_in2()`, `tween_ease_out1()`, `tween_ease_out2()`, `tween_bounce()`, `tween_overshoot()`. Use an
    interpolation method of -1 to turn off interpolation on this value.

    These constants within the module can also be used: TWEEN_OFF, TWEEN_LINEAR, TWEEN_SMOOTH1, TWEEN_SMOOTH2,
    TWEEN_EASE_IN1, TWEEN_EASE_IN2, TWEEN_EASE_OUT1, TWEEN_EASE_OUT2, TWEEN_BOUNCE, and TWEEN_OVERSHOOT.

    :param int tween_id: ID of the tween to modify.
    :param Union[float, int] begin: The starting X value for the sprite, the sprite will be positioned here when playing
        starts.
    :param Union[float, int] end: The end X value for the sprite, the sprite will be positioned here when playing ends.
    :param int interpolation: The interpolation method whilst the sprite is moving from `begin` to `end`.
    :rtype: None
    """
    pass    


def set_tween_sprite_x_by_offset(tween_id: int, begin: Union[float, int], end: Union[float, int],
                                 interpolation: int) -> None:
    """
    Sets the X parameter of the given tween ID.

    A tween can modify several parameters of a sprite at the same time. Set the begin value and the end value and an
    interpolation method. A tween is just a template that can be applied to many sprites or chains at the same time with
    `play_tween_sprite()` or `add_tween_chain_sprite()`. This modifies the position of the sprite using its offset
    point, usually the center of the sprite.

    Available interpolation methods are `tween_linear()`, `tween_smooth1()`, `tween_smooth2()`, `tween_ease_in1()`,
    `tween_ease_in2()`, `tween_ease_out1()`, `tween_ease_out2()`, `tween_bounce()`, `tween_overshoot()`. Use an
    interpolation method of -1 to turn off interpolation on this value.

    These constants within the module can also be used: TWEEN_OFF, TWEEN_LINEAR, TWEEN_SMOOTH1, TWEEN_SMOOTH2,
    TWEEN_EASE_IN1, TWEEN_EASE_IN2, TWEEN_EASE_OUT1, TWEEN_EASE_OUT2, TWEEN_BOUNCE, and TWEEN_OVERSHOOT.

    :param int tween_id: ID of the tween to modify.
    :param Union[float, int] begin: The starting X value for the sprite, the sprite will be positioned here when playing
        starts.
    :param Union[float, int] end: The end X value for the sprite, the sprite will be positioned here when playing ends.
    :param int interpolation: The interpolation method whilst the sprite is moving from `begin` to `end`.
    :rtype: None
    """
    pass    


def set_tween_sprite_y(tween_id: int, begin: Union[float, int], end: Union[float, int],
                       interpolation: int) -> None:
    """
    Sets the Y parameter of the given tween ID.

    A tween can modify several parameters of a sprite at the same time. Set the begin value and the end value and an
    interpolation method. A tween is just a template that can be applied to many sprites or chains at the same time with
    `play_tween_sprite()` or `add_tween_chain_sprite()`. This modifies the position of the sprite using its top left
    corner.

    Available interpolation methods are `tween_linear()`, `tween_smooth1()`, `tween_smooth2()`, `tween_ease_in1()`,
    `tween_ease_in2()`, `tween_ease_out1()`, `tween_ease_out2()`, `tween_bounce()`, `tween_overshoot()`. Use an
    interpolation method of -1 to turn off interpolation on this value.

    These constants within the module can also be used: TWEEN_OFF, TWEEN_LINEAR, TWEEN_SMOOTH1, TWEEN_SMOOTH2,
    TWEEN_EASE_IN1, TWEEN_EASE_IN2, TWEEN_EASE_OUT1, TWEEN_EASE_OUT2, TWEEN_BOUNCE, and TWEEN_OVERSHOOT.

    :param int tween_id: ID of the tween to modify.
    :param Union[float, int] begin: The starting Y value for the sprite, the sprite will be positioned here when playing
        starts.
    :param Union[float, int] end: The end Y value for the sprite, the sprite will be positioned here when playing ends.
    :param int interpolation: The interpolation method whilst the sprite is moving from `begin` to `end`.
    :rtype: None
    """
    pass    


def set_tween_sprite_y_by_offset(tween_id: int, begin: Union[float, int], end: Union[float, int],
                                 interpolation: int) -> None:
    """
    Sets the Y parameter of the given tween ID.

    A tween can modify several parameters of a sprite at the same time. Set the begin value and the end value and an
    interpolation method. A tween is just a template that can be applied to many sprites or chains at the same time with
    `play_tween_sprite()` or `add_tween_chain_sprite()`. This modifies the position of the sprite using its offset
    point, usually the center of the sprite.

    Available interpolation methods are `tween_linear()`, `tween_smooth1()`, `tween_smooth2()`, `tween_ease_in1()`,
    `tween_ease_in2()`, `tween_ease_out1()`, `tween_ease_out2()`, `tween_bounce()`, `tween_overshoot()`. Use an
    interpolation method of -1 to turn off interpolation on this value.

    These constants within the module can also be used: TWEEN_OFF, TWEEN_LINEAR, TWEEN_SMOOTH1, TWEEN_SMOOTH2,
    TWEEN_EASE_IN1, TWEEN_EASE_IN2, TWEEN_EASE_OUT1, TWEEN_EASE_OUT2, TWEEN_BOUNCE, and TWEEN_OVERSHOOT.

    :param int tween_id: ID of the tween to modify.
    :param Union[float, int] begin: The starting Y value for the sprite, the sprite will be positioned here when playing
        starts.
    :param Union[float, int] end: The end Y value for the sprite, the sprite will be positioned here when playing ends.
    :param int interpolation: The interpolation method whilst the sprite is moving from `begin` to `end`.
    :rtype: None
    """
    pass    


def set_tween_text_alpha(tween_id: int, begin: int, end: int, interpolation: int) -> None:
    """
    Sets the alpha parameter of the given tween ID.

    A tween can modify several parameters of a text object at the same time. Set the begin value and the end value and
    an interpolation method. A tween is just a template that can be applied to many text objects or chains at the same
    time with `play_tween_text()` or `add_tween_chain_text()`.

    Available interpolation methods are `tween_linear()`, `tween_smooth1()`, `tween_smooth2()`, `tween_ease_in1()`,
    `tween_ease_in2()`, `tween_ease_out1()`, `tween_ease_out2()`, `tween_bounce()`, `tween_overshoot()`. Use an
    interpolation method of -1 to turn off interpolation on this value.

    These constants within the module can also be used: TWEEN_OFF, TWEEN_LINEAR, TWEEN_SMOOTH1, TWEEN_SMOOTH2,
    TWEEN_EASE_IN1, TWEEN_EASE_IN2, TWEEN_EASE_OUT1, TWEEN_EASE_OUT2, TWEEN_BOUNCE, and TWEEN_OVERSHOOT.

    :param int tween_id: ID of the tween to modify.
    :param int begin: The starting alpha color for the text, the text will be this color when playing starts.
    :param int end: The end alpha color for the text, the text will be this color when playing ends.
    :param int interpolation: The interpolation method whilst the text is moving from `begin` to `end`.
    :rtype: None
    """
    pass    


def set_tween_text_angle(tween_id: int, begin: Union[float, int], end: Union[float, int],
                         interpolation: int) -> None:
    """
    Sets the angle parameter of the given tween ID.

    A tween can modify several parameters of a text object at the same time. Set the begin value and the end value and
    an interpolation method. A tween is just a template that can be applied to many text objects or chains at the same
    time with `play_tween_text()` or `add_tween_chain_text()`.

    Available interpolation methods are `tween_linear()`, `tween_smooth1()`, `tween_smooth2()`, `tween_ease_in1()`,
    `tween_ease_in2()`, `tween_ease_out1()`, `tween_ease_out2()`, `tween_bounce()`, `tween_overshoot()`. Use an
    interpolation method of -1 to turn off interpolation on this value.

    These constants within the module can also be used: TWEEN_OFF, TWEEN_LINEAR, TWEEN_SMOOTH1, TWEEN_SMOOTH2,
    TWEEN_EASE_IN1, TWEEN_EASE_IN2, TWEEN_EASE_OUT1, TWEEN_EASE_OUT2, TWEEN_BOUNCE, and TWEEN_OVERSHOOT.

    :param int tween_id: ID of the tween to modify.
    :param Union[float, int] begin: The starting angle value for the text, the text will be rotated at this angle when
        playing starts.
    :param Union[float, int] end: The end angle value for the text, the text will be rotated at this angle when playing
        ends.
    :param int interpolation: The interpolation method whilst the text is moving from `begin` to `end`.
    :rtype: None
    """
    pass    


def set_tween_text_blue(tween_id: int, begin: int, end: int, interpolation: int) -> None:
    """
    Sets the blue parameter of the given tween ID.

    A tween can modify several parameters of a text object at the same time. Set the begin value and the end value and
    an interpolation method. A tween is just a template that can be applied to many text objects or chains at the same
    time with `play_tween_text()` or `add_tween_chain_text()`.

    Available interpolation methods are `tween_linear()`, `tween_smooth1()`, `tween_smooth2()`, `tween_ease_in1()`,
    `tween_ease_in2()`, `tween_ease_out1()`, `tween_ease_out2()`, `tween_bounce()`, `tween_overshoot()`. Use an
    interpolation method of -1 to turn off interpolation on this value.

    These constants within the module can also be used: TWEEN_OFF, TWEEN_LINEAR, TWEEN_SMOOTH1, TWEEN_SMOOTH2,
    TWEEN_EASE_IN1, TWEEN_EASE_IN2, TWEEN_EASE_OUT1, TWEEN_EASE_OUT2, TWEEN_BOUNCE, and TWEEN_OVERSHOOT.

    :param int tween_id: ID of the tween to modify.
    :param int begin: The starting blue color for the text, the text will be this color when playing starts.
    :param int end: The end blue color for the text, the text will be this color when playing ends.
    :param int interpolation: The interpolation method whilst the text is moving from `begin` to `end`.
    :rtype: None
    """
    pass    


def set_tween_text_green(tween_id: int, begin: int, end: int, interpolation: int) -> None:
    """
    Sets the green parameter of the given tween ID.

    A tween can modify several parameters of a text object at the same time. Set the begin value and the end value and
    an interpolation method. A tween is just a template that can be applied to many text objects or chains at the same
    time with `play_tween_text()` or `add_tween_chain_text()`.

    Available interpolation methods are `tween_linear()`, `tween_smooth1()`, `tween_smooth2()`, `tween_ease_in1()`,
    `tween_ease_in2()`, `tween_ease_out1()`, `tween_ease_out2()`, `tween_bounce()`, `tween_overshoot()`. Use an
    interpolation method of -1 to turn off interpolation on this value.

    These constants within the module can also be used: TWEEN_OFF, TWEEN_LINEAR, TWEEN_SMOOTH1, TWEEN_SMOOTH2,
    TWEEN_EASE_IN1, TWEEN_EASE_IN2, TWEEN_EASE_OUT1, TWEEN_EASE_OUT2, TWEEN_BOUNCE, and TWEEN_OVERSHOOT.

    :param int tween_id: ID of the tween to modify.
    :param int begin: The starting green color for the text, the text will be this color when playing starts.
    :param int end: The end green color for the text, the text will be this color when playing ends.
    :param int interpolation: The interpolation method whilst the text is moving from `begin` to `end`.
    :rtype: None
    """
    pass    


def set_tween_text_line_spacing(tween_id: int, begin: Union[float, int], end: Union[float, int],
                                interpolation: int) -> None:
    """
    Sets the line spacing parameter of the given tween ID.

    A tween can modify several parameters of a text object at the same time. Set the begin value and the end value and
    an interpolation method. A tween is just a template that can be applied to many text objects or chains at the same
    time with `play_tween_text()` or `add_tween_chain_text()`.

    Available interpolation methods are `tween_linear()`, `tween_smooth1()`, `tween_smooth2()`, `tween_ease_in1()`,
    `tween_ease_in2()`, `tween_ease_out1()`, `tween_ease_out2()`, `tween_bounce()`, `tween_overshoot()`. Use an
    interpolation method of -1 to turn off interpolation on this value.

    These constants within the module can also be used: TWEEN_OFF, TWEEN_LINEAR, TWEEN_SMOOTH1, TWEEN_SMOOTH2,
    TWEEN_EASE_IN1, TWEEN_EASE_IN2, TWEEN_EASE_OUT1, TWEEN_EASE_OUT2, TWEEN_BOUNCE, and TWEEN_OVERSHOOT.

    :param int tween_id: ID of the tween to modify.
    :param Union[float, int] begin: The starting Line Spacing value for the text, the text will have this spacing when
        playing starts.
    :param Union[float, int] end: The end line spacing value for the text, the text will have this spacing when playing
        ends.
    :param int interpolation: The interpolation method whilst the text is moving from `begin` to `end`.
    :rtype: None
    """
    pass    


def set_tween_text_red(tween_id: int, begin: int, end: int, interpolation: int) -> None:
    """
    Sets the red parameter of the given tween ID.

    A tween can modify several parameters of a text object at the same time. Set the begin value and the end value and
    an interpolation method. A tween is just a template that can be applied to many text objects or chains at the same
    time with `play_tween_text()` or `add_tween_chain_text()`.

    Available interpolation methods are `tween_linear()`, `tween_smooth1()`, `tween_smooth2()`, `tween_ease_in1()`,
    `tween_ease_in2()`, `tween_ease_out1()`, `tween_ease_out2()`, `tween_bounce()`, `tween_overshoot()`. Use an
    interpolation method of -1 to turn off interpolation on this value.

    These constants within the module can also be used: TWEEN_OFF, TWEEN_LINEAR, TWEEN_SMOOTH1, TWEEN_SMOOTH2,
    TWEEN_EASE_IN1, TWEEN_EASE_IN2, TWEEN_EASE_OUT1, TWEEN_EASE_OUT2, TWEEN_BOUNCE, and TWEEN_OVERSHOOT.

    :param int tween_id: ID of the tween to modify.
    :param int begin: The starting red color for the text, the text will be this color when playing starts.
    :param int end: The end red color for the text, the text will be this color when playing ends.
    :param int interpolation: The interpolation method whilst the text is moving from `begin` to `end`.
    :rtype: None
    """
    pass    


def set_tween_text_size(tween_id: int, begin: Union[float, int], end: Union[float, int],
                        interpolation: int) -> None:
    """
    Sets the size parameter of the given tween ID.

    A tween can modify several parameters of a text object at the same time. Set the begin value and the end value and
    an interpolation method. A tween is just a template that can be applied to many text objects or chains at the same
    time with `play_tween_text()` or `add_tween_chain_text()`.

    Available interpolation methods are `tween_linear()`, `tween_smooth1()`, `tween_smooth2()`, `tween_ease_in1()`,
    `tween_ease_in2()`, `tween_ease_out1()`, `tween_ease_out2()`, `tween_bounce()`, `tween_overshoot()`. Use an
    interpolation method of -1 to turn off interpolation on this value.

    These constants within the module can also be used: TWEEN_OFF, TWEEN_LINEAR, TWEEN_SMOOTH1, TWEEN_SMOOTH2,
    TWEEN_EASE_IN1, TWEEN_EASE_IN2, TWEEN_EASE_OUT1, TWEEN_EASE_OUT2, TWEEN_BOUNCE, and TWEEN_OVERSHOOT.

    :param int tween_id: ID of the tween to modify.
    :param Union[float, int] begin: The starting size value for the text, the text will be this size when playing
        starts.
    :param Union[float, int] end: The end size value for the text, the text will be this size when playing ends.
    :param int interpolation: The interpolation method whilst the text is moving from `begin` to `end`.
    :rtype: None
    """
    pass    


def set_tween_text_spacing(tween_id: int, begin: Union[float, int], end: Union[float, int],
                           interpolation: int) -> None:
    """
    Sets the spacing parameter of the given tween ID.

    A tween can modify several parameters of a text object at the same time. Set the begin value and the end value and
    an interpolation method. A tween is just a template that can be applied to many text objects or chains at the same
    time with `play_tween_text()` or `add_tween_chain_text()`.

    Available interpolation methods are `tween_linear()`, `tween_smooth1()`, `tween_smooth2()`, `tween_ease_in1()`,
    `tween_ease_in2()`, `tween_ease_out1()`, `tween_ease_out2()`, `tween_bounce()`, `tween_overshoot()`. Use an
    interpolation method of -1 to turn off interpolation on this value.

    These constants within the module can also be used: TWEEN_OFF, TWEEN_LINEAR, TWEEN_SMOOTH1, TWEEN_SMOOTH2,
    TWEEN_EASE_IN1, TWEEN_EASE_IN2, TWEEN_EASE_OUT1, TWEEN_EASE_OUT2, TWEEN_BOUNCE, and TWEEN_OVERSHOOT.

    :param int tween_id: ID of the tween to modify.
    :param Union[float, int] begin: The starting spacing value for the text, the text will have this spacing when
        playing starts.
    :param Union[float, int] end: The end spacing value for the text, the text will have this spacing when playing ends.
    :param int interpolation: The interpolation method whilst the text is moving from `begin` to `end`.
    :rtype: None
    """
    pass    


def set_tween_text_x(tween_id: int, begin: Union[float, int], end: Union[float, int],
                     interpolation: int) -> None:
    """
    Sets the X parameter of the given tween ID.

    A tween can modify several parameters of a text object at the same time. Set the begin value and the end value and
    an interpolation method. A tween is just a template that can be applied to many text objects or chains at the same
    time with `play_tween_text()` or `add_tween_chain_text()`.

    Available interpolation methods are `tween_linear()`, `tween_smooth1()`, `tween_smooth2()`, `tween_ease_in1()`,
    `tween_ease_in2()`, `tween_ease_out1()`, `tween_ease_out2()`, `tween_bounce()`, `tween_overshoot()`. Use an
    interpolation method of -1 to turn off interpolation on this value.

    These constants within the module can also be used: TWEEN_OFF, TWEEN_LINEAR, TWEEN_SMOOTH1, TWEEN_SMOOTH2,
    TWEEN_EASE_IN1, TWEEN_EASE_IN2, TWEEN_EASE_OUT1, TWEEN_EASE_OUT2, TWEEN_BOUNCE, and TWEEN_OVERSHOOT.

    :param int tween_id: ID of the tween to modify.
    :param Union[float, int] begin: The starting X value for the text, the text will be positioned here when playing
        starts.
    :param Union[float, int] end: The end X value for the text, the text will be positioned here when playing ends.
    :param int interpolation: The interpolation method whilst the text is moving from `begin` to `end`.
    :rtype: None
    """
    pass    


def set_tween_text_y(tween_id: int, begin: Union[float, int], end: Union[float, int],
                     interpolation: int) -> None:
    """
    Sets the Y parameter of the given tween ID.

    A tween can modify several parameters of a text object at the same time. Set the begin value and the end value and
    an interpolation method. A tween is just a template that can be applied to many text objects or chains at the same
    time with `play_tween_text()` or `add_tween_chain_text()`.

    Available interpolation methods are `tween_linear()`, `tween_smooth1()`, `tween_smooth2()`, `tween_ease_in1()`,
    `tween_ease_in2()`, `tween_ease_out1()`, `tween_ease_out2()`, `tween_bounce()`, `tween_overshoot()`. Use an
    interpolation method of -1 to turn off interpolation on this value.

    These constants within the module can also be used: TWEEN_OFF, TWEEN_LINEAR, TWEEN_SMOOTH1, TWEEN_SMOOTH2,
    TWEEN_EASE_IN1, TWEEN_EASE_IN2, TWEEN_EASE_OUT1, TWEEN_EASE_OUT2, TWEEN_BOUNCE, and TWEEN_OVERSHOOT.

    :param int tween_id: ID of the tween to modify.
    :param Union[float, int] begin: The starting Y value for the text, the text will be positioned here when playing
        starts.
    :param Union[float, int] end: The end Y value for the text, the text will be positioned here when playing ends.
    :param int interpolation: The interpolation method whilst the text is moving from `begin` to `end`.
    :rtype: None
    """
    pass    


def stop_tween_camera(tween_id: int, camera_id: int) -> None:
    """
    Stops a given tween ID if it is playing on a given camera.

    If the tween is not playing or has finished then this command has no effect. If the camera was in the middle of an
    interpolation it will remain at its current position, it will not skip to the end or return to the beginning.

    :param int tween_id: ID of the tween to stop.
    :param int camera_id: ID of the camera to stop.
    :rtype: None
    """
    pass    


def stop_tween_chain(chain_id: int) -> None:
    """
    Stops the given chain.

    If an item was in the middle of an interpolation it will stay at its current position, it will not skip to the end
    or return to the beginning. Playing the chain again will start it from the beginning.

    :param int chain_id: ID of the chain to modify.
    :rtype: None
    """
    pass    


def stop_tween_char(tween_id: int, text_id: int, char_index: int) -> None:
    """
    Stops a given tween ID if it is playing on a given character of a text object.

    If the tween is not playing or has finished then this command has no effect. If the character was in the middle of
    an interpolation it will remain at its current position, it will not skip to the end or return to the beginning.

    :param int tween_id: ID of the tween to stop.
    :param int text_id: ID of the text object containing the character.
    :param int char_index: The index of the character to stop, indices start at 0, if out of range it will be ignored.
    :rtype: None
    """
    pass    


def stop_tween_custom(tween_id: int) -> None:
    """
    Stops a given custom tween ID if it is playing.

    If the tween is not playing or has finished then this command has no effect. If the tween was in the middle of an
    interpolation its values will remain at their current values, it will not skip to the end or return to the
    beginning.

    :param int tween_id: ID of the tween to stop.
    :rtype: None
    """
    pass    


def stop_tween_object(tween_id: int, object_id: int) -> None:
    """
    Stops a given tween ID if it is playing on a given object.

    If the tween is not playing or has finished then this command has no effect. If the object was in the middle of an
    interpolation it will remain at its current position, it will not skip to the end or return to the beginning.

    :param int tween_id: ID of the tween to stop.
    :param int object_id: ID of the object to stop.
    :rtype: None
    """
    pass    


def stop_tween_sprite(tween_id: int, sprite_id: int) -> None:
    """
    Stops a given tween ID if it is playing on a given sprite.

    If the tween is not playing or has finished then this command has no effect. If the sprite was in the middle of an
    interpolation it will remain at its current position, it will not skip to the end or return to the beginning.

    :param int tween_id: ID of the tween to stop.
    :param int sprite_id: ID of the sprite to stop.
    :rtype: None
    """
    pass    


def stop_tween_text(tween_id: int, text_id: int) -> None:
    """
    Stops a given tween ID if it is playing on a given text object.

    If the tween is not playing or has finished then this command has no effect. If the text was in the middle of an
    interpolation it will remain at its current position, it will not skip to the end or return to the beginning.

    :param int tween_id: ID of the tween to stop.
    :param int text_id: ID of the text object to stop.
    :rtype: None
    """
    pass    


def tween_bounce() -> int:
    """
    Uses a bounce affect at the end of the interpolation.

    This is just a helper function to avoid having to remember the integer value for this which is 7.

    :rtype: int
    """
    pass    


def tween_ease_in1() -> int:
    """
    Uses a smooth curve to move from the start, this avoids a sudden start but still ends abruptly.

    This is just a helper function to avoid having to remember the integer value for this which is 3.

    :rtype: int
    """
    pass    


def tween_ease_in2() -> int:
    """
    Uses a smooth curve to move from the start, similar to `tween_ease_in1()` but more exaggerated.

    This is just a helper function to avoid having to remember the integer value for this which is 4.

    :rtype: int
    """
    pass    


def tween_ease_out1() -> int:
    """
    Uses a smooth curve to move towards the end, this avoids a sudden stop but still starts abruptly.

    This is just a helper function to avoid having to remember the integer value for this which is 5.

    :rtype: int
    """
    pass    


def tween_ease_out2() -> int:
    """
    Uses a smooth curve to move towards the end, similar to `tween_ease_out1()` but more exaggerated.

    This is just a helper function to avoid having to remember the integer value for this which is 6.

    :rtype: int
    """
    pass    


def tween_linear() -> int:
    """
    Uses linear interpolation to move from start to end, this is the simplest form of interpolation.

    This is just a helper function to avoid having to remember the integer value for this which is 0.

    :rtype: int
    """
    pass    


def tween_overshoot() -> int:
    """
    Uses an elastic affect at the end of the interpolation.

    This is the only interpolation method that exceeds the given range and is not suitable for colors. This is just a
    helper function to avoid having to remember the integer value for this which is 8.

    :rtype: int
    """
    pass    


def tween_smooth1() -> int:
    """
    Uses a smooth curve to move from start to end, this avoids a sudden start and stop.

    This is just a helper function to avoid having to remember the integer value for this which is 1.

    :rtype: int
    """
    pass    


def tween_smooth2() -> int:
    """
    Uses a smooth curve to move from start to end, similar to `tween_smooth1()` but more exaggerated.

    This is just a helper function to avoid having to remember the integer value for this which is 2.

    :rtype: int
    """
    pass    


def update_all_tweens(time: Union[float, int]) -> None:
    """
    Updates all tweens started on individual items and chains.

    The time value allows you to control how quickly the tweens advance, and in most cases the result of
    `get_frame_time()` should be used. The time can be set negative so that any playing tweens will play in reverse
    until they reach their start points, however they will not stop playing when they reach the beginning and will
    instead wait for the time to become positive again or wait for you to stop them manually.

    :param Union[float, int] time: The time to advance the tweens.
    :rtype: None
    """
    pass    


def update_tween_camera(tween_id: int, camera_id: int, time: Union[float, int]) -> None:
    """
    Updates a specific tween that has been started.

    The time value allows you to control how quickly the tween advances, and in most cases the result of
    `get_frame_time()` should be used. The time can be set negative so that the tween will play in reverse until it
    reaches its start point, however it will not stop playing when it reaches the beginning and will instead wait for
    the time to become positive again or wait for you to stop it manually. The tween must have already been started on
    the given camera with `play_tween_camera()` or nothing will happen. If you have started a lot of tweens playing,
    then updating each tween individually will be a lot more expensive than using `update_all_tweens()`.

    :param int tween_id: The ID of the tween to update.
    :param int camera_id: The ID of the object to update.
    :param Union[float, int] time: The time to advance the tween.
    :rtype: None
    """
    pass    


def update_tween_chain(chain_id: int, time: Union[float, int]) -> None:
    """
    Updates the given tween chain.

    The time value allows you to control how quickly the chain advances, and in most cases the result of
    `get_frame_time()` should be used. The time can be set negative so that the chain and the tweens it contains will
    play in reverse until it reaches the start point, however it will not stop playing when it reaches the beginning and
    will instead wait for the time to become positive again or wait for you to stop it manually.

    :param int chain_id: The ID of the chain to update.
    :param Union[float, int] time: The time to advance the chain.
    :rtype: None
    """
    pass    


def update_tween_char(tween_id: int, text_id: int, char_index: int, time: Union[float,
                      int]) -> None:
    """
    Updates a specific tween that has been started.

    The time value allows you to control how quickly the tween advances, and in most cases the result of
    `get_frame_time()` should be used. The time can be set negative so that the tween will play in reverse until it
    reaches its start point, however it will not stop playing when it reaches the beginning and will instead wait for
    the time to become positive again or wait for you to stop it manually. The tween must have already been started on
    the given character with `play_tween_char()` or nothing will happen. If you have started a lot of tweens playing,
    then updating each tween individually will be a lot more expensive than using `update_all_tweens()`.

    :param int tween_id: The ID of the tween to update.
    :param int text_id: The ID of the text to update.
    :param int char_index: The index of the character, indices start at 0, if out of range it will be ignored.
    :param Union[float, int] time: The time to advance the tween.
    :rtype: None
    """
    pass    


def update_tween_custom(tween_id: int, time: Union[float, int]) -> None:
    """
    Updates a specific tween that has been started.

    The time value allows you to control how quickly the tween advances, and in most cases the result of
    `get_frame_time()` should be used. The time can be set negative so that the tween will play in reverse until it
    reaches its start point, however it will not stop playing when it reaches the beginning and will instead wait for
    the time to become positive again or wait for you to stop it manually. If you have started a lot of tweens playing,
    then updating each tween individually will be a lot more expensive than using `update_all_tweens()`.

    :param int tween_id: The ID of the tween to update.
    :param Union[float, int] time: The time to advance the tween.
    :rtype: None
    """
    pass    


def update_tween_object(tween_id: int, object_id: int, time: Union[float, int]) -> None:
    """
    Updates a specific tween that has been started.

    The time value allows you to control how quickly the tween advances, and in most cases the result of
    `get_frame_time()` should be used. The time can be set negative so that the tween will play in reverse until it
    reaches its start point, however it will not stop playing when it reaches the beginning and will instead wait for
    the time to become positive again or wait for you to stop it manually. The tween must have already been started on
    the given object with `play_tween_object()` or nothing will happen. If you have started a lot of tweens playing,
    then updating each tween individually will be a lot more expensive than using `update_all_tweens()`.

    :param int tween_id: The ID of the tween to update.
    :param int object_id: The ID of the object to update.
    :param Union[float, int] time: The time to advance the tween.
    :rtype: None
    """
    pass    


def update_tween_sprite(tween_id: int, sprite_id: int, time: Union[float, int]) -> None:
    """
    Updates a specific tween that has been started.

    The time value allows you to control how quickly the tween advances, and in most cases the result of
    `get_frame_time()` should be used. The time can be set negative so that the tween will play in reverse until it
    reaches its start point, however it will not stop playing when it reaches the beginning and will instead wait for
    the time to become positive again or wait for you to stop it manually. The tween must have already been started on
    the given sprite with `play_tween_sprite()` or nothing will happen. If you have started a lot of tweens playing,
    then updating each tween individually will be a lot more expensive than using `update_all_tweens()`.

    :param int tween_id: The ID of the tween to update.
    :param int sprite_id: The ID of the sprite to update.
    :param Union[float, int] time: The time to advance the tween.
    :rtype: None
    """
    pass    


def update_tween_text(tween_id: int, text_id: int, time: Union[float, int]) -> None:
    """
    Updates a specific tween that has been started.

    The time value allows you to control how quickly the tween advances, and in most cases the result of
    `get_frame_time()` should be used. The time can be set negative so that the tween will play in reverse until it
    reaches its start point, however it will not stop playing when it reaches the beginning and will instead wait for
    the time to become positive again or wait for you to stop it manually. The tween must have already been started on
    the given text with `play_tween_text()` or nothing will happen. If you have started a lot of tweens playing, then
    updating each tween individually will be a lot more expensive than using `update_all_tweens()`.

    :param int tween_id: The ID of the tween to update.
    :param int text_id: The ID of the text to update.
    :param Union[float, int] time: The time to advance the tween.
    :rtype: None
    """
    pass    


def delete_video() -> None:
    """
    Stops any playing video and deletes any loaded video from memory.

    :rtype: None
    """
    pass    


def get_video_duration() -> float:
    """
    Returns the number of seconds the video lasts from start to finish.

    If this returns 0 then call it in a loop with `sync()` to wait for the video to finish loading the meta data. If it
    returns less than 0 then this platform does not support this command or an error occurred.

    example:
    ::
        duration = get_video_duration()
        while duration == 0:
            sync()
            duration = get_video_duration()

    :rtype: float
    """
    pass    


def get_video_height() -> float:
    """
    Returns the height in pixels of the currently loaded video, if this returns 0 then call it in a loop with `sync()`
    to wait for the video to finish loading the meta data.

    If it returns less than 0 then this platform does not support this command or an error occurred.

    example:
    ::
        height = get_video_height()
        while height == 0:
            sync()
            height = get_video_height()

    :rtype: float
    """
    pass    


def get_video_playing() -> bool:
    """
    Returns True if the video is currently playing, False if it has finished or been stopped with `stop_video()` or
    `pause_video()`.

    :rtype: bool
    """
    pass    


def get_video_position() -> float:
    """
    Returns the number of seconds played so far.

    :rtype: float
    """
    pass    


def get_video_width() -> float:
    """
    Returns the width in pixels of the currently loaded video, if this returns 0 then call it in a loop with `sync()` to
    wait for the video to finish loading the meta data.

    If it returns less than 0 then this platform does not support this command or an error occurred.

    example:
    ::
        width = get_video_width()
        while width == 0:
            sync()
            width = get_video_width()

    :rtype: float
    """
    pass    


def is_screen_recording() -> bool:
    """
    Returns True if the screen recording is currently active, False if it has stopped.

    On Android it could have stopped because the app was sent to the background, or another activity such as an In App
    Purchase was activated.

    :rtype: bool
    """
    pass    


def load_video(filename: str) -> int:
    """
    This command loads a video file ready to be played.

    Only one video file can be loaded at a time so loading a video deletes any existing video. On iOS, Android, and Mac
    it is recommended that you use .mp4 files with the H264 (MPEG-4 AVC) codec for video. For audio it must be encoded
    in MP3 or AAC. On Windows it depends on the codecs installed and although in some cases it will play mp4 files it is
    recommended that you use wmv on Windows for maximum support.

    Returns 1 if successful, 0 if there was an error, -1 if this platform does not support videos.

    :param str filename: The video file to load.
    :rtype: int
    """
    pass    


def pause_video() -> None:
    """
    Pauses the video and keeps it on screen.

    :rtype: None
    """
    pass    


def play_video() -> None:
    """
    Plays the video on screen or resumes it from pausing.

    You can either use this command or `play_video_to_image()`, but not both.

    If you pause the video you must resume it using the same command you used to start it.

    :rtype: None
    """
    pass    


def play_video_to_image(image_id: int) -> None:
    """
    Plays the video or resumes it from pausing.

    Plays the video to an image instead of to the screen, the image must not already exist. The image will be deleted
    when you call `delete_video()`, you must not delete it manually.

    You can either use this command or `play_video()`, but not both. If you pause the video you must resume it using the
    same command you used to start it, with the same parameters.

    Currently this is only supported on iOS 7.0 or above, Android 4.0.3 or above, and Windows.

    :param int image_id: An ID to use to reference the new image, must not already exist.
    :rtype: None
    """
    pass    


def play_youtube_video(video_id: str, start_time: Optional[Union[float, int]] = 0.0,
                       developer_key: Optional[str] = None) -> None:
    """
    Plays the specified Youtube video in a separate window above your app.

    For Android you must enable the Youtube Data API v3 in the Google Cloud Console for your app, and create an API key
    for it in the credentials section. You can create a key specifically for use with the Youtube API, or you can use an
    unrestricted key that can be used by multiple APIs. The `video_id` is the string that follows the ?v= part of a
    Youtube URL, e.g. "eLIgxYHCgWA". You can also specify a start time to start playing the video from part way through
    instead of starting from the beginning. The time is specified in seconds and accepts decimal values to represent
    fractions of a second.

    On Windows, Mac, and Linux this command will open the default browser to play the Youtube video. The developer key
    field is only required on Android.

    :param str video_id: The ID of the video, e.g. eLIgxYHCgWA
    :param Optional[Union[float, int]] start_time: The seek time in seconds from which to start playing the video
    :param Optional[str] developer_key: The API key credential created in the Google Cloud Console for the Youtube Data
        API v3.
    :rtype: None
    """
    pass    


def set_video_dimensions(x: Union[float, int], y: Union[float, int], width: Union[float, int],
                         height: Union[float, int]) -> None:
    """
    Sets the width, height, and position of the video whilst it is playing.

    Can be called before or during playback. The coordinates are in AGK screen coordinates based on your chosen virtual
    resolution. The aspect ratio is not preserved and will be stretched to fit your chosen dimensions. To find the
    actual size of the video in pixels use `get_video_width()` and `get_video_height()`. An exception to the stretching
    is Windows which will always keep the aspect ratio of the original video and add black borders where necessary.

    :param Union[float, int] x: The x coordinate to position the top left corner of the video.
    :param Union[float, int] y: The y coordinate to position the top left corner of the video.
    :param Union[float, int] width: The width to display the video.
    :param Union[float, int] height: The height to display the video.
    :rtype: None
    """
    pass    


def set_video_position(seconds: Union[float, int]) -> None:
    """
    Seeks the video to the given position.

    This is not guaranteed to be 100% accurate, the device may choose to seek to the nearest keyframe, which may be up
    to 10 seconds before or after your chosen time.

    :param Union[float, int] seconds: The position in the video to seek to.
    :rtype: None
    """
    pass    


def set_video_volume(volume: Union[float, int]) -> None:
    """
    Sets the volume of the video from 0 (muted) to 100 (full volume).

    :param Union[float, int] volume: The volume of the video in the range 0-100.
    :rtype: None
    """
    pass    


def start_screen_recording(filename: str, microphone: int) -> None:
    """
    Starts recording the screen and saving it to a file.

    Currently only supported on iOS 9.0 and above and Android 5.0 and above. On iOS the filename is ignored as the
    device will always save the recording in the camera roll.

    On Android the microphone parameter can be set to 1 to record audio from the device microphone during the recording.
    A value of 0 will produce a silent video as Android does not support recording audio directly from the app. However
    the audio output from the app may be audible through the microphone when using mode 1. Recording through the
    microphone requires that you enable the "RecordAudio" permission when exporting your APK.

    On iOS a microphone value of 1 will record both the app audio output and the microphone, a value of 0 will only
    record the app audio.

    On Android 6 and below the recording may stop at any time, for example if the app is sent to the background, or if
    another activity is activated such as an In App Purchase. On Android 7 and above the recording will pause when the
    app is in the background and resume when the app resumes. On iOS the recording will continue after such
    interruptions, until `stop_screen_recording()` is called.

    :param str filename: The path to save the video, should end in .mp4, can be a "raw:" file path.
    :param int microphone: 1 to record from the microphone, 0 to record from the device.
    :rtype: None
    """
    pass    


def stop_screen_recording() -> None:
    """
    Stops any current screen recording.

    If the recording has already stopped then this has no effect. On iOS this will prompt the user to edit and/or save
    the video, they can also choose to discard it. On Android the user sees no change and the video is silently saved in
    the background.

    :rtype: None
    """
    pass    


def stop_video() -> None:
    """
    Stops the video and removes it from view, using `play_video()` will start it from the beginning.

    :rtype: None
    """
    pass    


def set_object_mesh_cast_shadow(object_id: int, mesh: int, mode: int) -> None:
    """
    This method does nothing in AppGameKit Classic (and therefore AppGameKit for Python).  It is an AppGameKit Studio
    method added to AppGameKit Classic so they both can compile the same code.

    :param int object_id: The ID of the object to modify.
    :param int mesh: The index of the mesh to change, first mesh is at index 1.
    :param int mode: 1 to set this object's mesh as casting a shadow, 0 to never cast a shadow.
    :rtype: None
    """
    pass    


def set_shader_error_mode(mode: int) -> None:
    """
    This method does nothing in AppGameKit Classic (and therefore AppGameKit for Python).  It is an AppGameKit Studio
    method added to AppGameKit Classic so they both can compile the same code.

    :param int mode: The error mode to use from now on, default is 0
    :rtype: None
    """
    pass    


def get_drawing_3d_setup_time() -> float:
    """
    This method does nothing in AppGameKit Classic (and therefore AppGameKit for Python).  It is an AppGameKit Studio
    method added to AppGameKit Classic so they both can compile the same code.

    :rtype: float
    """
    pass    


def force_present() -> None:
    """
    This method does nothing in AppGameKit Classic (and therefore AppGameKit for Python).  It is an AppGameKit Studio
    method added to AppGameKit Classic so they both can compile the same code.

    :rtype: None
    """
    pass    


def get_clip_space_mode() -> int:
    """
    This method does nothing in AppGameKit Classic (and therefore AppGameKit for Python).  It is an AppGameKit Studio
    method added to AppGameKit Classic so they both can compile the same code.

    :rtype: int
    """
    pass    


def is_inverted_depth() -> int:
    """
    This method does nothing in AppGameKit Classic (and therefore AppGameKit for Python).  It is an AppGameKit Studio
    method added to AppGameKit Classic so they both can compile the same code.

    :rtype: int
    """
    pass    


def is_top_left_origin() -> int:
    """
    This method does nothing in AppGameKit Classic (and therefore AppGameKit for Python).  It is an AppGameKit Studio
    method added to AppGameKit Classic so they both can compile the same code.

    :rtype: int
    """
    pass    


def set_present_mode(mode: int) -> None:
    """
    This method does nothing in AppGameKit Classic (and therefore AppGameKit for Python).  It is an AppGameKit Studio
    method added to AppGameKit Classic so they both can compile the same code.

    :param int mode: Can either be delayed (mode=0) or immediate (mode=1), the default is immediate.
    :rtype: None
    """
    pass    


def get_color_alpha(color: int) -> int:
    """
    Returns the alpha component of a compound color value created with `make_color()`.

    :param int color: The color value to decompose.
    :rtype: int
    """
    pass    


def set_object_shader_constant_array_float_by_name(object_id: int, name: str, array_index: int,
                                                   value: Union[float, int]) -> None:
    """
    Sets a shader constant for an object by name, the constant must be marked as "uniform" in the shader source.

    The object will set the specified constant to this value for any shader that it is applied to it. Array indices
    start at 0, if the array index is out of bounds then it will be ignored and no changes will be made. This command
    can only set arrays of floats.

    :param int object_id: The ID of the object to modify.
    :param str name: The name of the constant to change, as defined in the shader source file.
    :param int array_index: The index of the element within the array to modify.
    :param Union[float, int] value: The new value to use.
    :rtype: None
    """
    pass    


def set_object_shader_constant_array_vec2_by_name(object_id: int, name: str, array_index: int,
                                                  value1: Union[float, int], value2: Union[float,
                                                  int]) -> None:
    """
    Sets a shader constant for an object by name, the constant must be marked as "uniform" in the shader source.

    The object will set the specified constant to this value for any shader that it is applied to it. Array indices
    start at 0, if the array index is out of bounds then it will be ignored and no changes will be made. This command
    can only set arrays of vec2.

    :param int object_id: The ID of the object to modify.
    :param str name: The name of the constant to change, as defined in the shader source file.
    :param int array_index: The index of the element within the array to modify.
    :param Union[float, int] value1: The X component of the new value.
    :param Union[float, int] value2: The Y component of the new value.
    :rtype: None
    """
    pass    


def set_object_shader_constant_array_vec3_by_name(object_id: int, name: str, array_index: int,
                                                  value1: Union[float, int], value2: Union[float,
                                                  int], value3: Union[float, int]) -> None:
    """
    Sets a shader constant for an object by name, the constant must be marked as "uniform" in the shader source.

    The object will set the specified constant to this value for any shader that it is applied to it. Array indices
    start at 0, if the array index is out of bounds then it will be ignored and no changes will be made. This command
    can only set arrays of vec3.

    Note that arrays of vec3 have an inefficient use of space and are padded to vec4, so may be slghtly slower than
    using an array of vec4.

    :param int object_id: The ID of the object to modify.
    :param str name: The name of the constant to change, as defined in the shader source file.
    :param int array_index: The index of the element within the array to modify.
    :param Union[float, int] value1: The X or R component of the new value.
    :param Union[float, int] value2: The Y or G component of the new value.
    :param Union[float, int] value3: The Z or B component of the new value.
    :rtype: None
    """
    pass    


def set_object_shader_constant_array_vec4_by_name(object_id: int, name: str, array_index: int,
                                                  value1: Union[float, int], value2: Union[float,
                                                  int], value3: Union[float, int],
                                                  value4: Union[float, int]) -> None:
    """
    Sets a shader constant for an object by name, the constant must be marked as "uniform" in the shader source.

    The object will set the specified constant to this value for any shader that it is applied to it. Array indices
    start at 0, if the array index is out of bounds then it will be ignored and no changes will be made. This command
    can only set arrays of vec4.

    :param int object_id: The ID of the object to modify.
    :param str name: The name of the constant to change, as defined in the shader source file.
    :param int array_index: The index of the element within the array to modify.
    :param Union[float, int] value1: The X or R component of the new value.
    :param Union[float, int] value2: The Y or G component of the new value.
    :param Union[float, int] value3: The Z or B component of the new value.
    :param Union[float, int] value4: The W or A component of the new value.
    :rtype: None
    """
    pass    


def set_shader_constant_array_float_by_name(shader_id: int, name: str, array_index: int,
                                            value: Union[float, int]) -> None:
    """
    Sets a shader constant array index by name, the constant must be marked as "uniform" in the shader source.

    Array indices start at 0, if the array index is out of bounds then it will be ignored and no changes will be made.
    This will affect all objects drawn using this shader.This command can only set arrays of float.

    :param int shader_id: The ID of the shader to modify.
    :param str name: The name of the constant to change, as defined in the shader source file.
    :param int array_index: The index of the element within the array to modify.
    :param Union[float, int] value: The new value to use.
    :rtype: None
    """
    pass    


def set_shader_constant_array_vec2_by_name(shader_id: int, name: str, array_index: int,
                                           value1: Union[float, int], value2: Union[float,
                                           int]) -> None:
    """
    Sets a shader constant array index by name, the constant must be marked as "uniform" in the shader source.

    Array indices start at 0, if the array index is out of bounds then it will be ignored and no changes will be made.
    This will affect all objects drawn using this shader.This command can only set arrays of vec2.

    :param int shader_id: The ID of the shader to modify.
    :param str name: The name of the constant to change, as defined in the shader source file.
    :param int array_index: The index of the element within the array to modify.
    :param Union[float, int] value1: The X component of the new value.
    :param Union[float, int] value2: The Y component of the new value.
    :rtype: None
    """
    pass    


def set_shader_constant_array_vec3_by_name(shader_id: int, name: str, array_index: int,
                                           value1: Union[float, int], value2: Union[float, int],
                                           value3: Union[float, int]) -> None:
    """
    Sets a shader constant array index by name, the constant must be marked as "uniform" in the shader source.

    Array indices start at 0, if the array index is out of bounds then it will be ignored and no changes will be made.
    This will affect all objects drawn using this shader.This command can only set arrays of vec3.

    Note that arrays of vec3 have an inefficient use of space and are padded to vec4, so may be slghtly slower than
    using an array of vec4.

    :param int shader_id: The ID of the shader to modify.
    :param str name: The name of the constant to change, as defined in the shader source file.
    :param int array_index: The index of the element within the array to modify.
    :param Union[float, int] value1: The X or R component of the new value.
    :param Union[float, int] value2: The Y or G component of the new value.
    :param Union[float, int] value3: The Z or B component of the new value.
    :rtype: None
    """
    pass    


def set_shader_constant_array_vec4_by_name(shader_id: int, name: str, array_index: int,
                                           value1: Union[float, int], value2: Union[float, int],
                                           value3: Union[float, int], value4: Union[float,
                                           int]) -> None:
    """
    Sets a shader constant array index by name, the constant must be marked as "uniform" in the shader source.

    Array indices start at 0, if the array index is out of bounds then it will be ignored and no changes will be made.
    This will affect all objects drawn using this shader.This command can only set arrays of vec4.

    :param int shader_id: The ID of the shader to modify.
    :param str name: The name of the constant to change, as defined in the shader source file.
    :param int array_index: The index of the element within the array to modify.
    :param Union[float, int] value1: The X or R component of the new value.
    :param Union[float, int] value2: The Y or G component of the new value.
    :param Union[float, int] value3: The Z or B component of the new value.
    :param Union[float, int] value4: The W or A component of the new value.
    :rtype: None
    """
    pass    


def create_window(x: Optional[int] = None, y: Optional[int] = None, width: int = 1024,
                  height: int = 768, fullscreen: Optional[Union[bool, int]] = False,
                  company_name: Optional[str] = None, app_name: Optional[str] = None,
                  show_appgamekit_logo: Optional[Union[bool, int]] = False) -> None:
    """
    Creates and shows the graphics window and initializes AppGameKit.  Can only be called once.

    By default, the write path will use the base name of the script file.  However, this can be overridden by setting
    the `app_name` parameter.  This parameter is ignored when running in a PyInstaller bundle.

    Providing `company_name` is optional and is used to build the write path.

    :param Optional[int] x: Initial x-coordinate of the window's upper left corner. If None, then the window centers
        horizontally.
    :param Optional[int] y: Initial y-coordinate of the window's upper left corner. If None, then the window centers
        vertically.
    :param int width: Initial width of the window. Default is 1024.
    :param int height: Initial height of the window. Default is 768.
    :param Optional[Union[bool, int]] fullscreen: When True, begins full screen; otherwise windowed.
    :param Optional[str] company_name: The company name for your app. The company name becomes a folder in the write
        file path.
    :param Optional[str] app_name: Overrides the app name derived from the script file name.  Ignored while running in a
        PyInstaller bundle.
    :param Optional[Union[bool, int]] show_appgamekit_logo: When True, shows the AppGameKit logo when the application
        starts.
    :rtype: None
    """
    pass    


def destroy_window() -> None:
    """
    Destroys the graphics window and tells AppGameKit to clean up its resources.

    :rtype: None
    """
    pass    


def enable_debug_log(enabled: Union[bool, int] = True) -> None:
    """
    Enables the log method.

    Use this command to enable the log method while developing and comment out to stop all log calls from writing to
    stdout at once.

    :param Union[bool, int] enabled: True to enable logging to stdout.
    :rtype: None
    """
    pass    


def import_plugin(name: str, commands: Optional[str] = None) -> Plugin:
    r"""
    Loads a Tier 1 plugin for use with AppGameKit for Python.

    Plugins must be in a subfolder of your main script file path called "Plugins\\<PluginName>". Unlike with Tier 1, the
    Commands.txt file must also be located in your plugin's folder and distributed with your game or its text must be
    passed as the `commands` parameter when calling this method.

    Information on plugins: https://www.appgamekit.com/documentation/guides/14_plugins.htm

    :param str name: The name of the plugin to load.
    :param Optional[str] commands: A string containing the text that would normally be in the plugin's commands.txt
        file.
    :rtype: Plugin
    """
    pass    


def _get_plugin_string(pointer: int) -> str:
    """
    Internal use only.

    Converts char pointers returned by plugin commands into Python strings and deletes the given char pointer to prevent
    memory leaks.

    If the resulting Python string needs to be passed as an argument to another plugin command, it will first need to be
    converted to a bytes object.

    For those familiar with AppGameKit Tier 2, get_plugin_string converts the char pointer to a Python string object and
    calls agk::DeleteString() on the given char pointer to prevent memory leaks.

    :param int pointer: The char pointer returned by a plugin command.
    :rtype: str
    """
    pass    


def _get_agk_function_ptr() -> int:
    """
    Internal use only.

    Returns the function pointer used to initialize plugins.

    :rtype: int
    """
    pass    


def create_memblock_from_bytes(data: bytes) -> int:
    """
    Creates a memblock and populates it with the data from the given bytes object.

    A memblock must not already exist with your chosen `memblock_id`.

    :param bytes data: A bytes object.
    :rtype: int
    """
    pass    


def create_memblock_id_from_bytes(memblock_id: int, data: bytes) -> None:
    """
    Creates a memblock and populates it with the data from the given bytes object.

    A memblock must not already exist with your chosen `memblock_id`.

    :param int memblock_id: The ID of the memblock you want to use.
    :param bytes data: A bytes object.
    :rtype: None
    """
    pass    


def set_memblock_bytes(memblock_id: int, offset: int, data: bytes) -> None:
    """
    Writes a bytes object at the given offset.

    The offset must be less than the size of the memblock. The first value is at offset 0.

    :param int memblock_id: The ID of the memblock.
    :param int offset: The offset from the start of the memblock to write to, between 0 and size (exclusive).
    :param bytes data: The bytes to write.
    :rtype: None
    """
    pass    


def get_memblock_bytes(memblock_id: int, start: Optional[int] = None,
                       stop: Optional[int] = None) -> bytes:
    """
    Returns a bytes object with data from a memblock.

    :param int memblock_id: The ID of the memblock.
    :param Optional[int] start: An integer number specifying at which position to start.  Default is 0
    :param Optional[int] stop: An integer number specifying at which position to stop (not included).  Defaults to the
        size of the memblock.
    :rtype: bytes
    """
    pass    


def get_image_rgba_bytes(image_id: int) -> bytes:
    """
    Returns RGBA data from an image as a bytes object.

    :param int image_id: The ID of the image.
    :rtype: bytes
    """
    pass    


def create_image_from_rgba_bytes(width: int, height: int, data: bytes) -> int:
    """
    Creates an image from a bytes object.

    If the image exists it will be overwritten, if not it will be created.

    The raw image data is in the format RGBA, with each component stored in a single byte, so each pixel takes up 4
    bytes. The size of the image data can be calculated by width*height*4 bytes (for now bit depth can be assumed to be
    32 bits = 4 bytes).

    Note that due to little endian format writing the image data with bytes will result in offsets 0=R, 1=G, 2=B, 3=A.

    The pixel data starts in the top left corner of the image an proceeds left to right then top to bottom resulting in
    the image being stored as a sequence of rows ending in the bottom right corner.

    This command uses a lot of GPU bandwidth so it is not recommended that this command be called every frame on large
    images.

    :param int width: The image width.
    :param int height: The image height.
    :param bytes data: A bytes object containing 32-bit RGBA data.
    :rtype: int
    """
    pass    


def create_image_id_from_rgba_bytes(image_id: int, width: int, height: int, data: bytes) -> None:
    """
    Creates an image from a bytes object.

    If the image exists it will be overwritten, if not it will be created.

    The raw image data is in the format RGBA, with each component stored in a single byte, so each pixel takes up 4
    bytes. The size of the image data can be calculated by width*height*4 bytes (for now bit depth can be assumed to be
    32 bits = 4 bytes).

    Note that due to little endian format writing the image data with bytes will result in offsets 0=R, 1=G, 2=B, 3=A.

    The pixel data starts in the top left corner of the image an proceeds left to right then top to bottom resulting in
    the image being stored as a sequence of rows ending in the bottom right corner.

    This command uses a lot of GPU bandwidth so it is not recommended that this command be called every frame on large
    images.

    :param int image_id: The ID of the image to create or modify.
    :param int width: The image width.
    :param int height: The image height.
    :param bytes data: A bytes object containing 32-bit RGBA data.
    :rtype: None
    """
    pass    


def create_image_from_png_bytes(data: bytes) -> int:
    """
    Creates an image from a bytes object. If the image exists it will be overwritten, if not it will be created. The
    bytes object must contain a valid PNG file such as one loaded with `create_memblock_id_from_file(`memblock_id`,
    "image.png")`.

    :param bytes data: A bytes object.
    :rtype: int
    """
    pass    


def create_image_id_from_png_bytes(image_id: int, data: bytes) -> None:
    """
    Creates an image from a bytes object. If the image exists it will be overwritten, if not it will be created. The
    bytes object must contain a valid PNG file such as one loaded with `create_memblock_id_from_file(`memblock_id`,
    "image.png")`.

    :param int image_id: The ID of the image to create.
    :param bytes data: A bytes object.
    :rtype: None
    """
    pass    


def create_sound_from_raw_bytes(channels: int, bits_per_sample: int, sample_rate: int,
                                data: bytes) -> int:
    """
    Creates an sound from a bytes object.

    This creates a new sound and returns the ID. This will not affect any sound instances already playing, only future
    ones.

    The bytes object holds raw sound data, for example in an 8bit stereo sound with 3 frames the raw data would look
    like this:
    ::
        byte offset 0 = Frame 1, left channel data
        byte offset 1 = Frame 1, right channel data
        byte offset 2 = Frame 2, left channel data
        byte offset 3 = Frame 2, right channel data
        byte offset 4 = Frame 3, left channel data
        byte offset 5 = Frame 3, right channel data

    Returns the ID of the new sound.

    :param int channels: The number of channels (1 or 2 supported).
    :param int bits_per_sample: The bits per sample (8 or 16 supported).
    :param int sample_rate: The sample rate of the sound.
    :param bytes data: A bytes object.
    :rtype: int
    """
    pass    


def create_sound_id_from_raw_bytes(sound_id: int, channels: int, bits_per_sample: int,
                                   sample_rate: int, data: bytes) -> None:
    """
    Creates an sound from a bytes object.

    This creates a new sound and returns the ID. This will not affect any sound instances already playing, only future
    ones.

    The bytes object holds raw sound data, for example in an 8bit stereo sound with 3 frames the raw data would look
    like this:
    ::
        byte offset 0 = Frame 1, left channel data
        byte offset 1 = Frame 1, right channel data
        byte offset 2 = Frame 2, left channel data
        byte offset 3 = Frame 2, right channel data
        byte offset 4 = Frame 3, left channel data
        byte offset 5 = Frame 3, right channel data

    Returns the ID of the new sound.

    :param int sound_id: The ID of the sound to create or modify.
    :param int channels: The number of channels (1 or 2 supported).
    :param int bits_per_sample: The bits per sample (8 or 16 supported).
    :param int sample_rate: The sample rate of the sound.
    :param bytes data: A bytes object.
    :rtype: None
    """
    pass    


def create_sound_from_ogg_bytes(data: bytes) -> int:
    """
    Creates an sound from a bytes object. This creates a new sound and returns the ID. This will not affect any sound
    instances already playing, only future ones. The bytes object must contain a valid OGG file such as one loaded with
    `create_memblock_id_from_file(`memblock_id`, "sound.ogg")`.

    :param bytes data: A bytes object.
    :rtype: int
    """
    pass    


def create_sound_id_from_ogg_bytes(sound_id: int, data: bytes) -> None:
    """
    Creates an sound from a bytes object. This creates a new sound and returns the ID. This will not affect any sound
    instances already playing, only future ones. The bytes object must contain a valid OGG file such as one loaded with
    `create_memblock_id_from_file(`memblock_id`, "sound.ogg")`.

    :param int sound_id: The ID of the sound to create or modify.
    :param bytes data: A bytes object.
    :rtype: None
    """
    pass    


def create_music_from_ogg_bytes(data: bytes) -> int:
    """
    Creates a music entity from a bytes object. This will create a new music ID and return it.  The bytes object must
    contain a valid OGG file such as one loaded with `create_memblock_id_from_file(`memblock_id`, "music.ogg")`.

    :param bytes data: A bytes object.
    :rtype: int
    """
    pass    


def create_music_id_from_ogg_bytes(music_id: int, data: bytes) -> None:
    """
    Creates a music entity from a bytes object. This will create a new music ID and return it.  The bytes object must
    contain a valid OGG file such as one loaded with `create_memblock_id_from_file(`memblock_id`, "music.ogg")`.

    :param int music_id: The ID of the music to create.
    :param bytes data: A bytes object.
    :rtype: None
    """
    pass    


def add_object_mesh_from_bytes(object_id: int, data: bytes) -> None:
    """
    Adds a new mesh to the object, constructed from the given bytes object.

    The first 4 bytes of the bytes object represent the number of vertices in the mesh.

    The second 4 bytes represent the number of indices in the mesh, this may be 0 in which case every three vertices
    represents a polygon, and no vertices can be shared. If the number of indices is greater than 0 then every three
    indices represent a polygon and vertices may be shared between polygons. Indices start at 0 so index 0 references
    the first vertex in the list.

    The third 4 bytes represents the number of attributes per vertex, e.g. position, normals, and UV data are all
    potential attributes, so a vertex containing all three would have 3 attributes. A vertex must have a position
    attribute, everything else is optional.

    The fourth 4 bytes represent the size of a single vertex in bytes, this can be calculated from the attribute data
    but is given for convenience.

    The fifth 4 bytes is offset for the beginning of the vertex data, so you can reach it easily.

    The sixth 4 bytes is offset for the beginning of the index data, will be 0 if there are no indices.

    After those 6 values, starting at offset 24, is the vertex attribute data. The vertex attribute data describes how
    the vertex data is laid out, for example if it has normals, UV data, etc.

    For each attribute there is a 1 byte data type, 1 byte component count, 1 byte normalize flag, 1 byte string length,
    and X bytes of string data for the attribute name. The data type will be 0 for floats (used for almost everything,
    e.g. position, normals, etc) or 1 for unsigned bytes (used for vertex colors).

    The component count is the number of values per attribute, e.g. position has 3 components, x,y,z, UV data has 2
    components, and vertex colors have 4 components. Note that any unsigned byte data type must have 4 components even
    if some are unused.

    The normalize flag is only used for unsigned byte data types and will convert values in the range 0-255 into 0.0-1.0
    for use in a shader. Usually the normalize flag will be 1 for color attributes and 0 for everything else.

    The string length byte must always be a multiple of 4 for alignment reasons, the string itself might have slightly
    less characters but always round up to the nearest multiple of 4 for the string length value. e.g. a string of
    length 5 should have a string length value of 8. Note that a string of 4 characters has a null terminator on the end
    which makes it length 5, so even though it has a multiple of 4 characters already it must use a length value of 8
    due to the null terminator.

    The attribute name string will be used by the shader to recognise what the vertex data is, the attribute names
    recognised by AGK are "position", "normal", "tangent", "binormal", "color", "uv", "uv1", "boneweights", and
    "boneindices", however you may add attributes with any name you like as long as you write a matching shader that has
    the same names. If you are not using your own shader and instead rely on AGK to draw the object then you must stick
    to the above attribute names.

    Following the attribute data is the raw vertex data, which usually starts with the "position" attribute. It will be
    a 4 byte float for the X position, a 4 byte float for the Y position, and a 4 byte float for the Z position. This
    continues for each attribute specified in the attribute data. Note that color data will always be 4 bytes in total,
    1 unsigned byte for each color channel. You can access individual vertices by using the vertex size provided above
    and the vertex index like so offset=vertexDataOffset+(vertexIndex*vertexSize).

    Lastly is the index data, if present. Each index is a 4 byte integer which references a vertex in the vertex data.
    Every three indices represents a polygon.

    :param int object_id: The ID of the object to modify.
    :param bytes data: A bytes object.
    :rtype: None
    """
    pass    


def create_object_from_mesh_bytes(data: bytes) -> int:
    """
    Creates an object with a single mesh constructed from the given bytes object.

    Any subsequent changes to the bytes object will not affect the mesh, you should call `set_object_mesh_from_bytes()`
    to modify an existing mesh.

    The first 4 bytes of the bytes object represent the number of vertices in the mesh.

    The second 4 bytes represent the number of indices in the mesh, this may be 0 in which case every three vertices
    represents a polygon, and no vertices can be shared. If the number of indices is greater than 0 then every three
    indices represent a polygon and vertices may be shared between polygons. Indices start at 0 so index 0 references
    the first vertex in the list.

    The third 4 bytes represents the number of attributes per vertex, e.g. position, normals, and UV data are all
    potential attributes, so a vertex containing all three would have 3 attributes. A vertex must have a position
    attribute, everything else is optional.

    The fourth 4 bytes represent the size of a single vertex in bytes, this can be calculated from the attribute data
    but is given for convenience.

    The fifth 4 bytes is offset for the beginning of the vertex data, so you can reach it easily.

    The sixth 4 bytes is offset for the beginning of the index data, will be 0 if there are no indices.

    After those 6 values, starting at offset 24, is the vertex attribute data. The vertex attribute data describes how
    the vertex data is laid out, for example if it has normals, UV data, etc.

    For each attribute there is a 1 byte data type, 1 byte component count, 1 byte normalize flag, 1 byte string length,
    and X bytes of string data for the attribute name. The data type will be 0 for floats (used for almost everything,
    e.g. position, normals, etc) or 1 for unsigned bytes (used for vertex colors).

    The component count is the number of values per attribute, e.g. position has 3 components, x,y,z, UV data has 2
    components, and vertex colors have 4 components. Note that any unsigned byte data type must have 4 components even
    if some are unused.

    The normalize flag is only used for unsigned byte data types and will convert values in the range 0-255 into 0.0-1.0
    for use in a shader. Usually the normalize flag will be 1 for color attributes and 0 for everything else.

    The string length byte must always be a multiple of 4 for alignment reasons, the string itself might have slightly
    less characters but always round up to the nearest multiple of 4 for the string length value. e.g. a string of
    length 5 should have a string length value of 8. Note that a string of 4 characters has a null terminator on the end
    which makes it length 5, so even though it has a multiple of 4 characters already it must use a length value of 8
    due to the null terminator.

    The attribute name string will be used by the shader to recognise what the vertex data is, the attribute names
    recognised by AGK are "position", "normal", "tangent", "binormal", "color", "uv", "uv1", "boneweights", and
    "boneindices", however you may add attributes with any name you like as long as you write a matching shader that has
    the same names. If you are not using your own shader and instead rely on AGK to draw the object then you must stick
    to the above attribute names.

    Following the attribute data is the raw vertex data, which usually starts with the "position" attribute. It will be
    a 4 byte float for the X position, a 4 byte float for the Y position, and a 4 byte float for the Z position. This
    continues for each attribute specified in the attribute data. Note that color data will always be 4 bytes in total,
    1 unsigned byte for each color channel. You can access individual vertices by using the vertex size provided above
    and the vertex index like so offset=vertexDataOffset+(vertexIndex*vertexSize).

    Lastly is the index data, if present. Each index is a 4 byte integer which references a vertex in the vertex data.
    Every three indices represents a polygon.

    :param bytes data: A bytes object to use to create the mesg.
    :rtype: int
    """
    pass    


def create_object_id_from_mesh_bytes(object_id: int, data: bytes) -> None:
    """
    Creates an object with a single mesh constructed from the given bytes object.

    Any subsequent changes to the bytes object will not affect the mesh, you should call `set_object_mesh_from_bytes()`
    to modify an existing mesh.

    The first 4 bytes of the bytes object represent the number of vertices in the mesh.

    The second 4 bytes represent the number of indices in the mesh, this may be 0 in which case every three vertices
    represents a polygon, and no vertices can be shared. If the number of indices is greater than 0 then every three
    indices represent a polygon and vertices may be shared between polygons. Indices start at 0 so index 0 references
    the first vertex in the list.

    The third 4 bytes represents the number of attributes per vertex, e.g. position, normals, and UV data are all
    potential attributes, so a vertex containing all three would have 3 attributes. A vertex must have a position
    attribute, everything else is optional.

    The fourth 4 bytes represent the size of a single vertex in bytes, this can be calculated from the attribute data
    but is given for convenience.

    The fifth 4 bytes is offset for the beginning of the vertex data, so you can reach it easily.

    The sixth 4 bytes is offset for the beginning of the index data, will be 0 if there are no indices.

    After those 6 values, starting at offset 24, is the vertex attribute data. The vertex attribute data describes how
    the vertex data is laid out, for example if it has normals, UV data, etc.

    For each attribute there is a 1 byte data type, 1 byte component count, 1 byte normalize flag, 1 byte string length,
    and X bytes of string data for the attribute name. The data type will be 0 for floats (used for almost everything,
    e.g. position, normals, etc) or 1 for unsigned bytes (used for vertex colors).

    The component count is the number of values per attribute, e.g. position has 3 components, x,y,z, UV data has 2
    components, and vertex colors have 4 components. Note that any unsigned byte data type must have 4 components even
    if some are unused.

    The normalize flag is only used for unsigned byte data types and will convert values in the range 0-255 into 0.0-1.0
    for use in a shader. Usually the normalize flag will be 1 for color attributes and 0 for everything else.

    The string length byte must always be a multiple of 4 for alignment reasons, the string itself might have slightly
    less characters but always round up to the nearest multiple of 4 for the string length value. e.g. a string of
    length 5 should have a string length value of 8. Note that a string of 4 characters has a null terminator on the end
    which makes it length 5, so even though it has a multiple of 4 characters already it must use a length value of 8
    due to the null terminator.

    The attribute name string will be used by the shader to recognise what the vertex data is, the attribute names
    recognised by AGK are "position", "normal", "tangent", "binormal", "color", "uv", "uv1", "boneweights", and
    "boneindices", however you may add attributes with any name you like as long as you write a matching shader that has
    the same names. If you are not using your own shader and instead rely on AGK to draw the object then you must stick
    to the above attribute names.

    Following the attribute data is the raw vertex data, which usually starts with the "position" attribute. It will be
    a 4 byte float for the X position, a 4 byte float for the Y position, and a 4 byte float for the Z position. This
    continues for each attribute specified in the attribute data. Note that color data will always be 4 bytes in total,
    1 unsigned byte for each color channel. You can access individual vertices by using the vertex size provided above
    and the vertex index like so offset=vertexDataOffset+(vertexIndex*vertexSize).

    Lastly is the index data, if present. Each index is a 4 byte integer which references a vertex in the vertex data.
    Every three indices represents a polygon.

    :param int object_id: The ID of the object to create.
    :param bytes data: A bytes object to use to create the mesg.
    :rtype: None
    """
    pass    


def set_object_mesh_from_bytes(object_id: int, mesh: int, data: bytes) -> None:
    """
    Changes an object's mesh based on the bytes object provided.

    The bytes object need not have the same number of attributes or vertices as the original mesh, but it will improve
    performance if it does.

    The first 4 bytes of the bytes object represent the number of vertices in the mesh.

    The second 4 bytes represent the number of indices in the mesh, this may be 0 in which case every three vertices
    represents a polygon, and no vertices can be shared. If the number of indices is greater than 0 then every three
    indices represent a polygon and vertices may be shared between polygons. Indices start at 0 so index 0 references
    the first vertex in the list.

    The third 4 bytes represents the number of attributes per vertex, e.g. position, normals, and UV data are all
    potential attributes, so a vertex containing all three would have 3 attributes. A vertex must have a position
    attribute, everything else is optional.

    The fourth 4 bytes represent the size of a single vertex in bytes, this can be calculated from the attribute data
    but is given for convenience.

    The fifth 4 bytes is offset for the beginning of the vertex data, so you can reach it easily.

    The sixth 4 bytes is offset for the beginning of the index data, will be 0 if there are no indices.

    After those 6 values, starting at offset 24, is the vertex attribute data. The vertex attribute data describes how
    the vertex data is laid out, for example if it has normals, UV data, etc.

    For each attribute there is a 1 byte data type, 1 byte component count, 1 byte normalize flag, 1 byte string length,
    and X bytes of string data for the attribute name. The data type will be 0 for floats (used for almost everything,
    e.g. position, normals, etc) or 1 for unsigned bytes (used for vertex colors).

    The component count is the number of values per attribute, e.g. position has 3 components, x,y,z, UV data has 2
    components, and vertex colors have 4 components. Note that any unsigned byte data type must have 4 components even
    if some are unused.

    The normalize flag is only used for unsigned byte data types and will convert values in the range 0-255 into 0.0-1.0
    for use in a shader. Usually the normalize flag will be 1 for color attributes and 0 for everything else.

    The string length byte must always be a multiple of 4 for alignment reasons, the string itself might have slightly
    less characters but always round up to the nearest multiple of 4 for the string length value. e.g. a string of
    length 5 should have a string length value of 8. Note that a string of 4 characters has a null terminator on the end
    which makes it length 5, so even though it has a multiple of 4 characters already it must use a length value of 8
    due to the null terminator.

    The attribute name string will be used by the shader to recognise what the vertex data is, the attribute names
    recognised by AGK are "position", "normal", "tangent", "binormal", "color", "uv", "uv1", "boneweights", and
    "boneindices", however you may add attributes with any name you like as long as you write a matching shader that has
    the same names. If you are not using your own shader and instead rely on AGK to draw the object then you must stick
    to the above attribute names.

    Following the attribute data is the raw vertex data, which usually starts with the "position" attribute. It will be
    a 4 byte float for the X position, a 4 byte float for the Y position, and a 4 byte float for the Z position. This
    continues for each attribute specified in the attribute data. Note that color data will always be 4 bytes in total,
    1 unsigned byte for each color channel. You can access individual vertices by using the vertex size provided above
    and the vertex index like so offset=vertexDataOffset+(vertexIndex*vertexSize).

    Lastly is the index data, if present. Each index is a 4 byte integer which references a vertex in the vertex data.
    Every three indices represents a polygon.

    If you plan on making regular changes to the mesh you should keep the bytes object around after using
    `set_object_mesh_from_bytes()` instead of regenerating from the object it every time you want to make a change. Then
    call `set_object_mesh_from_bytes()` again when you want to push your new changes onto the object.

    :param int object_id: The ID of the object to modify.
    :param int mesh: The index of the mesh to modify.
    :param bytes data: A bytes object to use to modify the mesh.
    :rtype: None
    """
    pass    


